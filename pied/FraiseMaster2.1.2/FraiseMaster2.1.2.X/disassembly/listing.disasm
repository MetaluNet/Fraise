Disassembly Listing for FraiseMaster1.2.2
Generated From:

---  C:/MCC18/v3_39/src/traditional/stdclib/vfprintf.c  -------------------------------------------------
2F1C  ECCA     CALL 0x3994, 0
2F1E  F01C     NOP
3994  CFD9     MOVFF FSR2L, POSTINC1
3996  FFE6     NOP
3998  CFDA     MOVFF FSR2H, POSTINC1
399A  FFE6     NOP
399C  CFE1     MOVFF FSR1L, FSR2L
399E  FFD9     NOP
39A0  CFE2     MOVFF FSR1H, FSR2H
39A2  FFDA     NOP
39A4  0012     RETURN 0
2F20  0EFB     MOVLW 0xFB
2F22  CFDB     MOVFF PLUSW2, PRODL
2F24  FFF3     NOP
2F26  06DB     DECF PLUSW2, F, ACCESS
2F28  50F3     MOVF PRODL, W, ACCESS
2F2A  0900     IORLW 0x0
2F2C  E00A     BZ 0x2F42
2F2E  EC18     CALL 0x3A30, 0
2F30  F01D     NOP
2F32  0EFA     MOVLW 0xFA
2F34  EC83     CALL 0x3B06, 0
2F36  F01D     NOP
2F38  E1F3     BNZ 0x2F20
2F3A  1C15     COMF digit_cnt, W, ACCESS
2F3C  E1F1     BNZ 0x2F20
2F3E  0E01     MOVLW 0x1
2F40  D001     BRA 0x2F44
2F42  0E00     MOVLW 0x0
2F44  EFF9     GOTO 0x39F2
2F46  F01C     NOP
39F2  52E5     MOVF POSTDEC1, F, ACCESS
39F4  CFE5     MOVFF POSTDEC1, FSR2H
39F6  FFDA     NOP
39F8  CFE7     MOVFF INDF1, FSR2L
39FA  FFD9     NOP
39FC  0012     RETURN 0
2F48  ECCA     CALL 0x3994, 0
2F4A  F01C     NOP
2F4C  0E3B     MOVLW 0x3B
2F4E  24E1     ADDWF FSR1L, W, ACCESS
2F50  E302     BNC 0x2F56
2F52  68E1     SETF FSR1L, ACCESS
2F54  52E6     MOVF POSTINC1, F, ACCESS
2F56  6EE1     MOVWF FSR1L, ACCESS
2F58  0E01     MOVLW 0x1
2F5A  6ADB     CLRF PLUSW2, ACCESS
2F5C  0E02     MOVLW 0x2
2F5E  6ADB     CLRF PLUSW2, ACCESS
2F60  0EF9     MOVLW 0xF9
2F62  CFDB     MOVFF PLUSW2, TBLPTRL
2F64  FFF6     NOP
2F66  0EFA     MOVLW 0xFA
2F68  CFDB     MOVFF PLUSW2, TBLPTRH
2F6A  FFF7     NOP
2F6C  0EFB     MOVLW 0xFB
2F6E  CFDB     MOVFF PLUSW2, TBLPTRU
2F70  FFF8     NOP
2F72  0008     TBLRD*
2F74  50F5     MOVF TABLAT, W, ACCESS
2F76  6EDF     MOVWF INDF2, ACCESS
2F78  50DF     MOVF INDF2, W, ACCESS
2F7A  E102     BNZ 0x2F80
2F7C  EF1D     GOTO 0x383A
2F7E  F01C     NOP
3834  D979     RCALL __pa_45
3836  EFB9     GOTO 0x2F72
3838  F017     NOP
3B28  50D9     MOVF FSR2L, W, ACCESS
3B2A  0FF9     ADDLW 0xF9
3B2C  6EE9     MOVWF FSR0L, ACCESS
3B2E  0EFF     MOVLW 0xFF
3B30  EF2D     GOTO 0x3A5A
3B32  F01D     NOP
2F80  0E25     MOVLW 0x25
2F82  5CDF     SUBWF INDF2, W, ACCESS
2F84  E002     BZ 0x2F8A
2F86  EF10     GOTO 0x3820
2F88  F01C     NOP
2F8A  0E03     MOVLW 0x3
2F8C  6ADB     CLRF PLUSW2, ACCESS
2F8E  0E04     MOVLW 0x4
2F90  6ADB     CLRF PLUSW2, ACCESS
2F92  0E05     MOVLW 0x5
2F94  6ADB     CLRF PLUSW2, ACCESS
2F96  0E06     MOVLW 0x6
2F98  6ADB     CLRF PLUSW2, ACCESS
2F9A  0E07     MOVLW 0x7
2F9C  6ADB     CLRF PLUSW2, ACCESS
2F9E  EC32     CALL 0x3864, 0
2FA0  F01C     NOP
2FA2  0E2D     MOVLW 0x2D
2FA4  5CDF     SUBWF INDF2, W, ACCESS
2FA6  E00C     BZ 0x2FC0
2FA8  0E2B     MOVLW 0x2B
2FAA  5CDF     SUBWF INDF2, W, ACCESS
2FAC  E009     BZ 0x2FC0
2FAE  0E20     MOVLW 0x20
2FB0  5CDF     SUBWF INDF2, W, ACCESS
2FB2  E006     BZ 0x2FC0
2FB4  0E23     MOVLW 0x23
2FF2  D7D5     BRA 0x2F9E
2FB6  5CDF     SUBWF INDF2, W, ACCESS
2FB8  E003     BZ 0x2FC0
2FBA  0E30     MOVLW 0x30
2FBC  5CDF     SUBWF INDF2, W, ACCESS
2FBE  E11A     BNZ 0x2FF4
2FC0  50DF     MOVF INDF2, W, ACCESS
2FC2  0A30     XORLW 0x30
2FC4  E014     BZ 0x2FEE
2FC6  0A13     XORLW 0x13
2FC8  E00F     BZ 0x2FE8
2FCA  0A03     XORLW 0x3
2FCC  E00A     BZ 0x2FE2
2FCE  0A0B     XORLW 0xB
2FD0  E005     BZ 0x2FDC
2FD2  0A06     XORLW 0x6
2FD4  E1E4     BNZ 0x2F9E
2FD6  0E03     MOVLW 0x3
2FD8  80DB     BSF PLUSW2, 0, ACCESS
2FDA  D7E1     BRA 0x2F9E
2FDC  0E03     MOVLW 0x3
2FDE  82DB     BSF PLUSW2, 1, ACCESS
2FE0  D7DE     BRA 0x2F9E
2FE2  0E03     MOVLW 0x3
2FE4  84DB     BSF PLUSW2, 2, ACCESS
2FE6  D7DB     BRA 0x2F9E
2FE8  0E03     MOVLW 0x3
2FEA  86DB     BSF PLUSW2, 3, ACCESS
2FEC  D7D8     BRA 0x2F9E
2FEE  0E03     MOVLW 0x3
2FF0  88DB     BSF PLUSW2, 4, ACCESS
2FF4  0E2A     MOVLW 0x2A
2FF6  5CDF     SUBWF INDF2, W, ACCESS
2FF8  E11B     BNZ 0x3030
2FFA  EC2E     CALL 0x385C, 0
2FFC  F01C     NOP
2FFE  EC7C     CALL 0x38F8, 0
3000  F01C     NOP
38F8  0E13     MOVLW 0x13
38FA  CFEE     MOVFF POSTINC0, PLUSW2
38FC  FFDB     NOP
38FE  0E14     MOVLW 0x14
3900  CFED     MOVFF POSTDEC0, PLUSW2
3902  FFDB     NOP
3002  E010     BZ 0x3024
3904  0E13     MOVLW 0x13
3906  CFDB     MOVFF PLUSW2, __tmp_0
3908  F014     NOP
390A  0E14     MOVLW 0x14
390C  CFDB     MOVFF PLUSW2, digit_cnt
390E  F015     NOP
3910  0100     MOVLB 0x0
3912  0E80     MOVLW 0x80
3914  1415     ANDWF digit_cnt, W, ACCESS
3916  0012     RETURN 0
3004  0E03     MOVLW 0x3
3006  80DB     BSF PLUSW2, 0, ACCESS
3008  6806     SETF pUEP, ACCESS
300A  6807     SETF size, ACCESS
300C  0E13     MOVLW 0x13
300E  CFDB     MOVFF PLUSW2, 0xB
3010  F00B     NOP
3012  0E14     MOVLW 0x14
3014  CFDB     MOVFF PLUSW2, 0xC
3016  F00C     NOP
3018  EC6E     CALL 0x4ADC, 0
301A  F025     NOP
301C  0E04     MOVLW 0x4
301E  C004     MOVFF i, PLUSW2
3020  FFDB     NOP
3022  D003     BRA 0x302A
3024  0E13     MOVLW 0x13
3026  EC65     CALL 0x38CA, 0
3028  F01C     NOP
302A  EC32     CALL 0x3864, 0
302C  F01C     NOP
302E  D00B     BRA 0x3046
3030  0E09     MOVLW 0x9
3032  6ADB     CLRF PLUSW2, ACCESS
3034  ECD3     CALL 0x39A6, 0
3036  F01C     NOP
3038  E003     BZ 0x3040
303E  D7FA     BRA 0x3034
39A6  CFDF     MOVFF INDF2, POSTINC1
39A8  FFE6     NOP
39AA  6AE6     CLRF POSTINC1, ACCESS
39AC  ECBF     CALL 0x4B7E, 0
39AE  F025     NOP
39B0  52E5     MOVF POSTDEC1, F, ACCESS
39B2  52E5     MOVF POSTDEC1, F, ACCESS
39B4  50F3     MOVF PRODL, W, ACCESS
39B6  0012     RETURN 0
303A  EC47     CALL 0x3A8E, 0
303C  F01D     NOP
3A8E  0E09     MOVLW 0x9
3A90  50DB     MOVF PLUSW2, W, ACCESS
3A92  0D0A     MULLW 0xA
3A94  50F3     MOVF PRODL, W, ACCESS
3A96  24DF     ADDWF INDF2, W, ACCESS
3A98  0FD0     ADDLW 0xD0
3A9A  6EE7     MOVWF INDF1, ACCESS
3A9C  0E09     MOVLW 0x9
3A9E  CFE7     MOVFF INDF1, PLUSW2
3AA0  FFDB     NOP
3AA2  EF32     GOTO 0x3864
3AA4  F01C     NOP
3040  0E09     MOVLW 0x9
3042  EC65     CALL 0x38CA, 0
3044  F01C     NOP
3046  0E03     MOVLW 0x3
3048  B0DB     BTFSC PLUSW2, 0, ACCESS
304A  98DB     BCF PLUSW2, 4, ACCESS
304C  0E2E     MOVLW 0x2E
304E  5CDF     SUBWF INDF2, W, ACCESS
3050  E11B     BNZ 0x3088
3052  EC32     CALL 0x3864, 0
3054  F01C     NOP
3056  0E2A     MOVLW 0x2A
3058  5CDF     SUBWF INDF2, W, ACCESS
305A  E10B     BNZ 0x3072
305C  EC2E     CALL 0x385C, 0
305E  F01C     NOP
3060  EC7C     CALL 0x38F8, 0
3062  F01C     NOP
385C  D929     RCALL __pa_34
385E  0E02     MOVLW 0x2
3860  EF1F     GOTO 0x3A3E
3862  F01D     NOP
3A3E  5E14     SUBWF __tmp_0, F, ACCESS
3A40  0E00     MOVLW 0x0
3A42  5A15     SUBWFB digit_cnt, F, ACCESS
3A44  0EF7     MOVLW 0xF7
3A46  C014     MOVFF __tmp_0, PLUSW2
3A48  FFDB     NOP
3A4A  0EF8     MOVLW 0xF8
3A4C  C015     MOVFF digit_cnt, PLUSW2
3A4E  FFDB     NOP
3A50  C014     MOVFF __tmp_0, FSR0L
3A52  FFE9     NOP
3A54  C015     MOVFF digit_cnt, FSR0H
3A56  FFEA     NOP
3A58  0012     RETURN 0
3AB0  0EF7     MOVLW 0xF7
3AB2  CFDB     MOVFF PLUSW2, __tmp_0
3AB4  F014     NOP
3AB6  0EF8     MOVLW 0xF8
3AB8  CFDB     MOVFF PLUSW2, digit_cnt
3ABA  F015     NOP
3ABC  0012     RETURN 0
3064  E103     BNZ 0x306C
3066  0E13     MOVLW 0x13
3068  ECB7     CALL 0x396E, 0
306A  F01C     NOP
396E  50DB     MOVF PLUSW2, W, ACCESS
3970  D8CE     RCALL __pa_42
3B0E  6EE7     MOVWF INDF1, ACCESS
3B10  0E05     MOVLW 0x5
3B12  CFE7     MOVFF INDF1, PLUSW2
3B14  FFDB     NOP
3B16  0012     RETURN 0
3972  0E01     MOVLW 0x1
3974  6EF3     MOVWF PRODL, ACCESS
3976  0E06     MOVLW 0x6
3978  CFF3     MOVFF PRODL, PLUSW2
397A  FFDB     NOP
397C  0012     RETURN 0
306C  EC32     CALL 0x3864, 0
306E  F01C     NOP
3070  D00B     BRA 0x3088
3072  0E09     MOVLW 0x9
3074  6ADB     CLRF PLUSW2, ACCESS
3076  ECD3     CALL 0x39A6, 0
3078  F01C     NOP
307A  E003     BZ 0x3082
3080  D7FA     BRA 0x3076
307C  EC47     CALL 0x3A8E, 0
307E  F01D     NOP
3082  0E09     MOVLW 0x9
3084  ECB7     CALL 0x396E, 0
3086  F01C     NOP
3088  0E68     MOVLW 0x68
308A  5CDF     SUBWF INDF2, W, ACCESS
308C  E107     BNZ 0x309C
308E  EC32     CALL 0x3864, 0
3090  F01C     NOP
3092  0E68     MOVLW 0x68
3094  5CDF     SUBWF INDF2, W, ACCESS
3096  E11D     BNZ 0x30D2
3098  0E03     MOVLW 0x3
309A  D018     BRA 0x30CC
309C  0E74     MOVLW 0x74
309E  5CDF     SUBWF INDF2, W, ACCESS
30A0  E017     BZ 0x30D0
30A2  0E7A     MOVLW 0x7A
30A4  5CDF     SUBWF INDF2, W, ACCESS
30A6  E014     BZ 0x30D0
30A8  0E48     MOVLW 0x48
30AA  5CDF     SUBWF INDF2, W, ACCESS
30AC  E006     BZ 0x30BA
30AE  0E54     MOVLW 0x54
30B0  5CDF     SUBWF INDF2, W, ACCESS
30B2  E003     BZ 0x30BA
30B4  0E5A     MOVLW 0x5A
30B6  5CDF     SUBWF INDF2, W, ACCESS
30B8  E102     BNZ 0x30BE
30BA  0E02     MOVLW 0x2
30BC  D007     BRA 0x30CC
30BE  0E6C     MOVLW 0x6C
30C0  5CDF     SUBWF INDF2, W, ACCESS
30C2  E003     BZ 0x30CA
30C4  0E6A     MOVLW 0x6A
30C6  5CDF     SUBWF INDF2, W, ACCESS
30C8  E104     BNZ 0x30D2
30CA  0E01     MOVLW 0x1
30CC  EC0A     CALL 0x3A14, 0
30CE  F01D     NOP
30D0  DBC9     RCALL __pa_1
3864  D961     RCALL __pa_45
3866  0008     TBLRD*
3868  50F5     MOVF TABLAT, W, ACCESS
386A  6EDF     MOVWF INDF2, ACCESS
386C  0012     RETURN 0
3A5A  20DA     ADDWFC FSR2H, W, ACCESS
3A5C  6EEA     MOVWF FSR0H, ACCESS
3A5E  2AEF     INCF INDF0, F, ACCESS
3A60  CFEE     MOVFF POSTINC0, TBLPTRL
3A62  FFF6     NOP
3A64  0E00     MOVLW 0x0
3A66  22EF     ADDWFC INDF0, F, ACCESS
3A68  CFEE     MOVFF POSTINC0, TBLPTRH
3A6A  FFF7     NOP
3A6C  22EF     ADDWFC INDF0, F, ACCESS
3A6E  CFEE     MOVFF POSTINC0, TBLPTRU
3A70  FFF8     NOP
3A72  0012     RETURN 0
30D2  50DF     MOVF INDF2, W, ACCESS
30D4  0A6E     XORLW 0x6E
30D6  E101     BNZ 0x30DA
30D8  D37F     BRA 0x37D8
30DA  0A1E     XORLW 0x1E
30DC  E101     BNZ 0x30E0
30DE  D192     BRA 0x3404
30E0  0A20     XORLW 0x20
30E2  E101     BNZ 0x30E6
30E4  D18F     BRA 0x3404
30E6  0A3F     XORLW 0x3F
30E8  E101     BNZ 0x30EC
30EA  D149     BRA 0x337E
30EC  0A1A     XORLW 0x1A
30EE  E101     BNZ 0x30F2
30F0  D146     BRA 0x337E
30F2  0A0D     XORLW 0xD
30F4  E101     BNZ 0x30F8
30F6  D143     BRA 0x337E
30F8  0A20     XORLW 0x20
30FA  E101     BNZ 0x30FE
30FC  D140     BRA 0x337E
30FE  0A3A     XORLW 0x3A
3100  E101     BNZ 0x3104
3102  D13D     BRA 0x337E
3104  0A20     XORLW 0x20
3106  E101     BNZ 0x310A
3108  D13A     BRA 0x337E
310A  0A26     XORLW 0x26
310C  E101     BNZ 0x3110
310E  D135     BRA 0x337A
3110  0A0D     XORLW 0xD
3112  E101     BNZ 0x3116
3114  D132     BRA 0x337A
3116  0A1A     XORLW 0x1A
3118  E101     BNZ 0x311C
311A  D0D9     BRA 0x32CE
311C  0A20     XORLW 0x20
311E  E04A     BZ 0x31B4
3120  0A30     XORLW 0x30
3122  E01F     BZ 0x3162
3124  0A46     XORLW 0x46
3126  E00E     BZ 0x3144
3128  0A25     XORLW 0x25
312A  E001     BZ 0x312E
312C  D383     BRA 0x3834
312E  50D9     MOVF FSR2L, W, ACCESS
3130  0FF9     ADDLW 0xF9
3132  6EE9     MOVWF FSR0L, ACCESS
3134  0EFF     MOVLW 0xFF
3136  20DA     ADDWFC FSR2H, W, ACCESS
3138  6EEA     MOVWF FSR0H, ACCESS
313A  0E01     MOVLW 0x1
313C  5EEE     SUBWF POSTINC0, F, ACCESS
313E  0E00     MOVLW 0x0
3140  5AEE     SUBWFB POSTINC0, F, ACCESS
3142  5AEE     SUBWFB POSTINC0, F, ACCESS
3144  EC18     CALL 0x3A30, 0
3146  F01D     NOP
3148  0E25     MOVLW 0x25
314A  6EE6     MOVWF POSTINC1, ACCESS
314C  DB95     RCALL __pa_3
314E  E103     BNZ 0x3156
3150  1C15     COMF digit_cnt, W, ACCESS
3152  E101     BNZ 0x3156
3154  D369     BRA 0x3828
3156  EC14     CALL 0x3A28, 0
3158  F01D     NOP
315A  E201     BC 0x315E
315C  D36B     BRA 0x3834
315E  2ADB     INCF PLUSW2, F, ACCESS
3160  D369     BRA 0x3834
3162  0E08     MOVLW 0x8
3164  6ADB     CLRF PLUSW2, ACCESS
3166  0E04     MOVLW 0x4
3168  50DB     MOVF PLUSW2, W, ACCESS
316A  0801     SUBLW 0x1
316C  E206     BC 0x317A
316E  0E04     MOVLW 0x4
3170  04DB     DECF PLUSW2, W, ACCESS
3172  ECDC     CALL 0x39B8, 0
3174  F01C     NOP
3176  50DB     MOVF PLUSW2, W, ACCESS
3178  DB8B     RCALL __pa_4
317A  0E08     MOVLW 0x8
317C  50DB     MOVF PLUSW2, W, ACCESS
317E  E009     BZ 0x3192
3180  0E03     MOVLW 0x3
3182  50DB     MOVF PLUSW2, W, ACCESS
3184  0B01     ANDLW 0x1
3186  E105     BNZ 0x3192
3188  DB72     RCALL __pa_2
318A  E001     BZ 0x318E
318C  D34D     BRA 0x3828
318E  0E08     MOVLW 0x8
3190  6ADB     CLRF PLUSW2, ACCESS
3192  DB64     RCALL __pa_0
3194  CFEF     MOVFF INDF0, INDF2
3196  FFDF     NOP
3198  EC8C     CALL 0x3B18, 0
319A  F01D     NOP
319C  E103     BNZ 0x31A4
319E  1C15     COMF digit_cnt, W, ACCESS
31A0  E101     BNZ 0x31A4
31A2  D342     BRA 0x3828
31A4  EC14     CALL 0x3A28, 0
31A6  F01D     NOP
31A8  E301     BNC 0x31AC
31AA  2ADB     INCF PLUSW2, F, ACCESS
31AC  DB60     RCALL __pa_2
31AE  E101     BNZ 0x31B2
31B0  D341     BRA 0x3834
31B2  D33A     BRA 0x3828
31B4  0E07     MOVLW 0x7
31B6  50DB     MOVF PLUSW2, W, ACCESS
31B8  0802     SUBLW 0x2
31BA  E10F     BNZ 0x31DA
31BC  EC58     CALL 0x3AB0, 0
31BE  F01D     NOP
31C0  0E03     MOVLW 0x3
31C2  EC1F     CALL 0x3A3E, 0
31C4  F01D     NOP
31C6  0E0E     MOVLW 0xE
31C8  CFEE     MOVFF POSTINC0, PLUSW2
31CA  FFDB     NOP
31CC  0E0F     MOVLW 0xF
31CE  CFEE     MOVFF POSTINC0, PLUSW2
31D0  FFDB     NOP
31D2  0E10     MOVLW 0x10
31D4  CFEE     MOVFF POSTINC0, PLUSW2
31D6  FFDB     NOP
31D8  D020     BRA 0x321A
31DA  0EF7     MOVLW 0xF7
31DC  CFDB     MOVFF PLUSW2, sign_char
31DE  F017     NOP
31E0  0EF8     MOVLW 0xF8
31E2  CFDB     MOVFF PLUSW2, buf
31E4  F018     NOP
31E6  0E02     MOVLW 0x2
31E8  5E17     SUBWF sign_char, F, ACCESS
31EA  0E00     MOVLW 0x0
31EC  5A18     SUBWFB buf, F, ACCESS
31EE  0EF7     MOVLW 0xF7
31F0  C017     MOVFF sign_char, PLUSW2
31F2  FFDB     NOP
31F4  0EF8     MOVLW 0xF8
31F6  C018     MOVFF buf, PLUSW2
31F8  FFDB     NOP
31FA  C017     MOVFF sign_char, FSR0L
31FC  FFE9     NOP
31FE  C018     MOVFF buf, FSR0H
3200  FFEA     NOP
3202  EC0F     CALL 0x3A1E, 0
3204  F01D     NOP
3206  6A16     CLRF prefix_cnt, ACCESS
3208  0E0E     MOVLW 0xE
320A  C014     MOVFF __tmp_0, PLUSW2
320C  FFDB     NOP
320E  0E0F     MOVLW 0xF
3210  C015     MOVFF digit_cnt, PLUSW2
3212  FFDB     NOP
3214  0E10     MOVLW 0x10
3216  C016     MOVFF prefix_cnt, PLUSW2
3218  FFDB     NOP
321A  0E0E     MOVLW 0xE
321C  CFDB     MOVFF PLUSW2, POSTINC1
321E  FFE6     NOP
3220  0E0F     MOVLW 0xF
3222  CFDB     MOVFF PLUSW2, POSTINC1
3224  FFE6     NOP
3226  0E10     MOVLW 0x10
3228  CFDB     MOVFF PLUSW2, POSTINC1
322A  FFE6     NOP
322C  EC9B     CALL 0x4736, 0
322E  F023     NOP
3230  52E5     MOVF POSTDEC1, F, ACCESS
3232  52E5     MOVF POSTDEC1, F, ACCESS
3234  52E5     MOVF POSTDEC1, F, ACCESS
3236  0E13     MOVLW 0x13
3238  C005     MOVFF precision, PLUSW2
323A  FFDB     NOP
323C  0E14     MOVLW 0x14
323E  C006     MOVFF pUEP, PLUSW2
3240  FFDB     NOP
3242  0E06     MOVLW 0x6
3244  50DB     MOVF PLUSW2, W, ACCESS
3246  E005     BZ 0x3252
3248  0E13     MOVLW 0x13
324A  EC53     CALL 0x3AA6, 0
324C  F01D     NOP
324E  E201     BC 0x3252
3250  DB6A     RCALL __pa_11
3926  0E05     MOVLW 0x5
3928  50DB     MOVF PLUSW2, W, ACCESS
392A  6EE6     MOVWF POSTINC1, ACCESS
392C  50D9     MOVF FSR2L, W, ACCESS
392E  0F13     ADDLW 0x13
3930  D901     RCALL __pa_46
3932  52E5     MOVF POSTDEC1, F, ACCESS
3934  50E7     MOVF INDF1, W, ACCESS
3936  6EEE     MOVWF POSTINC0, ACCESS
3938  6AED     CLRF POSTDEC0, ACCESS
393A  0012     RETURN 0
3252  EC77     CALL 0x3AEE, 0
3254  F01D     NOP
3256  E202     BC 0x325C
3AEE  0E13     MOVLW 0x13
3AF0  50DB     MOVF PLUSW2, W, ACCESS
3AF2  6EF3     MOVWF PRODL, ACCESS
3AF4  0E04     MOVLW 0x4
3AF6  EF60     GOTO 0x38C0
3AF8  F01C     NOP
3258  0E13     MOVLW 0x13
325A  DB37     RCALL __pa_7
325C  EC3A     CALL 0x3A74, 0
325E  F01D     NOP
3A74  0E04     MOVLW 0x4
3A76  CFDB     MOVFF PLUSW2, POSTINC1
3A78  FFE6     NOP
3A7A  0E13     MOVLW 0x13
3A7C  50DB     MOVF PLUSW2, W, ACCESS
3A7E  52E5     MOVF POSTDEC1, F, ACCESS
3A80  5CE7     SUBWF INDF1, W, ACCESS
3A82  DF9A     RCALL __pa_18
3A84  50DB     MOVF PLUSW2, W, ACCESS
3A86  DF04     RCALL __pa_4
3260  E006     BZ 0x326E
3262  0E04     MOVLW 0x4
3264  EC53     CALL 0x3AA6, 0
3266  F01D     NOP
3268  E202     BC 0x326E
3A88  0E06     MOVLW 0x6
3A8A  50DB     MOVF PLUSW2, W, ACCESS
3A8C  0012     RETURN 0
326A  0E05     MOVLW 0x5
326C  DB2E     RCALL __pa_7
326E  0E03     MOVLW 0x3
3270  B0DB     BTFSC PLUSW2, 0, ACCESS
3272  D005     BRA 0x327E
3274  DAFC     RCALL __pa_2
3276  E001     BZ 0x327A
3278  D2D7     BRA 0x3828
327A  0E08     MOVLW 0x8
327C  6ADB     CLRF PLUSW2, ACCESS
327E  0E09     MOVLW 0x9
3280  6ADB     CLRF PLUSW2, ACCESS
3282  0E0E     MOVLW 0xE
3284  CFDB     MOVFF PLUSW2, TBLPTRL
3286  FFF6     NOP
3288  0E0F     MOVLW 0xF
328A  CFDB     MOVFF PLUSW2, TBLPTRH
328C  FFF7     NOP
328E  0E10     MOVLW 0x10
3290  CFDB     MOVFF PLUSW2, TBLPTRU
3292  FFF8     NOP
3294  0008     TBLRD*
3296  50F5     MOVF TABLAT, W, ACCESS
3298  6EDF     MOVWF INDF2, ACCESS
329A  50DF     MOVF INDF2, W, ACCESS
329C  E014     BZ 0x32C6
329E  EC7D     CALL 0x3AFA, 0
32A0  F01D     NOP
32A2  E211     BC 0x32C6
32BA  50D9     MOVF FSR2L, W, ACCESS
32BC  0F0E     ADDLW 0xE
32BE  6EE9     MOVWF FSR0L, ACCESS
32C0  0E00     MOVLW 0x0
32C2  DBCB     RCALL __pa_30
32C4  D7E7     BRA 0x3294
3AFA  0E04     MOVLW 0x4
3AFC  50DB     MOVF PLUSW2, W, ACCESS
3AFE  6EF3     MOVWF PRODL, ACCESS
3B00  0E09     MOVLW 0x9
3B02  EF60     GOTO 0x38C0
3B04  F01C     NOP
32A4  EC8C     CALL 0x3B18, 0
32A6  F01D     NOP
32A8  E103     BNZ 0x32B0
32AA  1C15     COMF digit_cnt, W, ACCESS
32AC  E101     BNZ 0x32B0
32AE  D2BC     BRA 0x3828
32B0  DBBB     RCALL __pa_27
32B2  E301     BNC 0x32B6
32B4  2ADB     INCF PLUSW2, F, ACCESS
32B6  0E09     MOVLW 0x9
32B8  2ADB     INCF PLUSW2, F, ACCESS
32C6  DAD3     RCALL __pa_2
32C8  E101     BNZ 0x32CC
32CA  D2B4     BRA 0x3834
32CC  D2AD     BRA 0x3828
32CE  DAC6     RCALL __pa_0
32D0  0E11     MOVLW 0x11
32D2  CFEE     MOVFF POSTINC0, PLUSW2
32D4  FFDB     NOP
32D6  0E12     MOVLW 0x12
32D8  CFED     MOVFF POSTDEC0, PLUSW2
32DA  FFDB     NOP
32DC  0E11     MOVLW 0x11
32DE  CFDB     MOVFF PLUSW2, POSTINC1
32E0  FFE6     NOP
32E2  0E12     MOVLW 0x12
32E4  CFDB     MOVFF PLUSW2, POSTINC1
32E6  FFE6     NOP
32E8  EC8D     CALL 0x471A, 0
32EA  F023     NOP
32EC  52E5     MOVF POSTDEC1, F, ACCESS
32EE  52E5     MOVF POSTDEC1, F, ACCESS
32F0  0E13     MOVLW 0x13
32F2  CFF3     MOVFF PRODL, PLUSW2
32F4  FFDB     NOP
32F6  0E14     MOVLW 0x14
32F8  CFF4     MOVFF PRODH, PLUSW2
32FA  FFDB     NOP
32FC  0E06     MOVLW 0x6
32FE  50DB     MOVF PLUSW2, W, ACCESS
3300  E004     BZ 0x330A
3302  0E13     MOVLW 0x13
3304  DBD0     RCALL __pa_33
3306  E201     BC 0x330A
3308  DB0E     RCALL __pa_11
330A  EC77     CALL 0x3AEE, 0
330C  F01D     NOP
330E  E202     BC 0x3314
3310  0E13     MOVLW 0x13
3312  DADB     RCALL __pa_7
3314  DBAF     RCALL __pa_31
39B8  6EE7     MOVWF INDF1, ACCESS
39BA  0E08     MOVLW 0x8
39BC  CFE7     MOVFF INDF1, PLUSW2
39BE  FFDB     NOP
39C0  0012     RETURN 0
3316  E005     BZ 0x3322
3318  0E04     MOVLW 0x4
331A  DBC5     RCALL __pa_33
331C  E202     BC 0x3322
3AA6  50DB     MOVF PLUSW2, W, ACCESS
3AA8  6EF3     MOVWF PRODL, ACCESS
3AAA  0E05     MOVLW 0x5
3AAC  EF60     GOTO 0x38C0
3AAE  F01C     NOP
331E  0E05     MOVLW 0x5
3320  DAD4     RCALL __pa_7
38CA  50DB     MOVF PLUSW2, W, ACCESS
38CC  6EE7     MOVWF INDF1, ACCESS
38CE  0E04     MOVLW 0x4
38D0  CFE7     MOVFF INDF1, PLUSW2
38D2  FFDB     NOP
38D4  0012     RETURN 0
3322  0E03     MOVLW 0x3
3324  B0DB     BTFSC PLUSW2, 0, ACCESS
3326  D005     BRA 0x3332
3328  DAA2     RCALL __pa_2
332A  E001     BZ 0x332E
332C  D27D     BRA 0x3828
332E  0E08     MOVLW 0x8
3330  6ADB     CLRF PLUSW2, ACCESS
3332  0E09     MOVLW 0x9
3334  6ADB     CLRF PLUSW2, ACCESS
3336  0E11     MOVLW 0x11
3338  CFDB     MOVFF PLUSW2, FSR0L
333A  FFE9     NOP
333C  0E12     MOVLW 0x12
333E  CFDB     MOVFF PLUSW2, FSR0H
3340  FFEA     NOP
3342  CFEF     MOVFF INDF0, INDF2
3344  FFDF     NOP
3346  50DF     MOVF INDF2, W, ACCESS
3348  E014     BZ 0x3372
334A  DBD7     RCALL __pa_40
334C  E212     BC 0x3372
3362  0E11     MOVLW 0x11
3364  2ADB     INCF PLUSW2, F, ACCESS
3366  CFDB     MOVFF PLUSW2, FSR0L
3368  FFE9     NOP
336A  0E12     MOVLW 0x12
336C  E3E8     BNC 0x333E
336E  2ADB     INCF PLUSW2, F, ACCESS
3370  D7E6     BRA 0x333E
334E  DBE4     RCALL __pa_43
3350  E103     BNZ 0x3358
3352  1C15     COMF digit_cnt, W, ACCESS
3354  E101     BNZ 0x3358
3356  D268     BRA 0x3828
3358  DB67     RCALL __pa_27
335A  E301     BNC 0x335E
335C  2ADB     INCF PLUSW2, F, ACCESS
335E  0E09     MOVLW 0x9
3360  2ADB     INCF PLUSW2, F, ACCESS
3372  DA7D     RCALL __pa_2
3374  E101     BNZ 0x3378
3376  D25E     BRA 0x3834
3378  D257     BRA 0x3828
337A  0E03     MOVLW 0x3
337C  8EDB     BSF PLUSW2, 7, ACCESS
337E  0E07     MOVLW 0x7
3380  04DB     DECF PLUSW2, W, ACCESS
3382  E110     BNZ 0x33A4
3384  DB95     RCALL __pa_34
3386  0E04     MOVLW 0x4
3388  DB5A     RCALL __pa_29
338A  0E0A     MOVLW 0xA
338C  CFEE     MOVFF POSTINC0, PLUSW2
338E  FFDB     NOP
3390  0E0B     MOVLW 0xB
3392  CFEE     MOVFF POSTINC0, PLUSW2
3394  FFDB     NOP
3396  0E0C     MOVLW 0xC
3398  CFEE     MOVFF POSTINC0, PLUSW2
339A  FFDB     NOP
339C  0E0D     MOVLW 0xD
339E  CFEE     MOVFF POSTINC0, PLUSW2
33A0  FFDB     NOP
33A2  D06C     BRA 0x347C
33A4  0E07     MOVLW 0x7
33A6  50DB     MOVF PLUSW2, W, ACCESS
33A8  0803     SUBLW 0x3
33AA  E12C     BNZ 0x3404
33AC  0E03     MOVLW 0x3
33AE  AEDB     BTFSS PLUSW2, 7, ACCESS
33B0  D00D     BRA 0x33CC
33B2  DAB2     RCALL __pa_10
33B4  0E02     MOVLW 0x2
33B6  DA76     RCALL __pa_5
33B8  CFEF     MOVFF INDF0, __tmp_0
33BA  F014     NOP
33BC  6A15     CLRF digit_cnt, ACCESS
33BE  6A16     CLRF prefix_cnt, ACCESS
33C0  6A17     CLRF sign_char, ACCESS
33C2  AE14     BTFSS __tmp_0, 7, ACCESS
33C4  D039     BRA 0x3438
33C6  6815     SETF digit_cnt, ACCESS
33C8  6816     SETF prefix_cnt, ACCESS
33CA  D035     BRA 0x3436
33CC  0EF7     MOVLW 0xF7
33CE  CFDB     MOVFF PLUSW2, digit_cnt
33D0  F015     NOP
33D2  0EF8     MOVLW 0xF8
33D4  CFDB     MOVFF PLUSW2, prefix_cnt
33D6  F016     NOP
33D8  0E02     MOVLW 0x2
33DA  5E15     SUBWF digit_cnt, F, ACCESS
33DC  0E00     MOVLW 0x0
33DE  5A16     SUBWFB prefix_cnt, F, ACCESS
33E0  0EF7     MOVLW 0xF7
33E2  C015     MOVFF digit_cnt, PLUSW2
33E4  FFDB     NOP
33E6  0EF8     MOVLW 0xF8
33E8  C016     MOVFF prefix_cnt, PLUSW2
33EA  FFDB     NOP
33EC  C015     MOVFF digit_cnt, FSR0L
33EE  FFE9     NOP
33F0  C016     MOVFF prefix_cnt, FSR0H
33F2  FFEA     NOP
33F4  CFEF     MOVFF INDF0, __tmp_0
33F6  F014     NOP
33F8  0E0A     MOVLW 0xA
33FA  C014     MOVFF __tmp_0, PLUSW2
33FC  FFDB     NOP
33FE  0E0B     MOVLW 0xB
3400  6ADB     CLRF PLUSW2, ACCESS
3402  D038     BRA 0x3474
3404  0E07     MOVLW 0x7
3406  50DB     MOVF PLUSW2, W, ACCESS
3408  0802     SUBLW 0x2
340A  E109     BNZ 0x341E
340C  0E03     MOVLW 0x3
340E  AEDB     BTFSS PLUSW2, 7, ACCESS
3410  D004     BRA 0x341A
3412  DB59     RCALL __pa_36
3414  AE16     BTFSS prefix_cnt, 7, ACCESS
3416  D010     BRA 0x3438
39C2  CFEE     MOVFF POSTINC0, __tmp_0
39C4  F014     NOP
39C6  CFEE     MOVFF POSTINC0, digit_cnt
39C8  F015     NOP
39CA  CFEF     MOVFF INDF0, prefix_cnt
39CC  F016     NOP
39CE  6A17     CLRF sign_char, ACCESS
39D0  0012     RETURN 0
3AC6  DF28     RCALL __pa_10
3AC8  0E03     MOVLW 0x3
3ACA  DEEC     RCALL __pa_5
3ACC  EFE1     GOTO 0x39C2
3ACE  F01C     NOP
3418  D00E     BRA 0x3436
341A  DB55     RCALL __pa_36
341C  D00D     BRA 0x3438
341E  0E03     MOVLW 0x3
3420  AEDB     BTFSS PLUSW2, 7, ACCESS
3422  D012     BRA 0x3448
3424  DA79     RCALL __pa_10
3426  0E02     MOVLW 0x2
3428  DA3D     RCALL __pa_5
342A  DAF9     RCALL __pa_26
342C  6A16     CLRF prefix_cnt, ACCESS
342E  6A17     CLRF sign_char, ACCESS
3430  AE15     BTFSS digit_cnt, 7, ACCESS
3432  D002     BRA 0x3438
3434  6816     SETF prefix_cnt, ACCESS
3436  6817     SETF sign_char, ACCESS
3438  DAE2     RCALL __pa_23
343A  0E0C     MOVLW 0xC
343C  C016     MOVFF prefix_cnt, PLUSW2
343E  FFDB     NOP
3440  0E0D     MOVLW 0xD
3442  C017     MOVFF sign_char, PLUSW2
3444  FFDB     NOP
38A4  5E18     SUBWF buf, F, ACCESS
38A6  0E00     MOVLW 0x0
38A8  5A19     SUBWFB 0x19, F, ACCESS
38AA  0EF7     MOVLW 0xF7
38AC  C018     MOVFF buf, PLUSW2
38AE  FFDB     NOP
38B0  0EF8     MOVLW 0xF8
38B2  C019     MOVFF 0x19, PLUSW2
38B4  FFDB     NOP
38B6  C018     MOVFF buf, FSR0L
38B8  FFE9     NOP
38BA  C019     MOVFF 0x19, FSR0H
38BC  FFEA     NOP
38BE  0012     RETURN 0
3918  0EF7     MOVLW 0xF7
391A  CFDB     MOVFF PLUSW2, buf
391C  F018     NOP
391E  0EF8     MOVLW 0xF8
3920  CFDB     MOVFF PLUSW2, 0x19
3922  F019     NOP
3924  0012     RETURN 0
39FE  0E0A     MOVLW 0xA
3A00  C014     MOVFF __tmp_0, PLUSW2
3A02  FFDB     NOP
3A04  0E0B     MOVLW 0xB
3A06  C015     MOVFF digit_cnt, PLUSW2
3A08  FFDB     NOP
3A0A  0012     RETURN 0
3A1E  CFEE     MOVFF POSTINC0, __tmp_0
3A20  F014     NOP
3A22  CFEF     MOVFF INDF0, digit_cnt
3A24  F015     NOP
3A26  0012     RETURN 0
3446  D01A     BRA 0x347C
3448  0EF7     MOVLW 0xF7
344A  CFDB     MOVFF PLUSW2, prefix_cnt
344C  F016     NOP
344E  0EF8     MOVLW 0xF8
3450  CFDB     MOVFF PLUSW2, sign_char
3452  F017     NOP
3454  0E02     MOVLW 0x2
3456  5E16     SUBWF prefix_cnt, F, ACCESS
3458  0E00     MOVLW 0x0
345A  5A17     SUBWFB sign_char, F, ACCESS
345C  0EF7     MOVLW 0xF7
345E  C016     MOVFF prefix_cnt, PLUSW2
3460  FFDB     NOP
3462  0EF8     MOVLW 0xF8
3464  C017     MOVFF sign_char, PLUSW2
3466  FFDB     NOP
3468  C016     MOVFF prefix_cnt, FSR0L
346A  FFE9     NOP
346C  C017     MOVFF sign_char, FSR0H
346E  FFEA     NOP
3470  DAD6     RCALL __pa_26
3472  DAC5     RCALL __pa_23
3474  0E0C     MOVLW 0xC
3476  6ADB     CLRF PLUSW2, ACCESS
3478  0E0D     MOVLW 0xD
347A  6ADB     CLRF PLUSW2, ACCESS
347C  0E06     MOVLW 0x6
347E  50DB     MOVF PLUSW2, W, ACCESS
3480  E105     BNZ 0x348C
3482  0E01     MOVLW 0x1
3484  6EF3     MOVWF PRODL, ACCESS
3486  0E05     MOVLW 0x5
3488  CFF3     MOVFF PRODL, PLUSW2
348A  FFDB     NOP
348C  0E15     MOVLW 0x15
348E  6ADB     CLRF PLUSW2, ACCESS
3490  0E16     MOVLW 0x16
3492  6ADB     CLRF PLUSW2, ACCESS
3494  50D9     MOVF FSR2L, W, ACCESS
3496  0F37     ADDLW 0x37
3498  6E14     MOVWF __tmp_0, ACCESS
349A  0E00     MOVLW 0x0
349C  20DA     ADDWFC FSR2H, W, ACCESS
349E  6E15     MOVWF digit_cnt, ACCESS
34A0  0E39     MOVLW 0x39
34A2  C014     MOVFF __tmp_0, PLUSW2
34A4  FFDB     NOP
34A6  0E3A     MOVLW 0x3A
34A8  C015     MOVFF digit_cnt, PLUSW2
34AA  FFDB     NOP
34AC  0E38     MOVLW 0x38
34AE  6ADB     CLRF PLUSW2, ACCESS
34B0  0E08     MOVLW 0x8
34B2  6ADB     CLRF PLUSW2, ACCESS
34B4  0E0A     MOVLW 0xA
34B6  DAAE     RCALL __pa_25
34B8  50DF     MOVF INDF2, W, ACCESS
34BA  0A78     XORLW 0x78
34BC  E012     BZ 0x34E2
34BE  0A20     XORLW 0x20
34C0  E010     BZ 0x34E2
34C2  0A28     XORLW 0x28
34C4  E00C     BZ 0x34DE
34C6  0A20     XORLW 0x20
34C8  E00A     BZ 0x34DE
34CA  0A3F     XORLW 0x3F
34CC  E006     BZ 0x34DA
34CE  0A0D     XORLW 0xD
34D0  E002     BZ 0x34D6
34D2  0A20     XORLW 0x20
34D4  E108     BNZ 0x34E6
34D6  0E02     MOVLW 0x2
34D8  D005     BRA 0x34E4
34DA  0E08     MOVLW 0x8
34DC  D003     BRA 0x34E4
34DE  0E08     MOVLW 0x8
34E0  26DF     ADDWF INDF2, F, ACCESS
34E2  0E10     MOVLW 0x10
34E4  DA97     RCALL __pa_25
3A14  6EF3     MOVWF PRODL, ACCESS
3A16  0E07     MOVLW 0x7
3A18  CFF3     MOVFF PRODL, PLUSW2
3A1A  FFDB     NOP
3A1C  0012     RETURN 0
34E6  0E03     MOVLW 0x3
34E8  BEDB     BTFSC PLUSW2, 7, ACCESS
34EA  D002     BRA 0x34F0
34EC  92DB     BCF PLUSW2, 1, ACCESS
34EE  94DB     BCF PLUSW2, 2, ACCESS
34F0  50DB     MOVF PLUSW2, W, ACCESS
34F2  0B80     ANDLW 0x80
34F4  E024     BZ 0x353E
34F6  DA8A     RCALL __pa_24
34F8  90D8     BCF STATUS, 0, ACCESS
34FA  0E03     MOVLW 0x3
34FC  50EB     MOVF PLUSW0, W, ACCESS
34FE  0A00     XORLW 0x0
3500  E608     BN 0x3512
3502  0E00     MOVLW 0x0
3504  5CEE     SUBWF POSTINC0, W, ACCESS
3506  0E00     MOVLW 0x0
3508  58EE     SUBWFB POSTINC0, W, ACCESS
350A  0E00     MOVLW 0x0
350C  58EE     SUBWFB POSTINC0, W, ACCESS
350E  0E00     MOVLW 0x0
3510  58EE     SUBWFB POSTINC0, W, ACCESS
3512  E215     BC 0x353E
3A0C  50D9     MOVF FSR2L, W, ACCESS
3A0E  0F0A     ADDLW 0xA
3A10  EF9A     GOTO 0x3B34
3A12  F01D     NOP
3B34  6EE9     MOVWF FSR0L, ACCESS
3B36  0E00     MOVLW 0x0
3B38  20DA     ADDWFC FSR2H, W, ACCESS
3B3A  6EEA     MOVWF FSR0H, ACCESS
3B3C  0012     RETURN 0
3514  DA13     RCALL __pa_12
3516  6809     SETF cval, ACCESS
3518  680A     SETF larg, ACCESS
351A  680B     SETF 0xB, ACCESS
351C  680C     SETF 0xC, ACCESS
351E  EC36     CALL 0x4A6C, 0
3520  F025     NOP
3522  0E0A     MOVLW 0xA
3524  C000     MOVFF i, PLUSW2
3526  FFDB     NOP
3528  0E0B     MOVLW 0xB
352A  C001     MOVFF c, PLUSW2
352C  FFDB     NOP
352E  0E0C     MOVLW 0xC
3530  C002     MOVFF c2, PLUSW2
3532  FFDB     NOP
3534  0E0D     MOVLW 0xD
3536  C003     MOVFF n, PLUSW2
3538  FFDB     NOP
393C  0E0A     MOVLW 0xA
393E  CFDB     MOVFF PLUSW2, i
3940  F004     NOP
3942  0E0B     MOVLW 0xB
3944  CFDB     MOVFF PLUSW2, precision
3946  F005     NOP
3948  0E0C     MOVLW 0xC
394A  CFDB     MOVFF PLUSW2, pUEP
394C  F006     NOP
394E  0E0D     MOVLW 0xD
3950  CFDB     MOVFF PLUSW2, size
3952  F007     NOP
3954  0012     RETURN 0
353A  0E2D     MOVLW 0x2D
353C  D008     BRA 0x354E
353E  0E03     MOVLW 0x3
3540  A2DB     BTFSS PLUSW2, 1, ACCESS
3542  D002     BRA 0x3548
3544  0E2B     MOVLW 0x2B
3546  D003     BRA 0x354E
3548  A4DB     BTFSS PLUSW2, 2, ACCESS
354A  D008     BRA 0x355C
354C  0E20     MOVLW 0x20
354E  6EF3     MOVWF PRODL, ACCESS
3550  0E17     MOVLW 0x17
3552  CFF3     MOVFF PRODL, PLUSW2
3554  FFDB     NOP
3556  0E15     MOVLW 0x15
3558  2ADB     INCF PLUSW2, F, ACCESS
355A  D002     BRA 0x3560
355C  0E17     MOVLW 0x17
355E  6ADB     CLRF PLUSW2, ACCESS
3560  0E05     MOVLW 0x5
3562  50DB     MOVF PLUSW2, W, ACCESS
3564  E103     BNZ 0x356C
3566  D9B7     RCALL __pa_8
3568  E101     BNZ 0x356C
356A  D089     BRA 0x367E
38D6  0E0A     MOVLW 0xA
38D8  CFDB     MOVFF PLUSW2, __tmp_0
38DA  F014     NOP
38DC  0E0B     MOVLW 0xB
38DE  CFDB     MOVFF PLUSW2, digit_cnt
38E0  F015     NOP
38E2  0E0C     MOVLW 0xC
38E4  CFDB     MOVFF PLUSW2, prefix_cnt
38E6  F016     NOP
38E8  0E0D     MOVLW 0xD
38EA  CFDB     MOVFF PLUSW2, sign_char
38EC  F017     NOP
38EE  5014     MOVF __tmp_0, W, ACCESS
38F0  1015     IORWF digit_cnt, W, ACCESS
38F2  1016     IORWF prefix_cnt, W, ACCESS
38F4  1017     IORWF sign_char, W, ACCESS
38F6  0012     RETURN 0
356C  0EFA     MOVLW 0xFA
356E  6E14     MOVWF __tmp_0, ACCESS
3570  0E4B     MOVLW 0x4B
3572  6E15     MOVWF digit_cnt, ACCESS
3574  0E00     MOVLW 0x0
3576  6E16     MOVWF prefix_cnt, ACCESS
3578  0E07     MOVLW 0x7
357A  CFDB     MOVFF PLUSW2, sign_char
357C  F017     NOP
357E  6A18     CLRF buf, ACCESS
3580  6A19     CLRF 0x19, ACCESS
3582  6A1A     CLRF 0x1A, ACCESS
3584  C017     MOVFF sign_char, cval
3586  F009     NOP
3588  C018     MOVFF buf, larg
358A  F00A     NOP
358C  C019     MOVFF 0x19, 0xB
358E  F00B     NOP
3590  C01A     MOVFF 0x1A, 0xC
3592  F00C     NOP
3594  D9D3     RCALL __pa_12
3596  EC9B     CALL 0x4B36, 0
3598  F025     NOP
359A  5014     MOVF __tmp_0, W, ACCESS
359C  2400     ADDWF i, W, ACCESS
359E  6EF3     MOVWF PRODL, ACCESS
35A0  5015     MOVF digit_cnt, W, ACCESS
35A2  2001     ADDWFC c, W, ACCESS
35A4  6EF4     MOVWF PRODH, ACCESS
35A6  5016     MOVF prefix_cnt, W, ACCESS
35A8  2002     ADDWFC c2, W, ACCESS
35AA  6EF8     MOVWF TBLPTRU, ACCESS
35AC  CFF4     MOVFF PRODH, TBLPTRH
35AE  FFF7     NOP
35B0  CFF3     MOVFF PRODL, TBLPTRL
35B2  FFF6     NOP
35B4  0008     TBLRD*
35B6  0E09     MOVLW 0x9
35B8  CFF5     MOVFF TABLAT, PLUSW2
35BA  FFDB     NOP
35BC  0E58     MOVLW 0x58
35BE  5CDF     SUBWF INDF2, W, ACCESS
35C0  E10F     BNZ 0x35E0
35C2  0E61     MOVLW 0x61
35C4  6EF3     MOVWF PRODL, ACCESS
35C6  0E09     MOVLW 0x9
35C8  D97B     RCALL __pa_6
35CA  E30A     BNC 0x35E0
38C0  CFDB     MOVFF PLUSW2, PRODH
38C2  FFF4     NOP
38C4  50F3     MOVF PRODL, W, ACCESS
38C6  5CF4     SUBWF PRODH, W, ACCESS
38C8  0012     RETURN 0
35CC  0E20     MOVLW 0x20
35CE  6E14     MOVWF __tmp_0, ACCESS
35D0  0E09     MOVLW 0x9
35D2  CFDB     MOVFF PLUSW2, INDF1
35D4  FFE7     NOP
35D6  5014     MOVF __tmp_0, W, ACCESS
35D8  5EE7     SUBWF INDF1, F, ACCESS
35DA  0E09     MOVLW 0x9
35DC  CFE7     MOVFF INDF1, PLUSW2
35DE  FFDB     NOP
35E0  0E07     MOVLW 0x7
35E2  CFDB     MOVFF PLUSW2, __tmp_0
35E4  F014     NOP
35E6  6A15     CLRF digit_cnt, ACCESS
35E8  6A16     CLRF prefix_cnt, ACCESS
35EA  6A17     CLRF sign_char, ACCESS
35EC  DA0F     RCALL __pa_24
35EE  C014     MOVFF __tmp_0, cval
35F0  F009     NOP
35F2  C015     MOVFF digit_cnt, larg
35F4  F00A     NOP
35F6  C016     MOVFF prefix_cnt, 0xB
35F8  F00B     NOP
35FA  C017     MOVFF sign_char, 0xC
35FC  F00C     NOP
35FE  CFEE     MOVFF POSTINC0, i
3600  F004     NOP
3602  CFEE     MOVFF POSTINC0, precision
3604  F005     NOP
3606  CFEE     MOVFF POSTINC0, pUEP
3608  F006     NOP
360A  CFEF     MOVFF INDF0, size
360C  F007     NOP
360E  EC9B     CALL 0x4B36, 0
3610  F025     NOP
3612  C007     MOVFF size, POSTDEC0
3614  FFED     NOP
3616  C006     MOVFF pUEP, POSTDEC0
3618  FFED     NOP
361A  C005     MOVFF precision, POSTDEC0
361C  FFED     NOP
361E  C004     MOVFF i, INDF0
3620  FFEF     NOP
3622  0E39     MOVLW 0x39
3624  CFDB     MOVFF PLUSW2, FSR0L
3626  FFE9     NOP
3628  06DB     DECF PLUSW2, F, ACCESS
362A  0E3A     MOVLW 0x3A
362C  CFDB     MOVFF PLUSW2, FSR0H
362E  FFEA     NOP
3630  E201     BC 0x3634
3632  06DB     DECF PLUSW2, F, ACCESS
3634  0E09     MOVLW 0x9
3636  CFDB     MOVFF PLUSW2, INDF0
3638  FFEF     NOP
363A  0E15     MOVLW 0x15
363C  2ADB     INCF PLUSW2, F, ACCESS
363E  D94B     RCALL __pa_8
3640  E195     BNZ 0x356C
3642  0E03     MOVLW 0x3
3644  A6DB     BTFSS PLUSW2, 3, ACCESS
3646  D01D     BRA 0x3682
3648  0E6F     MOVLW 0x6F
364A  5CDF     SUBWF INDF2, W, ACCESS
364C  E106     BNZ 0x365A
364E  D9C1     RCALL __pa_20
3650  E318     BNC 0x3682
39D2  0E05     MOVLW 0x5
39D4  CFDB     MOVFF PLUSW2, __tmp_0
39D6  F014     NOP
39D8  0E15     MOVLW 0x15
39DA  50DB     MOVF PLUSW2, W, ACCESS
39DC  80D8     BSF STATUS, 0, ACCESS
39DE  5414     SUBFWB __tmp_0, W, ACCESS
39E0  0012     RETURN 0
3652  0E15     MOVLW 0x15
3654  28DB     INCF PLUSW2, W, ACCESS
3656  DA5B     RCALL __pa_42
3658  D014     BRA 0x3682
365A  0E78     MOVLW 0x78
365C  5CDF     SUBWF INDF2, W, ACCESS
365E  E009     BZ 0x3672
3660  0E58     MOVLW 0x58
3662  5CDF     SUBWF INDF2, W, ACCESS
3664  E006     BZ 0x3672
3666  0E62     MOVLW 0x62
3668  5CDF     SUBWF INDF2, W, ACCESS
366A  E003     BZ 0x3672
366C  0E42     MOVLW 0x42
366E  5CDF     SUBWF INDF2, W, ACCESS
3670  E108     BNZ 0x3682
3672  0E02     MOVLW 0x2
3674  6EF3     MOVWF PRODL, ACCESS
3676  0E16     MOVLW 0x16
3678  CFF3     MOVFF PRODL, PLUSW2
367A  FFDB     NOP
367C  D002     BRA 0x3682
367E  0E15     MOVLW 0x15
3680  6ADB     CLRF PLUSW2, ACCESS
3682  0E03     MOVLW 0x3
3684  50DB     MOVF PLUSW2, W, ACCESS
3686  0B10     ANDLW 0x10
368A  0E04     MOVLW 0x4
368C  CFDB     MOVFF PLUSW2, __tmp_0
368E  F014     NOP
3690  0E05     MOVLW 0x5
3692  50DB     MOVF PLUSW2, W, ACCESS
3694  80D8     BSF STATUS, 0, ACCESS
3696  5414     SUBFWB __tmp_0, W, ACCESS
3688  E00E     BZ 0x36A6
3698  E206     BC 0x36A6
369A  0E06     MOVLW 0x6
369C  50DB     MOVF PLUSW2, W, ACCESS
369E  E103     BNZ 0x36A6
36A0  0E04     MOVLW 0x4
36A2  50DB     MOVF PLUSW2, W, ACCESS
36A4  DA34     RCALL __pa_42
36A6  D995     RCALL __pa_20
36A8  E20A     BC 0x36BE
36AA  0E05     MOVLW 0x5
36AC  CFDB     MOVFF PLUSW2, INDF1
36AE  FFE7     NOP
36B0  0E15     MOVLW 0x15
36B2  50DB     MOVF PLUSW2, W, ACCESS
36B4  5EE7     SUBWF INDF1, F, ACCESS
36B6  0E05     MOVLW 0x5
36B8  CFE7     MOVFF INDF1, PLUSW2
36BA  FFDB     NOP
36BC  D002     BRA 0x36C2
36BE  0E05     MOVLW 0x5
36C0  6ADB     CLRF PLUSW2, ACCESS
36C2  0E04     MOVLW 0x4
36C4  CFDB     MOVFF PLUSW2, __tmp_0
36C6  F014     NOP
36C8  0E16     MOVLW 0x16
36CA  D945     RCALL __pa_13
36CC  80D8     BSF STATUS, 0, ACCESS
36CE  5414     SUBFWB __tmp_0, W, ACCESS
36D0  E214     BC 0x36FA
3956  CFDB     MOVFF PLUSW2, POSTINC1
3958  FFE6     NOP
395A  0E15     MOVLW 0x15
395C  CFDB     MOVFF PLUSW2, POSTINC1
395E  FFE6     NOP
3960  0E05     MOVLW 0x5
3962  50DB     MOVF PLUSW2, W, ACCESS
3964  52E5     MOVF POSTDEC1, F, ACCESS
3966  24E7     ADDWF INDF1, W, ACCESS
3968  52E5     MOVF POSTDEC1, F, ACCESS
396A  24E7     ADDWF INDF1, W, ACCESS
396C  0012     RETURN 0
36D2  0E16     MOVLW 0x16
36D4  CFDB     MOVFF PLUSW2, POSTINC1
36D6  FFE6     NOP
36D8  0E15     MOVLW 0x15
36DA  CFDB     MOVFF PLUSW2, POSTINC1
36DC  FFE6     NOP
36DE  0E04     MOVLW 0x4
36E0  CFDB     MOVFF PLUSW2, POSTINC1
36E2  FFE6     NOP
36E4  0E05     MOVLW 0x5
36E6  50DB     MOVF PLUSW2, W, ACCESS
36E8  52E5     MOVF POSTDEC1, F, ACCESS
36EA  5CE7     SUBWF INDF1, W, ACCESS
36EC  52E5     MOVF POSTDEC1, F, ACCESS
36EE  80D8     BSF STATUS, 0, ACCESS
36F0  54E7     SUBFWB INDF1, W, ACCESS
36F2  52E5     MOVF POSTDEC1, F, ACCESS
36F4  80D8     BSF STATUS, 0, ACCESS
36F6  54E7     SUBFWB INDF1, W, ACCESS
36F8  D95F     RCALL __pa_18
36FA  0E03     MOVLW 0x3
36FC  50DB     MOVF PLUSW2, W, ACCESS
36FE  0B01     ANDLW 0x1
3700  E10B     BNZ 0x3718
3702  0E08     MOVLW 0x8
3704  50DB     MOVF PLUSW2, W, ACCESS
3706  E008     BZ 0x3718
3708  D8B2     RCALL __pa_2
370A  E001     BZ 0x370E
370C  D08D     BRA 0x3828
370E  0E08     MOVLW 0x8
3710  50DB     MOVF PLUSW2, W, ACCESS
3712  D8BE     RCALL __pa_4
3714  0E08     MOVLW 0x8
3716  6ADB     CLRF PLUSW2, ACCESS
3718  0E17     MOVLW 0x17
371A  50DB     MOVF PLUSW2, W, ACCESS
371C  E007     BZ 0x372C
371E  D988     RCALL __pa_28
3720  0E17     MOVLW 0x17
3722  D9F1     RCALL __pa_41
3724  E103     BNZ 0x372C
3726  1C15     COMF digit_cnt, W, ACCESS
3728  E101     BNZ 0x372C
372A  D07E     BRA 0x3828
372C  0E16     MOVLW 0x16
372E  50DB     MOVF PLUSW2, W, ACCESS
3730  E016     BZ 0x375E
3732  D97E     RCALL __pa_28
3734  0E30     MOVLW 0x30
3736  6EE6     MOVWF POSTINC1, ACCESS
3738  D89F     RCALL __pa_3
373A  E102     BNZ 0x3740
373C  1C15     COMF digit_cnt, W, ACCESS
373E  E074     BZ 0x3828
3740  D977     RCALL __pa_28
3742  CFDF     MOVFF INDF2, POSTINC1
3744  FFE6     NOP
3746  ECF4     CALL 0x49E8, 0
3748  F024     NOP
374A  52E5     MOVF POSTDEC1, F, ACCESS
374C  52E5     MOVF POSTDEC1, F, ACCESS
374E  52E5     MOVF POSTDEC1, F, ACCESS
3750  CFF4     MOVFF PRODH, digit_cnt
3752  F015     NOP
3754  0100     MOVLB 0x0
3756  1CF3     COMF PRODL, W, ACCESS
3758  E102     BNZ 0x375E
375A  1C15     COMF digit_cnt, W, ACCESS
375C  E065     BZ 0x3828
375E  0E05     MOVLW 0x5
3760  CFDB     MOVFF PLUSW2, __tmp_0
3762  F014     NOP
3764  0E16     MOVLW 0x16
3766  50DB     MOVF PLUSW2, W, ACCESS
3768  80D8     BSF STATUS, 0, ACCESS
376A  5414     SUBFWB __tmp_0, W, ACCESS
376C  E209     BC 0x3780
376E  0E05     MOVLW 0x5
3770  CFDB     MOVFF PLUSW2, INDF1
3772  FFE7     NOP
3774  0E16     MOVLW 0x16
3776  50DB     MOVF PLUSW2, W, ACCESS
3778  5EE7     SUBWF INDF1, F, ACCESS
377A  0E05     MOVLW 0x5
377C  CFE7     MOVFF INDF1, PLUSW2
377E  FFDB     NOP
3780  0E30     MOVLW 0x30
3782  6EE6     MOVWF POSTINC1, ACCESS
3784  0E05     MOVLW 0x5
3786  D9CB     RCALL __pa_44
3788  E14F     BNZ 0x3828
3AD0  EC8E     CALL 0x2F1C, 0
3AD2  F017     NOP
3AD4  52E5     MOVF POSTDEC1, F, ACCESS
3AD6  52E5     MOVF POSTDEC1, F, ACCESS
3AD8  52E5     MOVF POSTDEC1, F, ACCESS
3ADA  52E5     MOVF POSTDEC1, F, ACCESS
3ADC  0900     IORLW 0x0
3ADE  0012     RETURN 0
3B1E  CFDB     MOVFF PLUSW2, POSTINC1
3B20  FFE6     NOP
3B22  DF86     RCALL __pa_28
3B24  EF68     GOTO 0x3AD0
3B26  F01D     NOP
378A  0E39     MOVLW 0x39
378C  2ADB     INCF PLUSW2, F, ACCESS
378E  CFDB     MOVFF PLUSW2, FSR0L
3790  FFE9     NOP
3792  0E3A     MOVLW 0x3A
3794  E301     BNC 0x3798
3796  2ADB     INCF PLUSW2, F, ACCESS
3798  CFDB     MOVFF PLUSW2, FSR0H
379A  FFEA     NOP
379C  0E09     MOVLW 0x9
379E  CFEF     MOVFF INDF0, PLUSW2
37A0  FFDB     NOP
37A2  50DB     MOVF PLUSW2, W, ACCESS
37A4  E00E     BZ 0x37C2
37B2  0E39     MOVLW 0x39
37B4  2ADB     INCF PLUSW2, F, ACCESS
37B6  CFDB     MOVFF PLUSW2, FSR0L
37B8  FFE9     NOP
37BA  0E3A     MOVLW 0x3A
37BC  E3ED     BNC 0x3798
37BE  2ADB     INCF PLUSW2, F, ACCESS
37C0  D7EB     BRA 0x3798
37A6  D944     RCALL __pa_28
37A8  0E09     MOVLW 0x9
37AA  D9AD     RCALL __pa_41
37AC  E102     BNZ 0x37B2
37AE  1C15     COMF digit_cnt, W, ACCESS
37B0  E03B     BZ 0x3828
3B06  CFDB     MOVFF PLUSW2, POSTINC1
3B08  FFE6     NOP
3B0A  EF3C     GOTO 0x3878
3B0C  F01C     NOP
37C2  D855     RCALL __pa_2
37C4  E131     BNZ 0x3828
386E  0E20     MOVLW 0x20
3870  6EE6     MOVWF POSTINC1, ACCESS
3872  0E08     MOVLW 0x8
3874  EF8F     GOTO 0x3B1E
3876  F01D     NOP
3A30  0EFC     MOVLW 0xFC
3A32  CFDB     MOVFF PLUSW2, POSTINC1
3A34  FFE6     NOP
3A36  0EFD     MOVLW 0xFD
3A38  CFDB     MOVFF PLUSW2, POSTINC1
3A3A  FFE6     NOP
3A3C  0012     RETURN 0
37C6  0E16     MOVLW 0x16
37C8  CFDB     MOVFF PLUSW2, POSTINC1
37CA  FFE6     NOP
37CC  0E08     MOVLW 0x8
37CE  D8C3     RCALL __pa_13
37D0  52E5     MOVF POSTDEC1, F, ACCESS
37D2  24E7     ADDWF INDF1, W, ACCESS
37D4  D85D     RCALL __pa_4
3890  6E14     MOVWF __tmp_0, ACCESS
3892  6A15     CLRF digit_cnt, ACCESS
3894  50D9     MOVF FSR2L, W, ACCESS
3896  0F01     ADDLW 0x1
3898  D94D     RCALL __pa_46
389A  5014     MOVF __tmp_0, W, ACCESS
389C  26EE     ADDWF POSTINC0, F, ACCESS
389E  5015     MOVF digit_cnt, W, ACCESS
38A0  22ED     ADDWFC POSTDEC0, F, ACCESS
38A2  0012     RETURN 0
37D6  D02E     BRA 0x3834
37D8  0E07     MOVLW 0x7
37DA  50DB     MOVF PLUSW2, W, ACCESS
37DC  0A03     XORLW 0x3
37DE  E01C     BZ 0x3818
37E0  0A01     XORLW 0x1
37E2  E014     BZ 0x380C
37E4  0A03     XORLW 0x3
37E6  E007     BZ 0x37F6
37F6  D8F5     RCALL __pa_21
37F8  6A19     CLRF 0x19, ACCESS
37FA  AE17     BTFSS sign_char, 7, ACCESS
37FC  D002     BRA 0x3802
37FE  6818     SETF buf, ACCESS
3800  6819     SETF 0x19, ACCESS
3802  D82C     RCALL __pa_0
3804  D8BC     RCALL __pa_15
3806  C019     MOVFF 0x19, POSTINC0
3808  FFEE     NOP
397E  50EE     MOVF POSTINC0, W, ACCESS
3980  CFEF     MOVFF INDF0, FSR0H
3982  FFEA     NOP
3984  6EE9     MOVWF FSR0L, ACCESS
3986  C016     MOVFF prefix_cnt, POSTINC0
3988  FFEE     NOP
398A  C017     MOVFF sign_char, POSTINC0
398C  FFEE     NOP
398E  C018     MOVFF buf, POSTINC0
3990  FFEE     NOP
3992  0012     RETURN 0
39E2  0E01     MOVLW 0x1
39E4  CFDB     MOVFF PLUSW2, prefix_cnt
39E6  F016     NOP
39E8  0E02     MOVLW 0x2
39EA  CFDB     MOVFF PLUSW2, sign_char
39EC  F017     NOP
39EE  6A18     CLRF buf, ACCESS
39F0  0012     RETURN 0
380A  D014     BRA 0x3834
380C  D8EA     RCALL __pa_21
380E  BE17     BTFSC sign_char, 7, ACCESS
3810  6818     SETF buf, ACCESS
3812  D824     RCALL __pa_0
3814  D8B4     RCALL __pa_15
3816  D00E     BRA 0x3834
3818  D963     RCALL __pa_38
381A  CFDB     MOVFF PLUSW2, INDF0
381C  FFEF     NOP
381E  D00A     BRA 0x3834
37E8  D97B     RCALL __pa_38
37EA  CFDB     MOVFF PLUSW2, POSTINC0
37EC  FFEE     NOP
37EE  0E02     MOVLW 0x2
37F0  CFDB     MOVFF PLUSW2, POSTDEC0
37F2  FFED     NOP
3AE0  DEBD     RCALL __pa_0
3AE2  50EE     MOVF POSTINC0, W, ACCESS
3AE4  CFEF     MOVFF INDF0, FSR0H
3AE6  FFEA     NOP
3AE8  6EE9     MOVWF FSR0L, ACCESS
3AEA  0E01     MOVLW 0x1
3AEC  0012     RETURN 0
37F4  D01F     BRA 0x3834
3820  D97B     RCALL __pa_43
3822  E105     BNZ 0x382E
3824  1C15     COMF digit_cnt, W, ACCESS
3826  E103     BNZ 0x382E
3878  ECF4     CALL 0x49E8, 0
387A  F024     NOP
387C  52E5     MOVF POSTDEC1, F, ACCESS
387E  52E5     MOVF POSTDEC1, F, ACCESS
3880  52E5     MOVF POSTDEC1, F, ACCESS
3882  CFF3     MOVFF PRODL, __tmp_0
3884  F014     NOP
3886  CFF4     MOVFF PRODH, digit_cnt
3888  F015     NOP
388A  0100     MOVLB 0x0
388C  1CF3     COMF PRODL, W, ACCESS
388E  0012     RETURN 0
3ABE  CFDF     MOVFF INDF2, POSTINC1
3AC0  FFE6     NOP
3AC2  EF3C     GOTO 0x3878
3AC4  F01C     NOP
3B18  DF8B     RCALL __pa_28
3B1A  EF5F     GOTO 0x3ABE
3B1C  F01D     NOP
3828  68F3     SETF PRODL, ACCESS
382A  68F4     SETF PRODH, ACCESS
382C  D010     BRA 0x384E
382E  D8FC     RCALL __pa_27
3830  E301     BNC 0x3834
3832  2ADB     INCF PLUSW2, F, ACCESS
3A28  0E01     MOVLW 0x1
3A2A  2ADB     INCF PLUSW2, F, ACCESS
3A2C  0E02     MOVLW 0x2
3A2E  0012     RETURN 0
383A  0E01     MOVLW 0x1
383C  CFDB     MOVFF PLUSW2, __tmp_0
383E  F014     NOP
3840  0E02     MOVLW 0x2
3842  CFDB     MOVFF PLUSW2, digit_cnt
3844  F015     NOP
3846  C014     MOVFF __tmp_0, PRODL
3848  FFF3     NOP
384A  C015     MOVFF digit_cnt, PRODH
384C  FFF4     NOP
384E  0E3B     MOVLW 0x3B
3850  5CE1     SUBWF FSR1L, W, ACCESS
3852  E202     BC 0x3858
3854  6AE1     CLRF FSR1L, ACCESS
3856  52E5     MOVF POSTDEC1, F, ACCESS
3858  6EE1     MOVWF FSR1L, ACCESS
385A  D0CB     BRA __pa_22
---  C:/MCC18/v3_39/src/traditional/stdclib/strlen.asm  -------------------------------------------------
471A  0EFE     MOVLW 0xFE
471C  CFE3     MOVFF PLUSW1, FSR0L
471E  FFE9     NOP
4720  0EFF     MOVLW 0xFF
4722  CFE3     MOVFF PLUSW1, FSR0H
4724  FFEA     NOP
4726  6AF3     CLRF PRODL, ACCESS
4728  6AF4     CLRF PRODH, ACCESS
472A  52EE     MOVF POSTINC0, F, ACCESS
472C  E003     BZ jEnd
472E  4AF3     INFSNZ PRODL, F, ACCESS
4730  2AF4     INCF PRODH, F, ACCESS
4732  D7FB     BRA jLoop
4734  0012     RETURN 0
---  C:/MCC18/v3_39/src/traditional/stdclib/slenpgm.asm  ------------------------------------------------
4736  0EFF     MOVLW 0xFF
4738  CFE3     MOVFF PLUSW1, TBLPTRU
473A  FFF8     NOP
473C  52E5     MOVF POSTDEC1, F, ACCESS
473E  0EFF     MOVLW 0xFF
4740  CFE3     MOVFF PLUSW1, TBLPTRH
4742  FFF7     NOP
4744  52E5     MOVF POSTDEC1, F, ACCESS
4746  0EFF     MOVLW 0xFF
4748  CFE3     MOVFF PLUSW1, TBLPTRL
474A  FFF6     NOP
474C  52E5     MOVF POSTDEC1, F, ACCESS
474E  6AE6     CLRF POSTINC1, ACCESS
4750  6AE6     CLRF POSTINC1, ACCESS
4752  6AE6     CLRF POSTINC1, ACCESS
4754  0009     TBLRD*+
4756  52F5     MOVF TABLAT, F, ACCESS
4758  E009     BZ jEnd
475A  0EFD     MOVLW 0xFD
475C  2AE3     INCF PLUSW1, F, ACCESS
475E  E105     BNZ _2jEnd
4760  0EFE     MOVLW 0xFE
4762  2AE3     INCF PLUSW1, F, ACCESS
4764  E102     BNZ _2jEnd
4766  0EFF     MOVLW 0xFF
4768  2AE3     INCF PLUSW1, F, ACCESS
476A  D7F4     BRA jLoop
476C  0EFD     MOVLW 0xFD
476E  CFE3     MOVFF PLUSW1, precision
4770  F005     NOP
4772  0EFE     MOVLW 0xFE
4774  CFE3     MOVFF PLUSW1, pUEP
4776  F006     NOP
4778  0EFF     MOVLW 0xFF
477A  CFE3     MOVFF PLUSW1, size
477C  F007     NOP
477E  0012     RETURN 0
---  C:/MCC18/v3_39/src/traditional/stdclib/putc.c  -----------------------------------------------------
49E8  CFD9     MOVFF FSR2L, POSTINC1
49EA  FFE6     NOP
49EC  CFDA     MOVFF FSR2H, POSTINC1
49EE  FFE6     NOP
49F0  CFE1     MOVFF FSR1L, FSR2L
49F2  FFD9     NOP
49F4  CFE2     MOVFF FSR1H, FSR2H
49F6  FFDA     NOP
49F8  0EFB     MOVLW 0xFB
49FA  CFDB     MOVFF PLUSW2, __tmp_0
49FC  F014     NOP
49FE  0EFC     MOVLW 0xFC
4A00  CFDB     MOVFF PLUSW2, digit_cnt
4A02  F015     NOP
4A04  0100     MOVLB 0x0
4A06  0E80     MOVLW 0x80
4A08  1415     ANDWF digit_cnt, W, ACCESS
4A0A  E11A     BNZ 0x4A40
4A0C  0EFB     MOVLW 0xFB
4A0E  CFDB     MOVFF PLUSW2, FSR0L
4A10  FFE9     NOP
4A12  0EFC     MOVLW 0xFC
4A14  CFDB     MOVFF PLUSW2, FSR0H
4A16  FFEA     NOP
4A18  CFEE     MOVFF POSTINC0, PRODL
4A1A  FFF3     NOP
4A1C  CFED     MOVFF POSTDEC0, PRODH
4A1E  FFF4     NOP
4A20  2AEE     INCF POSTINC0, F, ACCESS
4A22  0E00     MOVLW 0x0
4A24  22EF     ADDWFC INDF0, F, ACCESS
4A26  CFF3     MOVFF PRODL, FSR0L
4A28  FFE9     NOP
4A2A  CFF4     MOVFF PRODH, FSR0H
4A2C  FFEA     NOP
4A2E  0EFD     MOVLW 0xFD
4A30  CFDB     MOVFF PLUSW2, INDF0
4A32  FFEF     NOP
4A34  50EF     MOVF INDF0, W, ACCESS
4A36  6A15     CLRF digit_cnt, ACCESS
4A38  6EF3     MOVWF PRODL, ACCESS
4A3A  C015     MOVFF digit_cnt, PRODH
4A3C  FFF4     NOP
4A3E  D010     BRA 0x4A60
4A40  0EFB     MOVLW 0xFB
4A42  50DB     MOVF PLUSW2, W, ACCESS
4A44  08FE     SUBLW 0xFE
4A46  E106     BNZ 0x4A54
4A48  0EFD     MOVLW 0xFD
4A4A  CFDB     MOVFF PLUSW2, POSTINC1
4A4C  FFE6     NOP
4A4E  ECEF     CALL 0x4BDE, 0
4A50  F025     NOP
4A52  D005     BRA 0x4A5E
4A54  0EFD     MOVLW 0xFD
4A56  CFDB     MOVFF PLUSW2, POSTINC1
4A58  FFE6     NOP
4A5A  ECEF     CALL 0x43DE, 0
4A5C  F021     NOP
4A5E  52E5     MOVF POSTDEC1, F, ACCESS
4A60  52E5     MOVF POSTDEC1, F, ACCESS
4A62  CFE5     MOVFF POSTDEC1, FSR2H
4A64  FFDA     NOP
4A66  CFE7     MOVFF INDF1, FSR2L
4A68  FFD9     NOP
4A6A  0012     RETURN 0
---  C:/MCC18/v3_39/src/traditional/stdclib/printf.c  ---------------------------------------------------
48C6  CFD9     MOVFF FSR2L, POSTINC1
48C8  FFE6     NOP
48CA  CFDA     MOVFF FSR2H, POSTINC1
48CC  FFE6     NOP
48CE  CFE1     MOVFF FSR1L, FSR2L
48D0  FFD9     NOP
48D2  CFE2     MOVFF FSR1H, FSR2H
48D4  FFDA     NOP
48D6  52E6     MOVF POSTINC1, F, ACCESS
48D8  52E6     MOVF POSTINC1, F, ACCESS
48DA  52E6     MOVF POSTINC1, F, ACCESS
48DC  52E6     MOVF POSTINC1, F, ACCESS
48DE  50D9     MOVF FSR2L, W, ACCESS
48E0  0FFB     ADDLW 0xFB
48E2  6E14     MOVWF __tmp_0, ACCESS
48E4  0EFF     MOVLW 0xFF
48E6  20DA     ADDWFC FSR2H, W, ACCESS
48E8  6E15     MOVWF digit_cnt, ACCESS
48EA  C014     MOVFF __tmp_0, POSTINC2
48EC  FFDE     NOP
48EE  6EDD     MOVWF POSTDEC2, ACCESS
48F0  CFDE     MOVFF POSTINC2, POSTINC1
48F2  FFE6     NOP
48F4  CFDD     MOVFF POSTDEC2, POSTINC1
48F6  FFE6     NOP
48F8  0EFB     MOVLW 0xFB
48FA  CFDB     MOVFF PLUSW2, POSTINC1
48FC  FFE6     NOP
48FE  0EFC     MOVLW 0xFC
4900  CFDB     MOVFF PLUSW2, POSTINC1
4902  FFE6     NOP
4904  0EFD     MOVLW 0xFD
4906  CFDB     MOVFF PLUSW2, POSTINC1
4908  FFE6     NOP
490A  C1FB     MOVFF stdout, POSTINC1
490C  FFE6     NOP
490E  C1FC     MOVFF 0x1FC, POSTINC1
4910  FFE6     NOP
4912  ECA4     CALL 0x2F48, 0
4914  F017     NOP
4916  6E14     MOVWF __tmp_0, ACCESS
4918  0E07     MOVLW 0x7
491A  5CE1     SUBWF FSR1L, W, ACCESS
491C  E202     BC 0x4922
491E  6AE1     CLRF FSR1L, ACCESS
4920  52E5     MOVF POSTDEC1, F, ACCESS
4922  6EE1     MOVWF FSR1L, ACCESS
4924  5014     MOVF __tmp_0, W, ACCESS
4926  0E02     MOVLW 0x2
4928  CFF3     MOVFF PRODL, PLUSW2
492A  FFDB     NOP
492C  0E03     MOVLW 0x3
492E  CFF4     MOVFF PRODH, PLUSW2
4930  FFDB     NOP
4932  0E02     MOVLW 0x2
4934  CFDB     MOVFF PLUSW2, __tmp_0
4936  F014     NOP
4938  0E03     MOVLW 0x3
493A  CFDB     MOVFF PLUSW2, digit_cnt
493C  F015     NOP
493E  C014     MOVFF __tmp_0, PRODL
4940  FFF3     NOP
4942  C015     MOVFF digit_cnt, PRODH
4944  FFF4     NOP
4946  0E04     MOVLW 0x4
4948  5CE1     SUBWF FSR1L, W, ACCESS
494A  E202     BC 0x4950
494C  6AE1     CLRF FSR1L, ACCESS
494E  52E5     MOVF POSTDEC1, F, ACCESS
4950  6EE1     MOVWF FSR1L, ACCESS
4952  52E5     MOVF POSTDEC1, F, ACCESS
4954  CFE5     MOVFF POSTDEC1, FSR2H
4956  FFDA     NOP
4958  CFE7     MOVFF INDF1, FSR2L
495A  FFD9     NOP
495C  0012     RETURN 0
---  C:/MCC18/v3_39/src/traditional/stdclib/memcpy.asm  -------------------------------------------------
46C4  CFD9     MOVFF FSR2L, POSTINC1
46C6  FFE6     NOP
46C8  CFDA     MOVFF FSR2H, POSTINC1
46CA  FFE6     NOP
46CC  0EFA     MOVLW 0xFA
46CE  CFE3     MOVFF PLUSW1, FSR2L
46D0  FFD9     NOP
46D2  0EFB     MOVLW 0xFB
46D4  CFE3     MOVFF PLUSW1, FSR2H
46D6  FFDA     NOP
46D8  0EFC     MOVLW 0xFC
46DA  CFE3     MOVFF PLUSW1, FSR0L
46DC  FFE9     NOP
46DE  0EFD     MOVLW 0xFD
46E0  CFE3     MOVFF PLUSW1, FSR0H
46E2  FFEA     NOP
46E4  CFE9     MOVFF FSR0L, PRODL
46E6  FFF3     NOP
46E8  CFEA     MOVFF FSR0H, PRODH
46EA  FFF4     NOP
46EC  0EF8     MOVLW 0xF8
46EE  50E3     MOVF PLUSW1, W, ACCESS
46F0  E103     BNZ _4jContinue
46F2  0EF9     MOVLW 0xF9
46F4  50E3     MOVF PLUSW1, W, ACCESS
46F6  E008     BZ jEnd
46F8  0EF8     MOVLW 0xF8
46FA  06E3     DECF PLUSW1, F, ACCESS
46FC  E202     BC _5jEnd
46FE  0EF9     MOVLW 0xF9
4700  06E3     DECF PLUSW1, F, ACCESS
4702  CFDE     MOVFF POSTINC2, POSTINC0
4704  FFEE     NOP
4706  D7F2     BRA jLoop
4708  0EFF     MOVLW 0xFF
470A  CFE3     MOVFF PLUSW1, FSR2H
470C  FFDA     NOP
470E  52E5     MOVF POSTDEC1, F, ACCESS
4710  0EFF     MOVLW 0xFF
4712  CFE3     MOVFF PLUSW1, FSR2L
4714  FFD9     NOP
4716  52E5     MOVF POSTDEC1, F, ACCESS
4718  0012     RETURN 0
---  C:/MCC18/v3_39/src/traditional/stdclib/isdigit.asm  ------------------------------------------------
4B7E  6AF3     CLRF PRODL, ACCESS
4B80  6AF4     CLRF PRODH, ACCESS
4B82  0EFF     MOVLW 0xFF
4B84  24E1     ADDWF FSR1L, W, ACCESS
4B86  6EE9     MOVWF FSR0L, ACCESS
4B88  0EFF     MOVLW 0xFF
4B8A  20E2     ADDWFC FSR1H, W, ACCESS
4B8C  6EEA     MOVWF FSR0H, ACCESS
4B8E  66ED     TSTFSZ POSTDEC0, ACCESS
4B90  D007     BRA jNoMatch
4B92  0E2F     MOVLW 0x2F
4B94  64EF     CPFSGT INDF0, ACCESS
4B96  D004     BRA jNoMatch
4B98  0E3A     MOVLW 0x3A
4B9A  60EF     CPFSLT INDF0, ACCESS
4B9C  D001     BRA jNoMatch
4B9E  2AF3     INCF PRODL, F, ACCESS
4BA0  0012     RETURN 0
---  C:/MCC18/v3_39/src/traditional/stdclib/__init.c  ---------------------------------------------------
4C0C  0012     RETURN 0
---  C:/MCC18/v3_39/src/traditional/startup/c018i.c  ----------------------------------------------------
0000  EFE1     GOTO 0x4BC2
0002  F025     NOP
0004  0012     RETURN 0
4BC2  EE13     LFSR 1, 0x300
4BC4  F000     NOP
4BC6  EE23     LFSR 2, 0x300
4BC8  F000     NOP
4BCA  6AF8     CLRF TBLPTRU, ACCESS
4BCC  9C0F     BCF 0xF, 6, ACCESS
4BCE  EC14     CALL 0x4828, 0
4BD0  F024     NOP
4BD2  EC06     CALL 0x4C0C, 0
4BD4  F026     NOP
4BD6  EC03     CALL 0x4406, 0
4BD8  F022     NOP
4BDA  D7FB     BRA 0x4BD2
4BDC  0012     RETURN 0
4828  0E2A     MOVLW 0x2A
482A  6EF6     MOVWF TBLPTRL, ACCESS
482C  0E08     MOVLW 0x8
482E  6EF7     MOVWF TBLPTRH, ACCESS
4830  0E00     MOVLW 0x0
4832  6EF8     MOVWF TBLPTRU, ACCESS
4834  0100     MOVLB 0x0
4836  0009     TBLRD*+
4838  50F5     MOVF TABLAT, W, ACCESS
483A  6FDE     MOVWF curr_entry, BANKED
483C  0009     TBLRD*+
483E  50F5     MOVF TABLAT, W, ACCESS
4840  6FDF     MOVWF 0xDF, BANKED
4842  E103     BNZ 0x484A
4844  67DE     TSTFSZ curr_entry, BANKED
4846  D001     BRA 0x484A
4848  D03D     BRA 0x48C4
484A  0009     TBLRD*+
484C  50F5     MOVF TABLAT, W, ACCESS
484E  6FD9     MOVWF prom, BANKED
4850  0009     TBLRD*+
4852  50F5     MOVF TABLAT, W, ACCESS
4854  6FDA     MOVWF 0xDA, BANKED
4856  0009     TBLRD*+
4858  50F5     MOVF TABLAT, W, ACCESS
485A  6FDB     MOVWF 0xDB, BANKED
485C  0009     TBLRD*+
485E  0009     TBLRD*+
4860  50F5     MOVF TABLAT, W, ACCESS
4862  6EE9     MOVWF FSR0L, ACCESS
4864  0009     TBLRD*+
4866  50F5     MOVF TABLAT, W, ACCESS
4868  6EEA     MOVWF FSR0H, ACCESS
486A  0009     TBLRD*+
486C  0009     TBLRD*+
486E  0009     TBLRD*+
4870  50F5     MOVF TABLAT, W, ACCESS
4872  6FDC     MOVWF curr_byte, BANKED
4874  0009     TBLRD*+
4876  50F5     MOVF TABLAT, W, ACCESS
4878  6FDD     MOVWF 0xDD, BANKED
487A  0009     TBLRD*+
487C  0009     TBLRD*+
487E  CFF6     MOVFF TBLPTRL, data_ptr
4880  F0E0     NOP
4882  CFF7     MOVFF TBLPTRH, 0xE1
4884  F0E1     NOP
4886  CFF8     MOVFF TBLPTRU, 0xE2
4888  F0E2     NOP
488A  C0D9     MOVFF prom, TBLPTRL
488C  FFF6     NOP
488E  C0DA     MOVFF 0xDA, TBLPTRH
4890  FFF7     NOP
4892  C0DB     MOVFF 0xDB, TBLPTRU
4894  FFF8     NOP
4896  0100     MOVLB 0x0
4898  53DC     MOVF curr_byte, F, BANKED
489A  E102     BNZ 0x48A0
489C  53DD     MOVF 0xDD, F, BANKED
489E  E007     BZ 0x48AE
48A0  0009     TBLRD*+
48A2  50F5     MOVF TABLAT, W, ACCESS
48A4  6EEE     MOVWF POSTINC0, ACCESS
48A6  07DC     DECF curr_byte, F, BANKED
48A8  E2F8     BC 0x489A
48AA  07DD     DECF 0xDD, F, BANKED
48AC  D7F9     BRA 0x48A0
48AE  C0E0     MOVFF data_ptr, TBLPTRL
48B0  FFF6     NOP
48B2  C0E1     MOVFF 0xE1, TBLPTRH
48B4  FFF7     NOP
48B6  C0E2     MOVFF 0xE2, TBLPTRU
48B8  FFF8     NOP
48BA  0100     MOVLB 0x0
48BC  07DE     DECF curr_entry, F, BANKED
48BE  0E00     MOVLW 0x0
48C0  5BDF     SUBWFB 0xDF, F, BANKED
48C2  D7BF     BRA 0x4842
48C4  0012     RETURN 0
---  C:/MCC18/v3_39/src/traditional/proc/p18F2550.asm  --------------------------------------------------
4BA2  0E00     MOVLW 0x0
4BA4  6EF3     MOVWF PRODL, ACCESS
4BA6  EE00     LFSR 0, 0x0
4BA8  F000     NOP
4BAA  0E08     MOVLW 0x8
4BAC  D801     RCALL zero_block
4BAE  0012     RETURN 0
4BB0  60EA     CPFSLT FSR0H, ACCESS
4BB2  D002     BRA compare_l
4BB4  6AEE     CLRF POSTINC0, ACCESS
4BB6  D7FC     BRA zero_block
4BB8  50F3     MOVF PRODL, W, ACCESS
4BBA  60E9     CPFSLT FSR0L, ACCESS
4BBC  0012     RETURN 0
4BBE  6AEE     CLRF POSTINC0, ACCESS
4BC0  D7FC     BRA loop_l
---  C:/MCC18/v3_39/src/traditional/math/fxm3232.c  -----------------------------------------------------
4A6C  5004     MOVF i, W, ACCESS
4A6E  0209     MULWF cval, ACCESS
4A70  CFF3     MOVFF PRODL, i
4A72  F000     NOP
4A74  CFF4     MOVFF PRODH, c
4A76  F001     NOP
4A78  020A     MULWF larg, ACCESS
4A7A  50F3     MOVF PRODL, W, ACCESS
4A7C  2601     ADDWF c, F, ACCESS
4A7E  0E00     MOVLW 0x0
4A80  20F4     ADDWFC PRODH, W, ACCESS
4A82  6E02     MOVWF c2, ACCESS
4A84  5004     MOVF i, W, ACCESS
4A86  020B     MULWF 0xB, ACCESS
4A88  50F3     MOVF PRODL, W, ACCESS
4A8A  2602     ADDWF c2, F, ACCESS
4A8C  0E00     MOVLW 0x0
4A8E  20F4     ADDWFC PRODH, W, ACCESS
4A90  6E03     MOVWF n, ACCESS
4A92  5004     MOVF i, W, ACCESS
4A94  020C     MULWF 0xC, ACCESS
4A96  50F3     MOVF PRODL, W, ACCESS
4A98  2603     ADDWF n, F, ACCESS
4A9A  5005     MOVF precision, W, ACCESS
4A9C  0209     MULWF cval, ACCESS
4A9E  50F3     MOVF PRODL, W, ACCESS
4AA0  2601     ADDWF c, F, ACCESS
4AA2  50F4     MOVF PRODH, W, ACCESS
4AA4  2202     ADDWFC c2, F, ACCESS
4AA6  0E00     MOVLW 0x0
4AA8  2203     ADDWFC n, F, ACCESS
4AAA  5005     MOVF precision, W, ACCESS
4AAC  020A     MULWF larg, ACCESS
4AAE  50F3     MOVF PRODL, W, ACCESS
4AB0  2602     ADDWF c2, F, ACCESS
4AB2  50F4     MOVF PRODH, W, ACCESS
4AB4  2203     ADDWFC n, F, ACCESS
4AB6  5005     MOVF precision, W, ACCESS
4AB8  020B     MULWF 0xB, ACCESS
4ABA  50F3     MOVF PRODL, W, ACCESS
4ABC  2603     ADDWF n, F, ACCESS
4ABE  5006     MOVF pUEP, W, ACCESS
4AC0  0209     MULWF cval, ACCESS
4AC2  50F3     MOVF PRODL, W, ACCESS
4AC4  2602     ADDWF c2, F, ACCESS
4AC6  50F4     MOVF PRODH, W, ACCESS
4AC8  2203     ADDWFC n, F, ACCESS
4ACA  5006     MOVF pUEP, W, ACCESS
4ACC  020A     MULWF larg, ACCESS
4ACE  50F3     MOVF PRODL, W, ACCESS
4AD0  2603     ADDWF n, F, ACCESS
4AD2  5007     MOVF size, W, ACCESS
4AD4  0209     MULWF cval, ACCESS
4AD6  50F3     MOVF PRODL, W, ACCESS
4AD8  2603     ADDWF n, F, ACCESS
4ADA  0012     RETURN 0
---  C:/MCC18/v3_39/src/traditional/math/fxm1616s.asm  --------------------------------------------------
4ADC  C007     MOVFF size, n
4ADE  F013     NOP
4AE0  C006     MOVFF pUEP, 0x12
4AE2  F012     NOP
4AE4  5006     MOVF pUEP, W, ACCESS
4AE6  020B     MULWF 0xB, ACCESS
4AE8  CFF4     MOVFF PRODH, precision
4AEA  F005     NOP
4AEC  CFF3     MOVFF PRODL, i
4AEE  F004     NOP
4AF0  5007     MOVF size, W, ACCESS
4AF2  020C     MULWF 0xC, ACCESS
4AF4  CFF4     MOVFF PRODH, size
4AF6  F007     NOP
4AF8  CFF3     MOVFF PRODL, pUEP
4AFA  F006     NOP
4AFC  020B     MULWF 0xB, ACCESS
4AFE  50F3     MOVF PRODL, W, ACCESS
4B00  2605     ADDWF precision, F, ACCESS
4B02  50F4     MOVF PRODH, W, ACCESS
4B04  2206     ADDWFC pUEP, F, ACCESS
4B06  6AE8     CLRF WREG, ACCESS
4B08  2207     ADDWFC size, F, ACCESS
4B0A  5012     MOVF 0x12, W, ACCESS
4B0C  020C     MULWF 0xC, ACCESS
4B0E  50F3     MOVF PRODL, W, ACCESS
4B10  2605     ADDWF precision, F, ACCESS
4B12  50F4     MOVF PRODH, W, ACCESS
4B14  2206     ADDWFC pUEP, F, ACCESS
4B16  6AE8     CLRF WREG, ACCESS
4B18  2207     ADDWFC size, F, ACCESS
4B1A  AE0C     BTFSS 0xC, 7, ACCESS
4B1C  EF94     GOTO 0x4B28
4B1E  F025     NOP
4B20  5012     MOVF 0x12, W, ACCESS
4B22  5E06     SUBWF pUEP, F, ACCESS
4B24  5013     MOVF n, W, ACCESS
4B26  5A07     SUBWFB size, F, ACCESS
4B28  AE13     BTFSS n, 7, ACCESS
4B2A  0C00     RETLW 0x0
4B2C  500B     MOVF 0xB, W, ACCESS
4B2E  5E06     SUBWF pUEP, F, ACCESS
4B30  500C     MOVF 0xC, W, ACCESS
4B32  5A07     SUBWFB size, F, ACCESS
4B34  0C00     RETLW 0x0
---  C:/MCC18/v3_39/src/traditional/math/fxd3232u.c  ----------------------------------------------------
4B36  6A03     CLRF n, ACCESS
4B38  6A02     CLRF c2, ACCESS
4B3A  6A01     CLRF c, ACCESS
4B3C  6A00     CLRF i, ACCESS
4B3E  0E20     MOVLW 0x20
4B40  6EE7     MOVWF INDF1, ACCESS
4B42  90D8     BCF STATUS, 0, ACCESS
4B44  3604     RLCF i, F, ACCESS
4B46  3605     RLCF precision, F, ACCESS
4B48  3606     RLCF pUEP, F, ACCESS
4B4A  3607     RLCF size, F, ACCESS
4B4C  3600     RLCF i, F, ACCESS
4B4E  3601     RLCF c, F, ACCESS
4B50  3602     RLCF c2, F, ACCESS
4B52  3603     RLCF n, F, ACCESS
4B54  5009     MOVF cval, W, ACCESS
4B56  5C00     SUBWF i, W, ACCESS
4B58  500A     MOVF larg, W, ACCESS
4B5A  5801     SUBWFB c, W, ACCESS
4B5C  500B     MOVF 0xB, W, ACCESS
4B5E  5802     SUBWFB c2, W, ACCESS
4B60  500C     MOVF 0xC, W, ACCESS
4B62  5803     SUBWFB n, W, ACCESS
4B64  E309     BNC 0x4B78
4B66  5009     MOVF cval, W, ACCESS
4B68  5E00     SUBWF i, F, ACCESS
4B6A  500A     MOVF larg, W, ACCESS
4B6C  5A01     SUBWFB c, F, ACCESS
4B6E  500B     MOVF 0xB, W, ACCESS
4B70  5A02     SUBWFB c2, F, ACCESS
4B72  500C     MOVF 0xC, W, ACCESS
4B74  5A03     SUBWFB n, F, ACCESS
4B76  2A04     INCF i, F, ACCESS
4B78  2EE7     DECFSZ INDF1, F, ACCESS
4B7A  D7E4     BRA 0x4B44
4B7C  0012     RETURN 0
---  C:/MCC18/v3_39/src/pmc_common/USART/uopen.c  -------------------------------------------------------
495E  CFD9     MOVFF FSR2L, POSTINC1
4960  FFE6     NOP
4962  CFDA     MOVFF FSR2H, POSTINC1
4964  FFE6     NOP
4966  CFE1     MOVFF FSR1L, FSR2L
4968  FFD9     NOP
496A  CFE2     MOVFF FSR1H, FSR2H
496C  FFDA     NOP
496E  6AAC     CLRF TXSTA, ACCESS
4970  6AAB     CLRF RCSTA, ACCESS
4972  0EFD     MOVLW 0xFD
4974  B0DB     BTFSC PLUSW2, 0, ACCESS
4976  88AC     BSF TXSTA, 4, ACCESS
4978  A2DB     BTFSS PLUSW2, 1, ACCESS
497A  D002     BRA 0x4980
497C  8CAC     BSF TXSTA, 6, ACCESS
497E  8CAB     BSF RCSTA, 6, ACCESS
4980  B4DB     BTFSC PLUSW2, 2, ACCESS
4982  8EAC     BSF TXSTA, 7, ACCESS
4984  A6DB     BTFSS PLUSW2, 3, ACCESS
4986  D002     BRA 0x498C
4988  88AB     BSF RCSTA, 4, ACCESS
498A  D001     BRA 0x498E
498C  8AAB     BSF RCSTA, 5, ACCESS
498E  B8DB     BTFSC PLUSW2, 4, ACCESS
4990  84AC     BSF TXSTA, 2, ACCESS
4992  989E     BCF PIR1, 4, ACCESS
4994  BADB     BTFSC PLUSW2, 5, ACCESS
4996  86AB     BSF RCSTA, 3, ACCESS
4998  ACDB     BTFSS PLUSW2, 6, ACCESS
499A  D002     BRA 0x49A0
499C  8A9D     BSF PIE1, 5, ACCESS
499E  D001     BRA 0x49A2
49A0  9A9D     BCF PIE1, 5, ACCESS
49A2  9A9E     BCF PIR1, 5, ACCESS
49A4  AEDB     BTFSS PLUSW2, 7, ACCESS
49A6  D002     BRA 0x49AC
49A8  889D     BSF PIE1, 4, ACCESS
49AA  D001     BRA 0x49AE
49AC  989D     BCF PIE1, 4, ACCESS
49AE  0EFB     MOVLW 0xFB
49B0  50DB     MOVF PLUSW2, W, ACCESS
49B2  6EAF     MOVWF SPBRG, ACCESS
49B4  0EFB     MOVLW 0xFB
49B6  0EFC     MOVLW 0xFC
49B8  CFDB     MOVFF PLUSW2, digit_cnt
49BA  F015     NOP
49BC  C015     MOVFF digit_cnt, __tmp_0
49BE  F014     NOP
49C0  6A15     CLRF digit_cnt, ACCESS
49C2  5014     MOVF __tmp_0, W, ACCESS
49C4  6EB0     MOVWF SPBRGH, ACCESS
49C6  8AAC     BSF TXSTA, 5, ACCESS
49C8  8EAB     BSF RCSTA, 7, ACCESS
49CA  9C94     BCF TRISC, 6, ACCESS
49CC  8E94     BSF TRISC, 7, ACCESS
49CE  50AC     MOVF TXSTA, W, ACCESS
49D0  0B10     ANDLW 0x10
49D2  E004     BZ 0x49DC
49D4  50AC     MOVF TXSTA, W, ACCESS
49D6  0B80     ANDLW 0x80
49D8  E101     BNZ 0x49DC
49DA  8C94     BSF TRISC, 6, ACCESS
49DC  52E5     MOVF POSTDEC1, F, ACCESS
49DE  CFE5     MOVFF POSTDEC1, FSR2H
49E0  FFDA     NOP
49E2  CFE7     MOVFF INDF1, FSR2L
49E4  FFD9     NOP
49E6  0012     RETURN 0
---  C:/MCC18/v3_39/src/pmc_common/USART/_usartpc.asm  --------------------------------------------------
4BDE  0EFF     MOVLW 0xFF
4BE0  50E3     MOVF PLUSW1, W, ACCESS
4BE2  BAAC     BTFSC TXSTA, 5, ACCESS
4BE4  D004     BRA loop
4BE6  6AAF     CLRF SPBRG, ACCESS
4BE8  8EAB     BSF RCSTA, 7, ACCESS
4BEA  8AAC     BSF TXSTA, 5, ACCESS
4BEC  9C94     BCF TRISC, 6, ACCESS
4BEE  A2AC     BTFSS TXSTA, 1, ACCESS
4BF0  D7FE     BRA loop
4BF2  6EAD     MOVWF TXREG, ACCESS
4BF4  6EF3     MOVWF PRODL, ACCESS
4BF6  6AF4     CLRF PRODH, ACCESS
4BF8  0012     RETURN 0
---  /home/antoine/Documents/Pic/DP_USB/USB_stack/dp_usb/usb_stack.c  -----------------------------------
1:             /*
2:             This work is licensed under the Creative Commons Attribution 3.0 Unported License.
3:             To view a copy of this license, visit http://creativecommons.org/licenses/by/3.0/
4:             or send a letter to
5:                     Creative Commons,
6:                     171 Second Street,
7:                     Suite 300,
8:                     San Francisco,
9:                     California,
10:                    94105,
11:                    USA.
12:            
13:            Influence and inspiration taken from http://pe.ece.olin.edu/ece/projects.html
14:             */
15:            
16:            // JTR v0.2a Jan 26th 2012
17:            
18:            
19:            #include "../dp_usb/usb_stack_globals.h"     // USB stack only defines Not function related.
20:            
21:            #if USB_EP0_BUFFER_SIZE == 8u
22:            #elif USB_EP0_BUFFER_SIZE == 16u
23:            #elif USB_EP0_BUFFER_SIZE == 32u
24:            #elif USB_EP0_BUFFER_SIZE == 64u
25:            #else
26:            #error "USB_EP0_BUFFER_SIZE needs to be 8, 16, 32 or 64 bytes"
27:            #endif
28:            
29:            
30:            ROMPTR const BYTE *usb_device_descriptor;
31:            ROMPTR const BYTE *usb_config_descriptor;
32:            ROMPTR const BYTE *usb_string_descriptor;
33:            int usb_num_string_descriptors;
34:            
35:            usb_handler_t sof_handler;
36:            usb_handler_t class_setup_handler, vendor_setup_handler;
37:            
38:            
39:            usb_ep_t endpoints[MAX_CHIP_EP]; // JTR change. MAX_CHIP_EP is the number of hardware endpoints on the silicon. See picusb.h
40:            
41:            /* Allocate buffers for buffer description table and the actual buffers */
42:            // CvD: linkscript puts it in the right memory location
43:            
44:            
45:            // JTR comments. This below goes part way to ridding us of the need for a linker script (PIC18).
46:            // It floats the EP0 buffers to occupy space immediately behind the buffer descriptors.
47:            // However there are problems. It only works for the EP0 buffers because they are the only
48:            // buffers defined in this block. It is not possible to do arithmatic within a #pragma
49:            // therefore there seems to be no way to cause EPs in other blocks to float.
50:            // All the buffers would need to be defined here and this would break the universal nature
51:            // of this module. As such efforts to create a custom linker script free stack have been
52:            // put on hold for now but can be revisited at any stage.
53:            // Please see http://dangerousprototypes.com/forum/viewtopic.php?f=39&t=1651&start=120#p17401
54:            
55:            #if defined(PIC_18F)
56:            #pragma udata usb_bdt
57:            BDentry usb_bdt[2 + 2 * MAX_EPNUM_USED]; // JTR changed index from 32 to variable
58:            #pragma udata usb_data
59:            //* Only claim buffer for ep 0 */
60:            #if USB_PP_BUF_MODE == 0
61:            BYTE usb_ep0_out_buf[USB_EP0_BUFFER_SIZE];
62:            BYTE usb_ep0_in_buf[USB_EP0_BUFFER_SIZE];
63:            #else
64:            #error "Ping pong buffer not implemented yet!"
65:            #endif
66:            
67:            #elif defined(PIC_24F)
68:            #pragma udata usb_bdt
69:            BDentry usb_bdt[2 + 2 * MAX_EPNUM_USED] __attribute__((aligned(512))); // JTR changed index from 32 to variable TODO: Dynamic allocation reflecting number of used endpoints. (How to do counting in preprocessor?)
70:            #if USB_PP_BUF_MODE == 0
71:            BYTE usb_ep0_out_buf[USB_EP0_BUFFER_SIZE];
72:            BYTE usb_ep0_in_buf[USB_EP0_BUFFER_SIZE];
73:            #else
74:            #error "Ping pong buffer not implemented yet!"
75:            #endif
76:            #endif
77:            
78:            #pragma udata
79:            unsigned int usb_device_status;
80:            unsigned int usb_current_cfg;
81:            volatile BYTE usb_device_state;
82:            BYTE usb_addr_pending;
83:            BYTE trn_status; // Global since it is needed everywere
84:            BDentry *EP0_Outbdp, *EP0_Inbdp; // Dito
85:            BYTE IsSuspended = 0;
86:            ROMPTR const BYTE *usb_rom_ptr;
87:            size_t usb_rom_len;
88:            volatile BYTE usbrequesterrorflag;
89:            
90:            void usb_init(ROMPTR const BYTE *device_descriptor,
1D2E  CFD9     MOVFF FSR2L, POSTINC1
1D30  FFE6     NOP
1D32  CFE1     MOVFF FSR1L, FSR2L
1D34  FFD9     NOP
91:                    ROMPTR const BYTE *config_descriptor,
92:                    ROMPTR const BYTE *string_descriptor,
93:                    int num_string_descriptors) {
94:            
95:                usb_device_descriptor = device_descriptor;
1D36  0EFC     MOVLW 0xFC
1D38  CFDB     MOVFF PLUSW2, usb_device_descriptor
1D3A  F060     NOP
1D3C  0EFD     MOVLW 0xFD
1D3E  CFDB     MOVFF PLUSW2, 0x61
1D40  F061     NOP
1D42  0EFE     MOVLW 0xFE
1D44  CFDB     MOVFF PLUSW2, 0x62
1D46  F062     NOP
96:                usb_config_descriptor = config_descriptor;
1D48  0EF9     MOVLW 0xF9
1D4A  CFDB     MOVFF PLUSW2, usb_config_descriptor
1D4C  F063     NOP
1D4E  0EFA     MOVLW 0xFA
1D50  CFDB     MOVFF PLUSW2, 0x64
1D52  F064     NOP
1D54  0EFB     MOVLW 0xFB
1D56  CFDB     MOVFF PLUSW2, 0x65
1D58  F065     NOP
97:                usb_string_descriptor = string_descriptor;
1D5A  0EF6     MOVLW 0xF6
1D5C  CFDB     MOVFF PLUSW2, usb_string_descriptor
1D5E  F066     NOP
1D60  0EF7     MOVLW 0xF7
1D62  CFDB     MOVFF PLUSW2, 0x67
1D64  F067     NOP
1D66  0EF8     MOVLW 0xF8
1D68  CFDB     MOVFF PLUSW2, 0x68
1D6A  F068     NOP
98:                usb_num_string_descriptors = num_string_descriptors;
1D6C  0EF4     MOVLW 0xF4
1D6E  CFDB     MOVFF PLUSW2, usb_num_string_descriptors
1D70  F069     NOP
1D72  0EF5     MOVLW 0xF5
1D74  CFDB     MOVFF PLUSW2, 0x6A
1D76  F06A     NOP
99:                sof_handler = NULL;
1D78  0100     MOVLB 0x0
1D7A  6B6B     CLRF sof_handler, BANKED
1D7C  6B6C     CLRF 0x6C, BANKED
100:               class_setup_handler = NULL;
1D7E  0100     MOVLB 0x0
1D80  6B6D     CLRF class_setup_handler, BANKED
1D82  6B6E     CLRF 0x6E, BANKED
101:               vendor_setup_handler = NULL;
1D84  0100     MOVLB 0x0
1D86  6B6F     CLRF vendor_setup_handler, BANKED
1D88  6B70     CLRF 0x70, BANKED
102:               usb_unset_in_handler(0);
1D8A  0E00     MOVLW 0x0
1D8C  6EE6     MOVWF POSTINC1, ACCESS
1D8E  6AE6     CLRF POSTINC1, ACCESS
1D90  0E00     MOVLW 0x0
1D92  6EE6     MOVWF POSTINC1, ACCESS
1D94  6AE6     CLRF POSTINC1, ACCESS
1D96  EC58     CALL 0x2CB0, 0
1D98  F016     NOP
1D9A  52E5     MOVF POSTDEC1, F, ACCESS
1D9C  52E5     MOVF POSTDEC1, F, ACCESS
1D9E  52E5     MOVF POSTDEC1, F, ACCESS
1DA0  52E5     MOVF POSTDEC1, F, ACCESS
103:               usb_unset_out_handler(0);
1DA2  0E00     MOVLW 0x0
1DA4  6EE6     MOVWF POSTINC1, ACCESS
1DA6  6AE6     CLRF POSTINC1, ACCESS
1DA8  0E00     MOVLW 0x0
1DAA  6EE6     MOVWF POSTINC1, ACCESS
1DAC  6AE6     CLRF POSTINC1, ACCESS
1DAE  EC76     CALL 0x2CEC, 0
1DB0  F016     NOP
1DB2  52E5     MOVF POSTDEC1, F, ACCESS
1DB4  52E5     MOVF POSTDEC1, F, ACCESS
1DB6  52E5     MOVF POSTDEC1, F, ACCESS
1DB8  52E5     MOVF POSTDEC1, F, ACCESS
104:               ClearUSBtoDefault();
1DBA  D821     RCALL ClearUSBtoDefault
105:               ConfigureUsbHardware();
1DBC  0E14     MOVLW 0x14
1DBE  6E6F     MOVWF UCFG, ACCESS
106:               EnablePacketTransfer();
1DC0  986D     BCF UCON, 4, ACCESS
107:           }
1DC2  52E5     MOVF POSTDEC1, F, ACCESS
1DC4  CFE7     MOVFF INDF1, FSR2L
1DC6  FFD9     NOP
1DC8  0012     RETURN 0
108:           
109:           void usb_start(void) {
110:               EnableUsb(); // Enable USB-hardware
1DCA  866D     BSF UCON, 3, ACCESS
111:               usb_device_state = ATTACHED_STATE;
1DCC  0100     MOVLB 0x0
1DCE  0E01     MOVLW 0x1
1DD0  6FB5     MOVWF usb_device_state, BANKED
112:               while (SingleEndedZeroIsSet()); // Busywait for initial power-up
1DD2  BA6D     BTFSC UCON, 5, ACCESS
1DD4  D7FE     BRA 0x1DD2
113:               usb_device_state = DEFAULT_STATE; //JTR2
1DD6  0100     MOVLB 0x0
1DD8  0E04     MOVLW 0x4
1DDA  6FB5     MOVWF usb_device_state, BANKED
114:           }
1DDC  0012     RETURN 0
115:           
116:           void usb_handle_error(void) {
117:               /* No errorhandler for now, just clear offending flag*/
118:               ClearAllUsbErrorInterruptFlags();
1DDE  6A6A     CLRF UEIR, ACCESS
119:           }
1DE0  0012     RETURN 0
120:           
121:           void usb_handle_reset(void) {
122:               do {
123:                   ClearUsbInterruptFlag(USB_TRN); // JTR corrected Must poll TRN Flag and clear, then wait 6 cycles. for next flag set.
1DE2  9668     BCF UIR, 3, ACCESS
124:                   usb_current_cfg = 0;
1DE4  0100     MOVLB 0x0
1DE6  6BB3     CLRF usb_current_cfg, BANKED
1DE8  6BB4     CLRF 0xB4, BANKED
125:                   usb_device_state = DEFAULT_STATE; // This BLOCK creates the requied 6 cycle delay for TRNF to reassert.
1DEA  0100     MOVLB 0x0
1DEC  0E04     MOVLW 0x4
1DEE  6FB5     MOVWF usb_device_state, BANKED
126:                   usb_addr_pending = 0x00;
1DF0  0100     MOVLB 0x0
1DF2  6BB6     CLRF usb_addr_pending, BANKED
127:               } while (USB_TRANSACTION_FLAG);
1DF4  B668     BTFSC UIR, 3, ACCESS
1DF6  D7F5     BRA usb_handle_reset
128:           
129:               ClearUSBtoDefault();
1DF8  D802     RCALL ClearUSBtoDefault
130:               EnablePacketTransfer();
1DFA  986D     BCF UCON, 4, ACCESS
131:           }
1DFC  0012     RETURN 0
132:           
133:           void ClearUSBtoDefault(void) {
1DFE  CFD9     MOVFF FSR2L, POSTINC1
1E00  FFE6     NOP
1E02  CFE1     MOVFF FSR1L, FSR2L
1E04  FFD9     NOP
1E06  0E02     MOVLW 0x2
1E08  26E1     ADDWF FSR1L, F, ACCESS
134:               int i;
135:               sof_handler = NULL;
1E0A  0100     MOVLB 0x0
1E0C  6B6B     CLRF sof_handler, BANKED
1E0E  6B6C     CLRF 0x6C, BANKED
136:               class_setup_handler = NULL;
1E10  0100     MOVLB 0x0
1E12  6B6D     CLRF class_setup_handler, BANKED
1E14  6B6E     CLRF 0x6E, BANKED
137:               vendor_setup_handler = NULL;
1E16  0100     MOVLB 0x0
1E18  6B6F     CLRF vendor_setup_handler, BANKED
1E1A  6B70     CLRF 0x70, BANKED
138:           
139:               SetUsbAddress(0); // After reset we don't have an address
1E1C  6A6E     CLRF UADDR, ACCESS
140:               ResetPPbuffers();
1E1E  8C6D     BSF UCON, 6, ACCESS
1E20  9C6D     BCF UCON, 6, ACCESS
141:               ClearAllUsbErrorInterruptFlags();
1E22  6A6A     CLRF UEIR, ACCESS
142:           
143:               for (i = 0; i < MAX_CHIP_EP; i++) {
1E24  6ADE     CLRF POSTINC2, ACCESS
1E26  6ADD     CLRF POSTDEC2, ACCESS
1E28  CFDE     MOVFF POSTINC2, __tmp_0
1E2A  F014     NOP
1E2C  CFDD     MOVFF POSTDEC2, digit_cnt
1E2E  F015     NOP
1E30  90D8     BCF STATUS, 0, ACCESS
1E32  5015     MOVF digit_cnt, W, ACCESS
1E34  E604     BN 0x1E3E
1E36  0E10     MOVLW 0x10
1E38  5C14     SUBWF __tmp_0, W, ACCESS
1E3A  0E00     MOVLW 0x0
1E3C  5815     SUBWFB digit_cnt, W, ACCESS
1E3E  E232     BC 0x1EA4
1E9A  2ADF     INCF INDF2, F, ACCESS
1E9C  0E01     MOVLW 0x1
1E9E  E301     BNC 0x1EA2
1EA0  2ADB     INCF PLUSW2, F, ACCESS
1EA2  D7C2     BRA 0x1E28
144:                   endpoints[i].out_handler = NULL;
1E40  CFDE     MOVFF POSTINC2, FSR0L
1E42  FFE9     NOP
1E44  CFDD     MOVFF POSTDEC2, FSR0H
1E46  FFEA     NOP
1E48  90D8     BCF STATUS, 0, ACCESS
1E4A  36E9     RLCF FSR0L, F, ACCESS
1E4C  36EA     RLCF FSR0H, F, ACCESS
1E4E  90D8     BCF STATUS, 0, ACCESS
1E50  36E9     RLCF FSR0L, F, ACCESS
1E52  36EA     RLCF FSR0H, F, ACCESS
1E54  0E71     MOVLW 0x71
1E56  26E9     ADDWF FSR0L, F, ACCESS
1E58  0E00     MOVLW 0x0
1E5A  22EA     ADDWFC FSR0H, F, ACCESS
1E5C  0E02     MOVLW 0x2
1E5E  26E9     ADDWF FSR0L, F, ACCESS
1E60  0E00     MOVLW 0x0
1E62  22EA     ADDWFC FSR0H, F, ACCESS
1E64  6AEE     CLRF POSTINC0, ACCESS
1E66  6AED     CLRF POSTDEC0, ACCESS
145:                   endpoints[i].in_handler = NULL;
1E68  CFDE     MOVFF POSTINC2, FSR0L
1E6A  FFE9     NOP
1E6C  CFDD     MOVFF POSTDEC2, FSR0H
1E6E  FFEA     NOP
1E70  90D8     BCF STATUS, 0, ACCESS
1E72  36E9     RLCF FSR0L, F, ACCESS
1E74  36EA     RLCF FSR0H, F, ACCESS
1E76  90D8     BCF STATUS, 0, ACCESS
1E78  36E9     RLCF FSR0L, F, ACCESS
1E7A  36EA     RLCF FSR0H, F, ACCESS
1E7C  0E71     MOVLW 0x71
1E7E  26E9     ADDWF FSR0L, F, ACCESS
1E80  0E00     MOVLW 0x0
1E82  22EA     ADDWFC FSR0H, F, ACCESS
1E84  6AEE     CLRF POSTINC0, ACCESS
1E86  6AED     CLRF POSTDEC0, ACCESS
146:                   USB_UEP[i] = 0;
1E88  CFDE     MOVFF POSTINC2, FSR0L
1E8A  FFE9     NOP
1E8C  CFDD     MOVFF POSTDEC2, FSR0H
1E8E  FFEA     NOP
1E90  0E70     MOVLW 0x70
1E92  26E9     ADDWF FSR0L, F, ACCESS
1E94  0E0F     MOVLW 0xF
1E96  22EA     ADDWFC FSR0H, F, ACCESS
1E98  6AEF     CLRF INDF0, ACCESS
147:               }
148:           
149:               for (i = 0; i < (2 + 2 * MAX_EPNUM_USED); i++) {
1EA4  6ADE     CLRF POSTINC2, ACCESS
1EA6  6ADD     CLRF POSTDEC2, ACCESS
1EA8  CFDE     MOVFF POSTINC2, __tmp_0
1EAA  F014     NOP
1EAC  CFDD     MOVFF POSTDEC2, digit_cnt
1EAE  F015     NOP
1EB0  90D8     BCF STATUS, 0, ACCESS
1EB2  5015     MOVF digit_cnt, W, ACCESS
1EB4  E604     BN 0x1EBE
1EB6  0E06     MOVLW 0x6
1EB8  5C14     SUBWF __tmp_0, W, ACCESS
1EBA  0E00     MOVLW 0x0
1EBC  5815     SUBWFB digit_cnt, W, ACCESS
1EBE  E214     BC 0x1EE8
1EDE  2ADF     INCF INDF2, F, ACCESS
1EE0  0E01     MOVLW 0x1
1EE2  E301     BNC 0x1EE6
1EE4  2ADB     INCF PLUSW2, F, ACCESS
1EE6  D7E0     BRA 0x1EA8
150:                   usb_bdt[i].BDSTAT = 0;
1EC0  CFDE     MOVFF POSTINC2, FSR0L
1EC2  FFE9     NOP
1EC4  CFDD     MOVFF POSTDEC2, FSR0H
1EC6  FFEA     NOP
1EC8  90D8     BCF STATUS, 0, ACCESS
1ECA  36E9     RLCF FSR0L, F, ACCESS
1ECC  36EA     RLCF FSR0H, F, ACCESS
1ECE  90D8     BCF STATUS, 0, ACCESS
1ED0  36E9     RLCF FSR0L, F, ACCESS
1ED2  36EA     RLCF FSR0H, F, ACCESS
1ED4  0E00     MOVLW 0x0
1ED6  26E9     ADDWF FSR0L, F, ACCESS
1ED8  0E04     MOVLW 0x4
1EDA  22EA     ADDWFC FSR0H, F, ACCESS
1EDC  6AEF     CLRF INDF0, ACCESS
151:               }
152:           
153:               USB_UEP0 = USB_EP_CONTROL; // Configure Only ep0 At this point.
1EE8  0E16     MOVLW 0x16
1EEA  6E70     MOVWF UEP0, ACCESS
154:               //usbrequesterrorflag = 0;
155:           
156:           #ifdef USB_SELF_POWERED
157:           
158:               // JTR TODO this isn't actually 100% correct. "usb_device_status" is a runtime variable
159:               // In the case of a bus powered device it will always be 0x000 but in the case of
160:               // self powered with bus powered option it becames variable to the current powered
161:               // State. This is a minor thing and for now but it may need to be addressed if there is
162:               // any hardware that is dual powered.
163:           
164:               usb_device_status = 0x0001;
165:           #else
166:               usb_device_status = 0x0000;
1EEC  0100     MOVLB 0x0
1EEE  6BB1     CLRF usb_device_status, BANKED
1EF0  6BB2     CLRF 0xB2, BANKED
167:           #endif
168:               usb_device_state = DETACHED_STATE; // JTR added flag byte for enumeration state
1EF2  0100     MOVLB 0x0
1EF4  6BB5     CLRF usb_device_state, BANKED
169:               usb_current_cfg = 0; // JTR formally usb_configured
1EF6  0100     MOVLB 0x0
1EF8  6BB3     CLRF usb_current_cfg, BANKED
1EFA  6BB4     CLRF 0xB4, BANKED
170:               usb_addr_pending = 0x00;
1EFC  0100     MOVLB 0x0
1EFE  6BB6     CLRF usb_addr_pending, BANKED
171:           
172:           #if USB_PP_BUF_MODE == NO_PINGPONG
173:               usb_bdt[USB_CALC_BD(0, USB_DIR_OUT, USB_PP_EVEN)].BDCNT = USB_EP0_BUFFER_SIZE; // JTR endpoints[0].buffer_size; same thing done more obviously
1F00  0104     MOVLB 0x4
1F02  0E08     MOVLW 0x8
1F04  6F01     MOVWF c, BANKED
174:               usb_bdt[USB_CALC_BD(0, USB_DIR_OUT, USB_PP_EVEN)].BDADDR = usb_ep0_out_buf; //endpoints[0].out_buffer;
1F06  0104     MOVLB 0x4
1F08  0E8A     MOVLW 0x8A
1F0A  6F02     MOVWF c2, BANKED
1F0C  0E04     MOVLW 0x4
1F0E  6F03     MOVWF n, BANKED
175:               usb_bdt[USB_CALC_BD(0, USB_DIR_OUT, USB_PP_EVEN)].BDSTAT = UOWN + DTSEN;
1F10  0104     MOVLB 0x4
1F12  0E88     MOVLW 0x88
1F14  6F00     MOVWF i, BANKED
176:               usb_bdt[USB_CALC_BD(0, USB_DIR_IN, USB_PP_EVEN)].BDCNT = 0;
1F16  0104     MOVLB 0x4
1F18  6B05     CLRF precision, BANKED
177:               usb_bdt[USB_CALC_BD(0, USB_DIR_IN, USB_PP_EVEN)].BDADDR = usb_ep0_in_buf; //endpoints[0].in_buffer;
1F1A  0104     MOVLB 0x4
1F1C  0E92     MOVLW 0x92
1F1E  6F06     MOVWF pUEP, BANKED
1F20  0E04     MOVLW 0x4
1F22  6F07     MOVWF size, BANKED
178:               usb_bdt[USB_CALC_BD(0, USB_DIR_IN, USB_PP_EVEN)].BDSTAT = DTS + DTSEN; // Set DTS => First packet inverts, ie. is Data0
1F24  0104     MOVLB 0x4
1F26  0E48     MOVLW 0x48
1F28  6F04     MOVWF i, BANKED
179:           #else
180:           #error "Invalid PING_PONG mode"
181:           #endif
182:           }
1F2A  0E02     MOVLW 0x2
1F2C  5CE1     SUBWF FSR1L, W, ACCESS
1F2E  E202     BC 0x1F34
1F30  6AE1     CLRF FSR1L, ACCESS
1F32  52E5     MOVF POSTDEC1, F, ACCESS
1F34  6EE1     MOVWF FSR1L, ACCESS
1F36  52E5     MOVF POSTDEC1, F, ACCESS
1F38  CFE7     MOVFF INDF1, FSR2L
1F3A  FFD9     NOP
1F3C  0012     RETURN 0
183:           
184:           void usb_handler(void) {
185:           
186:               if (USB_IDLE_FLAG) {
1F3E  A868     BTFSS UIR, 4, ACCESS
1F40  D003     BRA 0x1F48
187:                   /* Idle - suspend */
188:                   USBSuspend(); // // Must be defined in user code.
1F42  ECCE     CALL 0x459C, 0
1F44  F022     NOP
189:                   ClearUsbInterruptFlag(USB_IDLE);
1F46  9868     BCF UIR, 4, ACCESS
190:               }
191:           
192:               if (USB_RESET_FLAG) {
1F48  A068     BTFSS UIR, 0, ACCESS
1F4A  D002     BRA 0x1F50
193:                   usb_handle_reset();
1F4C  DF4A     RCALL usb_handle_reset
194:                   ClearUsbInterruptFlag(USB_URST);
1F4E  9068     BCF UIR, 0, ACCESS
195:               }
196:               if (USB_ERROR_FLAG) {
1F50  A268     BTFSS UIR, 1, ACCESS
1F52  D002     BRA 0x1F58
197:                   //     usb_handle_error();
198:                   ClearAllUsbErrorInterruptFlags();
1F54  6A6A     CLRF UEIR, ACCESS
199:                   ClearUsbInterruptFlag(USB_UERR);
1F56  9268     BCF UIR, 1, ACCESS
200:               }
201:               if (USB_STALL_FLAG) {
1F58  BA68     BTFSC UIR, 5, ACCESS
202:                   ClearUsbInterruptFlag(USB_STALL);
1F5A  9A68     BCF UIR, 5, ACCESS
203:               }
204:               if (USB_SOF_FLAG) {
1F5C  AC68     BTFSS UIR, 6, ACCESS
1F5E  D00C     BRA 0x1F78
205:                   /* Start-of-frame */
206:                   if (sof_handler) sof_handler();
1F60  0100     MOVLB 0x0
1F62  516B     MOVF sof_handler, W, BANKED
1F64  116C     IORWF 0x6C, W, BANKED
1F66  E007     BZ 0x1F76
1F68  D005     BRA 0x1F74
1F6A  C06C     MOVFF 0x6C, PCLATH
1F6C  FFFA     NOP
1F6E  0100     MOVLB 0x0
1F70  516B     MOVF sof_handler, W, BANKED
1F72  6EF9     MOVWF PCL, ACCESS
1F74  DFFA     RCALL 0x1F6A
207:                   ClearUsbInterruptFlag(USB_SOF);
1F76  9C68     BCF UIR, 6, ACCESS
208:               }
209:           
210:               if (USB_TRANSACTION_FLAG) {
1F78  A668     BTFSS UIR, 3, ACCESS
1F7A  D009     BRA 0x1F8E
211:                   if (!USB_STAT2EP(GetUsbTransaction()))
1F7C  506C     MOVF USTAT, W, ACCESS
1F7E  40E8     RRNCF WREG, W, ACCESS
1F80  40E8     RRNCF WREG, W, ACCESS
1F82  40E8     RRNCF WREG, W, ACCESS
1F84  0B1F     ANDLW 0x1F
1F86  0B0F     ANDLW 0xF
1F88  E101     BNZ 0x1F8C
212:                       usb_handle_transaction(); // Only handle EP0 transactions.
1F8A  D802     RCALL usb_handle_transaction
213:                   ClearUsbInterruptFlag(USB_TRN); // JTR Missing! This is why Ian was only getting one interrupt??
1F8C  9668     BCF UIR, 3, ACCESS
214:               } // Side effect: advance USTAT Fifo
215:           }
1F8E  0012     RETURN 0
216:           
217:           void usb_handle_transaction(void) {
218:           
219:               usbrequesterrorflag = 0;
1F90  0100     MOVLB 0x0
1F92  6BC1     CLRF usbrequesterrorflag, BANKED
220:           
221:               trn_status = GetUsbTransaction();
1F94  CF6C     MOVFF USTAT, trn_status
1F96  F0B7     NOP
222:               EP0_Outbdp = &usb_bdt[USB_USTAT2BD(trn_status)];
1F98  0100     MOVLB 0x0
1F9A  51B7     MOVF trn_status, W, BANKED
1F9C  0BFC     ANDLW 0xFC
1F9E  42E8     RRNCF WREG, F, ACCESS
1FA0  42E8     RRNCF WREG, F, ACCESS
1FA2  0D04     MULLW 0x4
1FA4  CFF3     MOVFF PRODL, EP0_Outbdp
1FA6  F0B8     NOP
1FA8  CFF4     MOVFF PRODH, 0xB9
1FAA  F0B9     NOP
1FAC  0E00     MOVLW 0x0
1FAE  0100     MOVLB 0x0
1FB0  27B8     ADDWF EP0_Outbdp, F, BANKED
1FB2  0E04     MOVLW 0x4
1FB4  0100     MOVLB 0x0
1FB6  23B9     ADDWFC 0xB9, F, BANKED
223:               EP0_Inbdp = &usb_bdt[USB_USTAT2BD(trn_status | DIRBIT)]; // All replies in IN direction
1FB8  0E04     MOVLW 0x4
1FBA  0100     MOVLB 0x0
1FBC  11B7     IORWF trn_status, W, BANKED
1FBE  0BFC     ANDLW 0xFC
1FC0  42E8     RRNCF WREG, F, ACCESS
1FC2  42E8     RRNCF WREG, F, ACCESS
1FC4  0D04     MULLW 0x4
1FC6  CFF3     MOVFF PRODL, EP0_Inbdp
1FC8  F0BA     NOP
1FCA  CFF4     MOVFF PRODH, 0xBB
1FCC  F0BB     NOP
1FCE  0E00     MOVLW 0x0
1FD0  0100     MOVLB 0x0
1FD2  27BA     ADDWF EP0_Inbdp, F, BANKED
1FD4  0E04     MOVLW 0x4
1FD6  0100     MOVLB 0x0
1FD8  23BB     ADDWFC 0xBB, F, BANKED
224:           
225:               switch (EP0_Outbdp->BDSTAT & USB_TOKEN_Mask) {
1FDA  C0B8     MOVFF EP0_Outbdp, FSR0L
1FDC  FFE9     NOP
1FDE  C0B9     MOVFF 0xB9, FSR0H
1FE0  FFEA     NOP
1FE2  50EF     MOVF INDF0, W, ACCESS
1FE4  0B3C     ANDLW 0x3C
1FE6  0A24     XORLW 0x24
1FE8  E00A     BZ 0x1FFE
1FEA  0A20     XORLW 0x20
1FEC  E005     BZ 0x1FF8
1FEE  0A30     XORLW 0x30
1FF0  E001     BZ 0x1FF4
1FF2  D008     BRA 0x2004
226:                   case USB_TOKEN_SETUP:
227:                       usb_handle_setup();
1FF4  D808     RCALL usb_handle_setup
228:                       break;
1FF6  D006     BRA 0x2004
229:                   case USB_TOKEN_OUT:
230:                       usb_handle_out();
1FF8  ECF8     CALL 0x2BF0, 0
1FFA  F015     NOP
231:                       break;
1FFC  D003     BRA 0x2004
232:                   case USB_TOKEN_IN:
233:                       usb_handle_in();
1FFE  ECCA     CALL 0x2B94, 0
2000  F015     NOP
234:                       break;
2002  D000     BRA 0x2004
235:                       //default:
236:                       /* Default case of unknown TOKEN - discard */
237:               }
238:           }
2004  0012     RETURN 0
239:           
240:           void usb_handle_setup(void) {
241:           
242:               EP0_Inbdp->BDSTAT = DTSEN; // Reclaim reply buffer
2006  C0BA     MOVFF EP0_Inbdp, FSR0L
2008  FFE9     NOP
200A  C0BB     MOVFF 0xBB, FSR0H
200C  FFEA     NOP
200E  0E08     MOVLW 0x8
2010  6EEF     MOVWF INDF0, ACCESS
243:           
244:               EnablePacketTransfer(); // JTR this is placed here to overcome a errate issue with early PIC18 USB pics.
2012  986D     BCF UCON, 4, ACCESS
245:           
246:               switch (EP0_Outbdp->BDADDR[USB_bmRequestType] & USB_bmRequestType_TypeMask) {
2014  C0B8     MOVFF EP0_Outbdp, FSR0L
2016  FFE9     NOP
2018  C0B9     MOVFF 0xB9, FSR0H
201A  FFEA     NOP
201C  0E02     MOVLW 0x2
201E  26E9     ADDWF FSR0L, F, ACCESS
2020  0E00     MOVLW 0x0
2022  22EA     ADDWFC FSR0H, F, ACCESS
2024  50EE     MOVF POSTINC0, W, ACCESS
2026  CFEF     MOVFF INDF0, FSR0H
2028  FFEA     NOP
202A  6EE9     MOVWF FSR0L, ACCESS
202C  50EF     MOVF INDF0, W, ACCESS
202E  0B60     ANDLW 0x60
2030  0A40     XORLW 0x40
2032  E042     BZ 0x20B8
2034  0A60     XORLW 0x60
2036  E034     BZ 0x20A0
2038  0A20     XORLW 0x20
203A  E001     BZ 0x203E
203C  D049     BRA 0x20D0
247:                   case USB_bmRequestType_Standard:
248:                       switch (EP0_Outbdp->BDADDR[USB_bmRequestType] & USB_bmRequestType_RecipientMask) {
203E  C0B8     MOVFF EP0_Outbdp, FSR0L
2040  FFE9     NOP
2042  C0B9     MOVFF 0xB9, FSR0H
2044  FFEA     NOP
2046  0E02     MOVLW 0x2
2048  26E9     ADDWF FSR0L, F, ACCESS
204A  0E00     MOVLW 0x0
204C  22EA     ADDWFC FSR0H, F, ACCESS
204E  50EE     MOVF POSTINC0, W, ACCESS
2050  CFEF     MOVFF INDF0, FSR0H
2052  FFEA     NOP
2054  6EE9     MOVWF FSR0L, ACCESS
2056  50EF     MOVF INDF0, W, ACCESS
2058  0B03     ANDLW 0x3
205A  0A02     XORLW 0x2
205C  E015     BZ 0x2088
205E  0A03     XORLW 0x3
2060  E00B     BZ 0x2078
2062  0A01     XORLW 0x1
2064  E001     BZ 0x2068
2066  D019     BRA 0x209A
249:                           case USB_bmRequestType_Device:
250:                               usb_handle_StandardDeviceRequest(EP0_Outbdp);
2068  C0B8     MOVFF EP0_Outbdp, POSTINC1
206A  FFE6     NOP
206C  C0B9     MOVFF 0xB9, POSTINC1
206E  FFE6     NOP
2070  D87C     RCALL usb_handle_StandardDeviceRequest
2072  52E5     MOVF POSTDEC1, F, ACCESS
2074  52E5     MOVF POSTDEC1, F, ACCESS
251:                               break;
2076  D013     BRA 0x209E
252:                           case USB_bmRequestType_Interface:
253:                               usb_handle_StandardInterfaceRequest(EP0_Outbdp);
2078  C0B8     MOVFF EP0_Outbdp, POSTINC1
207A  FFE6     NOP
207C  C0B9     MOVFF 0xB9, POSTINC1
207E  FFE6     NOP
2080  DB94     RCALL usb_handle_StandardInterfaceRequest
2082  52E5     MOVF POSTDEC1, F, ACCESS
2084  52E5     MOVF POSTDEC1, F, ACCESS
254:                               break;
2086  D00B     BRA 0x209E
255:                           case USB_bmRequestType_Endpoint:
256:                               usb_handle_StandardEndpointRequest(EP0_Outbdp);
2088  C0B8     MOVFF EP0_Outbdp, POSTINC1
208A  FFE6     NOP
208C  C0B9     MOVFF 0xB9, POSTINC1
208E  FFE6     NOP
2090  EC72     CALL 0x28E4, 0
2092  F014     NOP
2094  52E5     MOVF POSTDEC1, F, ACCESS
2096  52E5     MOVF POSTDEC1, F, ACCESS
257:                               break;
2098  D002     BRA 0x209E
258:                           default:
259:                               usb_RequestError();
209A  ECB8     CALL 0x2D70, 0
209C  F016     NOP
260:                       }
261:                       break;
209E  D01A     BRA 0x20D4
262:                   case USB_bmRequestType_Class:
263:                       if (class_setup_handler) class_setup_handler();
20A0  0100     MOVLB 0x0
20A2  516D     MOVF class_setup_handler, W, BANKED
20A4  116E     IORWF 0x6E, W, BANKED
20A6  E007     BZ 0x20B6
20A8  D005     BRA 0x20B4
20AA  C06E     MOVFF 0x6E, PCLATH
20AC  FFFA     NOP
20AE  0100     MOVLB 0x0
20B0  516D     MOVF class_setup_handler, W, BANKED
20B2  6EF9     MOVWF PCL, ACCESS
20B4  DFFA     RCALL 0x20AA
264:                       break;
20B6  D00E     BRA 0x20D4
265:                   case USB_bmRequestType_Vendor:
266:           			//ROBOTS FIX: http://dangerousprototypes.com/forum/viewtopic.php?f=39&t=3849&view=unread#unread
267:           			// did call class_setup_handler();
268:                       if (vendor_setup_handler) vendor_setup_handler();
20B8  0100     MOVLB 0x0
20BA  516F     MOVF vendor_setup_handler, W, BANKED
20BC  1170     IORWF 0x70, W, BANKED
20BE  E007     BZ 0x20CE
20C0  D005     BRA 0x20CC
20C2  C070     MOVFF 0x70, PCLATH
20C4  FFFA     NOP
20C6  0100     MOVLB 0x0
20C8  516F     MOVF vendor_setup_handler, W, BANKED
20CA  6EF9     MOVWF PCL, ACCESS
20CC  DFFA     RCALL 0x20C2
269:                       break;
20CE  D002     BRA 0x20D4
270:                   default:
271:                       usb_RequestError();
20D0  ECB8     CALL 0x2D70, 0
20D2  F016     NOP
272:               }
273:               /* Prepare endpoint for new reception */
274:           
275:               EP0_Outbdp->BDCNT = USB_EP0_BUFFER_SIZE; // Size  of EP0, should always be ep0?
20D4  C0B8     MOVFF EP0_Outbdp, FSR0L
20D6  FFE9     NOP
20D8  C0B9     MOVFF 0xB9, FSR0H
20DA  FFEA     NOP
20DC  52EE     MOVF POSTINC0, F, ACCESS
20DE  0E08     MOVLW 0x8
20E0  6EEF     MOVWF INDF0, ACCESS
276:           
277:               // JTR, is the next OUT transfer to be a setup packet (DAT0) or a DATA packet (DAT1)?
278:               // note that this is not an entirely robust way of doing things. See the microchip stack for
279:               // further comments and a better system as this does not account for errors and retries
280:               // and it results in the SIE not accepting the final out ZLP status packet for IN transfers
281:               // with a data stage. However it works but it is not anything to be proud of...
282:           
283:               EP0_Outbdp->BDSTAT = (!(EP0_Outbdp->BDADDR[USB_bmRequestType] & USB_bmRequestType_PhaseMask) &&
20E2  C0B8     MOVFF EP0_Outbdp, FSR0L
20E4  FFE9     NOP
20E6  C0B9     MOVFF 0xB9, FSR0H
20E8  FFEA     NOP
20EA  0E02     MOVLW 0x2
20EC  26E9     ADDWF FSR0L, F, ACCESS
20EE  0E00     MOVLW 0x0
20F0  22EA     ADDWFC FSR0H, F, ACCESS
20F2  50EE     MOVF POSTINC0, W, ACCESS
20F4  CFEF     MOVFF INDF0, FSR0H
20F6  FFEA     NOP
20F8  6EE9     MOVWF FSR0L, ACCESS
20FA  50EF     MOVF INDF0, W, ACCESS
20FC  0B80     ANDLW 0x80
215A  C0B8     MOVFF EP0_Outbdp, FSR0L
215C  FFE9     NOP
215E  C0B9     MOVFF 0xB9, FSR0H
2160  FFEA     NOP
284:                       (EP0_Outbdp->BDADDR[USB_wLength] || EP0_Outbdp->BDADDR[USB_wLengthHigh])) ? UOWN + DTS + DTSEN : UOWN + DTSEN;
20FE  E124     BNZ 0x2148
2100  C0B8     MOVFF EP0_Outbdp, FSR0L
2102  FFE9     NOP
2104  C0B9     MOVFF 0xB9, FSR0H
2106  FFEA     NOP
2108  0E02     MOVLW 0x2
210A  26E9     ADDWF FSR0L, F, ACCESS
210C  0E00     MOVLW 0x0
210E  22EA     ADDWFC FSR0H, F, ACCESS
2110  50EE     MOVF POSTINC0, W, ACCESS
2112  CFEF     MOVFF INDF0, FSR0H
2114  FFEA     NOP
2116  6EE9     MOVWF FSR0L, ACCESS
2118  0E06     MOVLW 0x6
211A  26E9     ADDWF FSR0L, F, ACCESS
211C  0E00     MOVLW 0x0
211E  22EA     ADDWFC FSR0H, F, ACCESS
2120  50EF     MOVF INDF0, W, ACCESS
2122  E114     BNZ 0x214C
2124  C0B8     MOVFF EP0_Outbdp, FSR0L
2126  FFE9     NOP
2128  C0B9     MOVFF 0xB9, FSR0H
212A  FFEA     NOP
212C  0E02     MOVLW 0x2
212E  26E9     ADDWF FSR0L, F, ACCESS
2130  0E00     MOVLW 0x0
2132  22EA     ADDWFC FSR0H, F, ACCESS
2134  50EE     MOVF POSTINC0, W, ACCESS
2136  CFEF     MOVFF INDF0, FSR0H
2138  FFEA     NOP
213A  6EE9     MOVWF FSR0L, ACCESS
213C  0E07     MOVLW 0x7
213E  26E9     ADDWF FSR0L, F, ACCESS
2140  0E00     MOVLW 0x0
2142  22EA     ADDWFC FSR0H, F, ACCESS
2144  50EF     MOVF INDF0, W, ACCESS
2146  E102     BNZ 0x214C
2148  0E00     MOVLW 0x0
214A  D001     BRA 0x214E
214C  0E01     MOVLW 0x1
214E  0900     IORLW 0x0
2150  E002     BZ 0x2156
2152  0EC8     MOVLW 0xC8
2154  D001     BRA 0x2158
2156  0E88     MOVLW 0x88
2158  6EE6     MOVWF POSTINC1, ACCESS
2162  52E5     MOVF POSTDEC1, F, ACCESS
2164  50E7     MOVF INDF1, W, ACCESS
2166  6EEF     MOVWF INDF0, ACCESS
285:           }
2168  0012     RETURN 0
286:           
287:           void usb_handle_StandardDeviceRequest(BDentry *bdp) {
216A  CFD9     MOVFF FSR2L, POSTINC1
216C  FFE6     NOP
216E  CFE1     MOVFF FSR1L, FSR2L
2170  FFD9     NOP
2172  0E04     MOVLW 0x4
2174  26E1     ADDWF FSR1L, F, ACCESS
288:               BYTE *packet = bdp->BDADDR;
2176  0EFD     MOVLW 0xFD
2178  CFDB     MOVFF PLUSW2, FSR0L
217A  FFE9     NOP
217C  0EFE     MOVLW 0xFE
217E  CFDB     MOVFF PLUSW2, FSR0H
2180  FFEA     NOP
2182  0E02     MOVLW 0x2
2184  26E9     ADDWF FSR0L, F, ACCESS
2186  0E00     MOVLW 0x0
2188  22EA     ADDWFC FSR0H, F, ACCESS
218A  CFEE     MOVFF POSTINC0, POSTINC2
218C  FFDE     NOP
218E  CFED     MOVFF POSTDEC0, POSTDEC2
2190  FFDD     NOP
289:               int i;
290:           
291:               switch (packet[USB_bRequest]) {
2192  CFDE     MOVFF POSTINC2, FSR0L
2194  FFE9     NOP
2196  CFDD     MOVFF POSTDEC2, FSR0H
2198  FFEA     NOP
219A  0E01     MOVLW 0x1
219C  26E9     ADDWF FSR0L, F, ACCESS
219E  0E00     MOVLW 0x0
21A0  22EA     ADDWFC FSR0H, F, ACCESS
21A2  50EF     MOVF INDF0, W, ACCESS
21A4  0A07     XORLW 0x7
21A6  E101     BNZ 0x21AA
21A8  D2F5     BRA 0x2794
21AA  0A0E     XORLW 0xE
21AC  E101     BNZ 0x21B0
21AE  D2C3     BRA 0x2736
21B0  0A01     XORLW 0x1
21B2  E101     BNZ 0x21B6
21B4  D2AB     BRA 0x270C
21B6  0A0E     XORLW 0xE
21B8  E101     BNZ 0x21BC
21BA  D09F     BRA 0x22FA
21BC  0A03     XORLW 0x3
21BE  E064     BZ 0x2288
21C0  0A06     XORLW 0x6
21C2  E04B     BZ 0x225A
21C4  0A02     XORLW 0x2
21C6  E032     BZ 0x222C
21C8  0A01     XORLW 0x1
21CA  E001     BZ 0x21CE
21CC  D2E3     BRA 0x2794
292:                   case USB_REQUEST_GET_STATUS:
293:                       EP0_Inbdp->BDADDR[0] = usb_device_status & 0xFF;
21CE  0100     MOVLB 0x0
21D0  51B1     MOVF usb_device_status, W, BANKED
21D2  6EE6     MOVWF POSTINC1, ACCESS
21D4  C0BA     MOVFF EP0_Inbdp, FSR0L
21D6  FFE9     NOP
21D8  C0BB     MOVFF 0xBB, FSR0H
21DA  FFEA     NOP
21DC  0E02     MOVLW 0x2
21DE  26E9     ADDWF FSR0L, F, ACCESS
21E0  0E00     MOVLW 0x0
21E2  22EA     ADDWFC FSR0H, F, ACCESS
21E4  50EE     MOVF POSTINC0, W, ACCESS
21E6  CFEF     MOVFF INDF0, FSR0H
21E8  FFEA     NOP
21EA  6EE9     MOVWF FSR0L, ACCESS
21EC  52E5     MOVF POSTDEC1, F, ACCESS
21EE  50E7     MOVF INDF1, W, ACCESS
21F0  6EEF     MOVWF INDF0, ACCESS
294:                       EP0_Inbdp->BDADDR[1] = usb_device_status >> 8;
21F2  C0B2     MOVFF 0xB2, __tmp_0
21F4  F014     NOP
21F6  6A15     CLRF digit_cnt, ACCESS
21F8  C0BA     MOVFF EP0_Inbdp, FSR0L
21FA  FFE9     NOP
21FC  C0BB     MOVFF 0xBB, FSR0H
21FE  FFEA     NOP
2200  0E02     MOVLW 0x2
2202  26E9     ADDWF FSR0L, F, ACCESS
2204  0E00     MOVLW 0x0
2206  22EA     ADDWFC FSR0H, F, ACCESS
2208  50EE     MOVF POSTINC0, W, ACCESS
220A  CFEF     MOVFF INDF0, FSR0H
220C  FFEA     NOP
220E  6EE9     MOVWF FSR0L, ACCESS
2210  0E01     MOVLW 0x1
2212  26E9     ADDWF FSR0L, F, ACCESS
2214  0E00     MOVLW 0x0
2216  22EA     ADDWFC FSR0H, F, ACCESS
2218  C014     MOVFF __tmp_0, INDF0
221A  FFEF     NOP
295:                       usb_ack_dat1(2);
221C  0E02     MOVLW 0x2
221E  6EE6     MOVWF POSTINC1, ACCESS
2220  6AE6     CLRF POSTINC1, ACCESS
2222  EC98     CALL 0x2D30, 0
2224  F016     NOP
2226  52E5     MOVF POSTDEC1, F, ACCESS
2228  52E5     MOVF POSTDEC1, F, ACCESS
296:                       break;
222A  D2B5     BRA 0x2796
297:                   case USB_REQUEST_CLEAR_FEATURE:
298:                       if (0x01u == packet[USB_wValue]) { // TODO: Remove magic (REMOTE_WAKEUP_FEATURE)
222C  CFDE     MOVFF POSTINC2, FSR0L
222E  FFE9     NOP
2230  CFDD     MOVFF POSTDEC2, FSR0H
2232  FFEA     NOP
2234  0E02     MOVLW 0x2
2236  26E9     ADDWF FSR0L, F, ACCESS
2238  0E00     MOVLW 0x0
223A  22EA     ADDWFC FSR0H, F, ACCESS
223C  04EF     DECF INDF0, W, ACCESS
223E  E10A     BNZ 0x2254
299:                           usb_device_status &= ~0x0002;
2240  0100     MOVLB 0x0
2242  93B1     BCF usb_device_status, 1, BANKED
300:                           usb_ack_dat1(0);
2244  0E00     MOVLW 0x0
2246  6EE6     MOVWF POSTINC1, ACCESS
2248  6AE6     CLRF POSTINC1, ACCESS
224A  EC98     CALL 0x2D30, 0
224C  F016     NOP
224E  52E5     MOVF POSTDEC1, F, ACCESS
2250  52E5     MOVF POSTDEC1, F, ACCESS
301:                       } else
2252  D002     BRA 0x2258
302:                           usb_RequestError();
2254  ECB8     CALL 0x2D70, 0
2256  F016     NOP
303:                       break;
2258  D29E     BRA 0x2796
304:                   case USB_REQUEST_SET_FEATURE:
305:                       if (0x01u == packet[USB_wValue]) { // TODO: Remove magic (REMOTE_WAKEUP_FEATURE)
225A  CFDE     MOVFF POSTINC2, FSR0L
225C  FFE9     NOP
225E  CFDD     MOVFF POSTDEC2, FSR0H
2260  FFEA     NOP
2262  0E02     MOVLW 0x2
2264  26E9     ADDWF FSR0L, F, ACCESS
2266  0E00     MOVLW 0x0
2268  22EA     ADDWFC FSR0H, F, ACCESS
226A  04EF     DECF INDF0, W, ACCESS
226C  E10A     BNZ 0x2282
306:                           usb_device_status |= 0x0002;
226E  0100     MOVLB 0x0
2270  83B1     BSF usb_device_status, 1, BANKED
307:                           usb_ack_dat1(0);
2272  0E00     MOVLW 0x0
2274  6EE6     MOVWF POSTINC1, ACCESS
2276  6AE6     CLRF POSTINC1, ACCESS
2278  EC98     CALL 0x2D30, 0
227A  F016     NOP
227C  52E5     MOVF POSTDEC1, F, ACCESS
227E  52E5     MOVF POSTDEC1, F, ACCESS
308:                       } else
2280  D002     BRA 0x2286
309:                           usb_RequestError();
2282  ECB8     CALL 0x2D70, 0
2284  F016     NOP
310:                       break;
2286  D287     BRA 0x2796
311:                   case USB_REQUEST_SET_ADDRESS:
312:                       if (0x00u == packet[USB_wValueHigh] && 0x7Fu >= packet[USB_wValue]) {
2288  CFDE     MOVFF POSTINC2, FSR0L
228A  FFE9     NOP
228C  CFDD     MOVFF POSTDEC2, FSR0H
228E  FFEA     NOP
2290  0E03     MOVLW 0x3
2292  26E9     ADDWF FSR0L, F, ACCESS
2294  0E00     MOVLW 0x0
2296  22EA     ADDWFC FSR0H, F, ACCESS
2298  50EF     MOVF INDF0, W, ACCESS
229A  E12C     BNZ 0x22F4
229C  0E7F     MOVLW 0x7F
229E  6E14     MOVWF __tmp_0, ACCESS
22A0  CFDE     MOVFF POSTINC2, FSR0L
22A2  FFE9     NOP
22A4  CFDD     MOVFF POSTDEC2, FSR0H
22A6  FFEA     NOP
22A8  0E02     MOVLW 0x2
22AA  26E9     ADDWF FSR0L, F, ACCESS
22AC  0E00     MOVLW 0x0
22AE  22EA     ADDWFC FSR0H, F, ACCESS
22B0  50EF     MOVF INDF0, W, ACCESS
22B2  5C14     SUBWF __tmp_0, W, ACCESS
22B4  E31F     BNC 0x22F4
313:                           usb_addr_pending = packet[USB_wValue];
22B6  CFDE     MOVFF POSTINC2, FSR0L
22B8  FFE9     NOP
22BA  CFDD     MOVFF POSTDEC2, FSR0H
22BC  FFEA     NOP
22BE  0E02     MOVLW 0x2
22C0  26E9     ADDWF FSR0L, F, ACCESS
22C2  0E00     MOVLW 0x0
22C4  22EA     ADDWFC FSR0H, F, ACCESS
22C6  CFEF     MOVFF INDF0, usb_addr_pending
22C8  F0B6     NOP
314:                           usb_set_in_handler(0, usb_set_address);
22CA  0E84     MOVLW 0x84
22CC  6EE6     MOVWF POSTINC1, ACCESS
22CE  0E2D     MOVLW 0x2D
22D0  6EE6     MOVWF POSTINC1, ACCESS
22D2  0E00     MOVLW 0x0
22D4  6EE6     MOVWF POSTINC1, ACCESS
22D6  6AE6     CLRF POSTINC1, ACCESS
22D8  EC58     CALL 0x2CB0, 0
22DA  F016     NOP
22DC  52E5     MOVF POSTDEC1, F, ACCESS
22DE  52E5     MOVF POSTDEC1, F, ACCESS
22E0  52E5     MOVF POSTDEC1, F, ACCESS
22E2  52E5     MOVF POSTDEC1, F, ACCESS
315:                           usb_ack_dat1(0);
22E4  0E00     MOVLW 0x0
22E6  6EE6     MOVWF POSTINC1, ACCESS
22E8  6AE6     CLRF POSTINC1, ACCESS
22EA  EC98     CALL 0x2D30, 0
22EC  F016     NOP
22EE  52E5     MOVF POSTDEC1, F, ACCESS
22F0  52E5     MOVF POSTDEC1, F, ACCESS
316:                       } else
22F2  D002     BRA 0x22F8
317:                           usb_RequestError();
22F4  ECB8     CALL 0x2D70, 0
22F6  F016     NOP
318:                       break;
22F8  D24E     BRA 0x2796
319:           
320:           
321:                   case USB_REQUEST_GET_DESCRIPTOR:
322:                       switch (packet[USB_bDescriptorType]) {
22FA  CFDE     MOVFF POSTINC2, FSR0L
22FC  FFE9     NOP
22FE  CFDD     MOVFF POSTDEC2, FSR0H
2300  FFEA     NOP
2302  0E03     MOVLW 0x3
2304  26E9     ADDWF FSR0L, F, ACCESS
2306  0E00     MOVLW 0x0
2308  22EA     ADDWFC FSR0H, F, ACCESS
230A  50EF     MOVF INDF0, W, ACCESS
230C  0A04     XORLW 0x4
230E  E101     BNZ 0x2312
2310  D1E7     BRA 0x26E0
2312  0A01     XORLW 0x1
2314  E101     BNZ 0x2318
2316  D1E4     BRA 0x26E0
2318  0A06     XORLW 0x6
231A  E101     BNZ 0x231E
231C  D14F     BRA 0x25BC
231E  0A01     XORLW 0x1
2320  E03F     BZ 0x23A0
2322  0A03     XORLW 0x3
2324  E001     BZ 0x2328
2326  D1DC     BRA 0x26E0
323:                           case USB_DEVICE_DESCRIPTOR_TYPE: // There is only every one in pratice.
324:                               usb_rom_ptr = usb_device_descriptor;
2328  C060     MOVFF usb_device_descriptor, usb_rom_ptr
232A  F0BC     NOP
232C  C061     MOVFF 0x61, 0xBD
232E  F0BD     NOP
2330  C062     MOVFF 0x62, 0xBE
2332  F0BE     NOP
325:                               usb_rom_len = usb_device_descriptor[0]; // Get BYTE length from descriptor always at byte [0]
2334  C060     MOVFF usb_device_descriptor, TBLPTRL
2336  FFF6     NOP
2338  C061     MOVFF 0x61, TBLPTRH
233A  FFF7     NOP
233C  C062     MOVFF 0x62, TBLPTRU
233E  FFF8     NOP
2340  0008     TBLRD*
2342  50F5     MOVF TABLAT, W, ACCESS
2344  0100     MOVLB 0x0
2346  6FBF     MOVWF usb_rom_len, BANKED
2348  6BC0     CLRF 0xC0, BANKED
326:                               if ((0 == packet[USB_wLengthHigh] && packet[USB_wLength] < usb_rom_ptr[0]))
234A  CFDE     MOVFF POSTINC2, FSR0L
234C  FFE9     NOP
234E  CFDD     MOVFF POSTDEC2, FSR0H
2350  FFEA     NOP
2352  0E07     MOVLW 0x7
2354  26E9     ADDWF FSR0L, F, ACCESS
2356  0E00     MOVLW 0x0
2358  22EA     ADDWFC FSR0H, F, ACCESS
235A  50EF     MOVF INDF0, W, ACCESS
235C  E120     BNZ 0x239E
235E  CFDE     MOVFF POSTINC2, FSR0L
2360  FFE9     NOP
2362  CFDD     MOVFF POSTDEC2, FSR0H
2364  FFEA     NOP
2366  0E06     MOVLW 0x6
2368  26E9     ADDWF FSR0L, F, ACCESS
236A  0E00     MOVLW 0x0
236C  22EA     ADDWFC FSR0H, F, ACCESS
236E  CFEF     MOVFF INDF0, __tmp_0
2370  F014     NOP
2372  C0BC     MOVFF usb_rom_ptr, TBLPTRL
2374  FFF6     NOP
2376  C0BD     MOVFF 0xBD, TBLPTRH
2378  FFF7     NOP
237A  C0BE     MOVFF 0xBE, TBLPTRU
237C  FFF8     NOP
237E  0008     TBLRD*
2380  50F5     MOVF TABLAT, W, ACCESS
2382  5C14     SUBWF __tmp_0, W, ACCESS
2384  E20C     BC 0x239E
327:                                   usb_rom_len = packet[USB_wLength]; // If the HOST asked for LESS then must adjust count to the smaller number
2386  CFDE     MOVFF POSTINC2, FSR0L
2388  FFE9     NOP
238A  CFDD     MOVFF POSTDEC2, FSR0H
238C  FFEA     NOP
238E  0E06     MOVLW 0x6
2390  26E9     ADDWF FSR0L, F, ACCESS
2392  0E00     MOVLW 0x0
2394  22EA     ADDWFC FSR0H, F, ACCESS
2396  50EF     MOVF INDF0, W, ACCESS
2398  0100     MOVLB 0x0
239A  6FBF     MOVWF usb_rom_len, BANKED
239C  6BC0     CLRF 0xC0, BANKED
328:                               break;
239E  D1A3     BRA 0x26E6
329:           
330:                           case USB_CONFIGURATION_DESCRIPTOR_TYPE:
331:                               if (packet[USB_bDescriptorIndex] >= usb_device_descriptor[17]) {
23A0  CFDE     MOVFF POSTINC2, FSR0L
23A2  FFE9     NOP
23A4  CFDD     MOVFF POSTDEC2, FSR0H
23A6  FFEA     NOP
23A8  0E02     MOVLW 0x2
23AA  26E9     ADDWF FSR0L, F, ACCESS
23AC  0E00     MOVLW 0x0
23AE  22EA     ADDWFC FSR0H, F, ACCESS
23B0  CFEF     MOVFF INDF0, __tmp_0
23B2  F014     NOP
23B4  C060     MOVFF usb_device_descriptor, TBLPTRL
23B6  FFF6     NOP
23B8  C061     MOVFF 0x61, TBLPTRH
23BA  FFF7     NOP
23BC  C062     MOVFF 0x62, TBLPTRU
23BE  FFF8     NOP
23C0  0E11     MOVLW 0x11
23C2  26F6     ADDWF TBLPTRL, F, ACCESS
23C4  0E00     MOVLW 0x0
23C6  22F7     ADDWFC TBLPTRH, F, ACCESS
23C8  0E00     MOVLW 0x0
23CA  22F8     ADDWFC TBLPTRU, F, ACCESS
23CC  0008     TBLRD*
23CE  50F5     MOVF TABLAT, W, ACCESS
23D0  5C14     SUBWF __tmp_0, W, ACCESS
23D2  E304     BNC 0x23DC
332:                                   flag_usb_RequestError();
23D4  0100     MOVLB 0x0
23D6  0E01     MOVLW 0x1
23D8  6FC1     MOVWF usbrequesterrorflag, BANKED
333:                                   break;
23DA  D185     BRA 0x26E6
334:                               }
335:           
336:                               usb_rom_ptr = usb_config_descriptor;
23DC  C063     MOVFF usb_config_descriptor, usb_rom_ptr
23DE  F0BC     NOP
23E0  C064     MOVFF 0x64, 0xBD
23E2  F0BD     NOP
23E4  C065     MOVFF 0x65, 0xBE
23E6  F0BE     NOP
337:                               usb_rom_len = usb_rom_ptr[2] + usb_rom_ptr[3] * 256; // Get WORD length from descriptor always at bytes 2&3 (Low-High)
23E8  C0BC     MOVFF usb_rom_ptr, TBLPTRL
23EA  FFF6     NOP
23EC  C0BD     MOVFF 0xBD, TBLPTRH
23EE  FFF7     NOP
23F0  C0BE     MOVFF 0xBE, TBLPTRU
23F2  FFF8     NOP
23F4  0E03     MOVLW 0x3
23F6  26F6     ADDWF TBLPTRL, F, ACCESS
23F8  0E00     MOVLW 0x0
23FA  22F7     ADDWFC TBLPTRH, F, ACCESS
23FC  0E00     MOVLW 0x0
23FE  22F8     ADDWFC TBLPTRU, F, ACCESS
2400  0008     TBLRD*
2402  50F5     MOVF TABLAT, W, ACCESS
2404  6E14     MOVWF __tmp_0, ACCESS
2406  6A15     CLRF digit_cnt, ACCESS
2408  C014     MOVFF __tmp_0, digit_cnt
240A  F015     NOP
240C  6A14     CLRF __tmp_0, ACCESS
240E  C0BC     MOVFF usb_rom_ptr, TBLPTRL
2410  FFF6     NOP
2412  C0BD     MOVFF 0xBD, TBLPTRH
2414  FFF7     NOP
2416  C0BE     MOVFF 0xBE, TBLPTRU
2418  FFF8     NOP
241A  0E02     MOVLW 0x2
241C  26F6     ADDWF TBLPTRL, F, ACCESS
241E  0E00     MOVLW 0x0
2420  22F7     ADDWFC TBLPTRH, F, ACCESS
2422  0E00     MOVLW 0x0
2424  22F8     ADDWFC TBLPTRU, F, ACCESS
2426  0008     TBLRD*
2428  50F5     MOVF TABLAT, W, ACCESS
242A  0100     MOVLB 0x0
242C  2414     ADDWF __tmp_0, W, ACCESS
242E  6FBF     MOVWF usb_rom_len, BANKED
2430  0E00     MOVLW 0x0
2432  2015     ADDWFC digit_cnt, W, ACCESS
2434  6FC0     MOVWF 0xC0, BANKED
338:                               for (i = 0; i < packet[USB_bDescriptorIndex]; i++) { // Implicit linked list traversal until requested configuration
2436  0E02     MOVLW 0x2
2438  6ADB     CLRF PLUSW2, ACCESS
243A  0E03     MOVLW 0x3
243C  6ADB     CLRF PLUSW2, ACCESS
243E  0E02     MOVLW 0x2
2440  CFDB     MOVFF PLUSW2, __tmp_0
2442  F014     NOP
2444  0E03     MOVLW 0x3
2446  CFDB     MOVFF PLUSW2, digit_cnt
2448  F015     NOP
244A  CFDE     MOVFF POSTINC2, FSR0L
244C  FFE9     NOP
244E  CFDD     MOVFF POSTDEC2, FSR0H
2450  FFEA     NOP
2452  0E02     MOVLW 0x2
2454  26E9     ADDWF FSR0L, F, ACCESS
2456  0E00     MOVLW 0x0
2458  22EA     ADDWFC FSR0H, F, ACCESS
245A  50EF     MOVF INDF0, W, ACCESS
245C  0100     MOVLB 0x0
245E  AE15     BTFSS digit_cnt, 7, ACCESS
2460  D002     BRA 0x2466
2462  90D8     BCF STATUS, 0, ACCESS
2464  D003     BRA 0x246C
2466  5C14     SUBWF __tmp_0, W, ACCESS
2468  0E00     MOVLW 0x0
246A  5815     SUBWFB digit_cnt, W, ACCESS
246C  E23B     BC 0x24E4
24D8  0E02     MOVLW 0x2
24DA  2ADB     INCF PLUSW2, F, ACCESS
24DC  0E03     MOVLW 0x3
24DE  E301     BNC 0x24E2
24E0  2ADB     INCF PLUSW2, F, ACCESS
24E2  D7AD     BRA 0x243E
339:                                   usb_rom_ptr += usb_rom_len;
246E  C0BF     MOVFF usb_rom_len, __tmp_0
2470  F014     NOP
2472  C0C0     MOVFF 0xC0, digit_cnt
2474  F015     NOP
2476  6A16     CLRF prefix_cnt, ACCESS
2478  5014     MOVF __tmp_0, W, ACCESS
247A  0100     MOVLB 0x0
247C  27BC     ADDWF usb_rom_ptr, F, BANKED
247E  5015     MOVF digit_cnt, W, ACCESS
2480  0100     MOVLB 0x0
2482  23BD     ADDWFC 0xBD, F, BANKED
2484  5016     MOVF prefix_cnt, W, ACCESS
2486  0100     MOVLB 0x0
2488  23BE     ADDWFC 0xBE, F, BANKED
340:                                   usb_rom_len = usb_rom_ptr[2] + usb_rom_ptr[3] * 256; // Get (next) WORD length from descriptor always at bytes 2&3 (Low-High)
248A  C0BC     MOVFF usb_rom_ptr, TBLPTRL
248C  FFF6     NOP
248E  C0BD     MOVFF 0xBD, TBLPTRH
2490  FFF7     NOP
2492  C0BE     MOVFF 0xBE, TBLPTRU
2494  FFF8     NOP
2496  0E03     MOVLW 0x3
2498  26F6     ADDWF TBLPTRL, F, ACCESS
249A  0E00     MOVLW 0x0
249C  22F7     ADDWFC TBLPTRH, F, ACCESS
249E  0E00     MOVLW 0x0
24A0  22F8     ADDWFC TBLPTRU, F, ACCESS
24A2  0008     TBLRD*
24A4  50F5     MOVF TABLAT, W, ACCESS
24A6  6E14     MOVWF __tmp_0, ACCESS
24A8  6A15     CLRF digit_cnt, ACCESS
24AA  C014     MOVFF __tmp_0, digit_cnt
24AC  F015     NOP
24AE  6A14     CLRF __tmp_0, ACCESS
24B0  C0BC     MOVFF usb_rom_ptr, TBLPTRL
24B2  FFF6     NOP
24B4  C0BD     MOVFF 0xBD, TBLPTRH
24B6  FFF7     NOP
24B8  C0BE     MOVFF 0xBE, TBLPTRU
24BA  FFF8     NOP
24BC  0E02     MOVLW 0x2
24BE  26F6     ADDWF TBLPTRL, F, ACCESS
24C0  0E00     MOVLW 0x0
24C2  22F7     ADDWFC TBLPTRH, F, ACCESS
24C4  0E00     MOVLW 0x0
24C6  22F8     ADDWFC TBLPTRU, F, ACCESS
24C8  0008     TBLRD*
24CA  50F5     MOVF TABLAT, W, ACCESS
24CC  0100     MOVLB 0x0
24CE  2414     ADDWF __tmp_0, W, ACCESS
24D0  6FBF     MOVWF usb_rom_len, BANKED
24D2  0E00     MOVLW 0x0
24D4  2015     ADDWFC digit_cnt, W, ACCESS
24D6  6FC0     MOVWF 0xC0, BANKED
341:                               }
342:                               if ((packet[USB_wLengthHigh] < usb_rom_ptr[3]) ||
24E4  CFDE     MOVFF POSTINC2, FSR0L
24E6  FFE9     NOP
24E8  CFDD     MOVFF POSTDEC2, FSR0H
24EA  FFEA     NOP
24EC  0E07     MOVLW 0x7
24EE  26E9     ADDWF FSR0L, F, ACCESS
24F0  0E00     MOVLW 0x0
24F2  22EA     ADDWFC FSR0H, F, ACCESS
24F4  CFEF     MOVFF INDF0, __tmp_0
24F6  F014     NOP
24F8  C0BC     MOVFF usb_rom_ptr, TBLPTRL
24FA  FFF6     NOP
24FC  C0BD     MOVFF 0xBD, TBLPTRH
24FE  FFF7     NOP
2500  C0BE     MOVFF 0xBE, TBLPTRU
2502  FFF8     NOP
2504  0E03     MOVLW 0x3
2506  26F6     ADDWF TBLPTRL, F, ACCESS
2508  0E00     MOVLW 0x0
250A  22F7     ADDWFC TBLPTRH, F, ACCESS
250C  0E00     MOVLW 0x0
250E  22F8     ADDWFC TBLPTRU, F, ACCESS
2510  0008     TBLRD*
2512  50F5     MOVF TABLAT, W, ACCESS
2514  5C14     SUBWF __tmp_0, W, ACCESS
343:                                       (packet[USB_wLengthHigh] == usb_rom_ptr[3] && packet[USB_wLength] < usb_rom_ptr[2]))
2516  E334     BNC 0x2580
2518  CFDE     MOVFF POSTINC2, FSR0L
251A  FFE9     NOP
251C  CFDD     MOVFF POSTDEC2, FSR0H
251E  FFEA     NOP
2520  0E07     MOVLW 0x7
2522  26E9     ADDWF FSR0L, F, ACCESS
2524  0E00     MOVLW 0x0
2526  22EA     ADDWFC FSR0H, F, ACCESS
2528  CFEF     MOVFF INDF0, digit_cnt
252A  F015     NOP
252C  C0BC     MOVFF usb_rom_ptr, TBLPTRL
252E  FFF6     NOP
2530  C0BD     MOVFF 0xBD, TBLPTRH
2532  FFF7     NOP
2534  C0BE     MOVFF 0xBE, TBLPTRU
2536  FFF8     NOP
2538  0E03     MOVLW 0x3
253A  26F6     ADDWF TBLPTRL, F, ACCESS
253C  0E00     MOVLW 0x0
253E  22F7     ADDWFC TBLPTRH, F, ACCESS
2540  0E00     MOVLW 0x0
2542  22F8     ADDWFC TBLPTRU, F, ACCESS
2544  0008     TBLRD*
2546  50F5     MOVF TABLAT, W, ACCESS
2548  5C15     SUBWF digit_cnt, W, ACCESS
254A  E137     BNZ 0x25BA
254C  CFDE     MOVFF POSTINC2, FSR0L
254E  FFE9     NOP
2550  CFDD     MOVFF POSTDEC2, FSR0H
2552  FFEA     NOP
2554  0E06     MOVLW 0x6
2556  26E9     ADDWF FSR0L, F, ACCESS
2558  0E00     MOVLW 0x0
255A  22EA     ADDWFC FSR0H, F, ACCESS
255C  CFEF     MOVFF INDF0, prefix_cnt
255E  F016     NOP
2560  C0BC     MOVFF usb_rom_ptr, TBLPTRL
2562  FFF6     NOP
2564  C0BD     MOVFF 0xBD, TBLPTRH
2566  FFF7     NOP
2568  C0BE     MOVFF 0xBE, TBLPTRU
256A  FFF8     NOP
256C  0E02     MOVLW 0x2
256E  26F6     ADDWF TBLPTRL, F, ACCESS
2570  0E00     MOVLW 0x0
2572  22F7     ADDWFC TBLPTRH, F, ACCESS
2574  0E00     MOVLW 0x0
2576  22F8     ADDWFC TBLPTRU, F, ACCESS
2578  0008     TBLRD*
257A  50F5     MOVF TABLAT, W, ACCESS
257C  5C16     SUBWF prefix_cnt, W, ACCESS
257E  E21D     BC 0x25BA
344:                                   usb_rom_len = packet[USB_wLength] + packet[USB_wLengthHigh] * 256; // If the HOST asked for LESS then must adjust count to the smaller number
2580  CFDE     MOVFF POSTINC2, FSR0L
2582  FFE9     NOP
2584  CFDD     MOVFF POSTDEC2, FSR0H
2586  FFEA     NOP
2588  0E07     MOVLW 0x7
258A  26E9     ADDWF FSR0L, F, ACCESS
258C  0E00     MOVLW 0x0
258E  22EA     ADDWFC FSR0H, F, ACCESS
2590  50EF     MOVF INDF0, W, ACCESS
2592  6E14     MOVWF __tmp_0, ACCESS
2594  6A15     CLRF digit_cnt, ACCESS
2596  C014     MOVFF __tmp_0, digit_cnt
2598  F015     NOP
259A  6A14     CLRF __tmp_0, ACCESS
259C  CFDE     MOVFF POSTINC2, FSR0L
259E  FFE9     NOP
25A0  CFDD     MOVFF POSTDEC2, FSR0H
25A2  FFEA     NOP
25A4  0E06     MOVLW 0x6
25A6  26E9     ADDWF FSR0L, F, ACCESS
25A8  0E00     MOVLW 0x0
25AA  22EA     ADDWFC FSR0H, F, ACCESS
25AC  50EF     MOVF INDF0, W, ACCESS
25AE  0100     MOVLB 0x0
25B0  2414     ADDWF __tmp_0, W, ACCESS
25B2  6FBF     MOVWF usb_rom_len, BANKED
25B4  0E00     MOVLW 0x0
25B6  2015     ADDWFC digit_cnt, W, ACCESS
25B8  6FC0     MOVWF 0xC0, BANKED
345:                               break;
25BA  D095     BRA 0x26E6
346:                           case USB_STRING_DESCRIPTOR_TYPE:
347:                               // TODO: Handle language request. For now return standard language.
348:                               if (packet[USB_bDescriptorIndex] >= usb_num_string_descriptors) {
25BC  CFDE     MOVFF POSTINC2, FSR0L
25BE  FFE9     NOP
25C0  CFDD     MOVFF POSTDEC2, FSR0H
25C2  FFEA     NOP
25C4  0E02     MOVLW 0x2
25C6  26E9     ADDWF FSR0L, F, ACCESS
25C8  0E00     MOVLW 0x0
25CA  22EA     ADDWFC FSR0H, F, ACCESS
25CC  50EF     MOVF INDF0, W, ACCESS
25CE  6E14     MOVWF __tmp_0, ACCESS
25D0  6A15     CLRF digit_cnt, ACCESS
25D2  0100     MOVLB 0x0
25D4  5015     MOVF digit_cnt, W, ACCESS
25D6  196A     XORWF 0x6A, W, BANKED
25D8  AEE8     BTFSS WREG, 7, ACCESS
25DA  D002     BRA 0x25E0
25DC  356A     RLCF 0x6A, W, BANKED
25DE  D004     BRA 0x25E8
25E0  5169     MOVF usb_num_string_descriptors, W, BANKED
25E2  5C14     SUBWF __tmp_0, W, ACCESS
25E4  516A     MOVF 0x6A, W, BANKED
25E6  5815     SUBWFB digit_cnt, W, ACCESS
25E8  E304     BNC 0x25F2
349:                                   flag_usb_RequestError();
25EA  0100     MOVLB 0x0
25EC  0E01     MOVLW 0x1
25EE  6FC1     MOVWF usbrequesterrorflag, BANKED
350:                                   break;
25F0  D07A     BRA 0x26E6
351:                               }
352:                               usb_rom_ptr = usb_string_descriptor;
25F2  C066     MOVFF usb_string_descriptor, usb_rom_ptr
25F4  F0BC     NOP
25F6  C067     MOVFF 0x67, 0xBD
25F8  F0BD     NOP
25FA  C068     MOVFF 0x68, 0xBE
25FC  F0BE     NOP
353:                               usb_rom_len = usb_rom_ptr[0]; // Get BYTE length from descriptor always at byte [0]
25FE  C0BC     MOVFF usb_rom_ptr, TBLPTRL
2600  FFF6     NOP
2602  C0BD     MOVFF 0xBD, TBLPTRH
2604  FFF7     NOP
2606  C0BE     MOVFF 0xBE, TBLPTRU
2608  FFF8     NOP
260A  0008     TBLRD*
260C  50F5     MOVF TABLAT, W, ACCESS
260E  0100     MOVLB 0x0
2610  6FBF     MOVWF usb_rom_len, BANKED
2612  6BC0     CLRF 0xC0, BANKED
354:                               for (i = 0; i < packet[USB_bDescriptorIndex]; i++) { // Implicit linked list traversal until requested configuration
2614  0E02     MOVLW 0x2
2616  6ADB     CLRF PLUSW2, ACCESS
2618  0E03     MOVLW 0x3
261A  6ADB     CLRF PLUSW2, ACCESS
261C  0E02     MOVLW 0x2
261E  CFDB     MOVFF PLUSW2, __tmp_0
2620  F014     NOP
2622  0E03     MOVLW 0x3
2624  CFDB     MOVFF PLUSW2, digit_cnt
2626  F015     NOP
2628  CFDE     MOVFF POSTINC2, FSR0L
262A  FFE9     NOP
262C  CFDD     MOVFF POSTDEC2, FSR0H
262E  FFEA     NOP
2630  0E02     MOVLW 0x2
2632  26E9     ADDWF FSR0L, F, ACCESS
2634  0E00     MOVLW 0x0
2636  22EA     ADDWFC FSR0H, F, ACCESS
2638  50EF     MOVF INDF0, W, ACCESS
263A  0100     MOVLB 0x0
263C  AE15     BTFSS digit_cnt, 7, ACCESS
263E  D002     BRA 0x2644
2640  90D8     BCF STATUS, 0, ACCESS
2642  D003     BRA 0x264A
2644  5C14     SUBWF __tmp_0, W, ACCESS
2646  0E00     MOVLW 0x0
2648  5815     SUBWFB digit_cnt, W, ACCESS
264A  E21F     BC 0x268A
267E  0E02     MOVLW 0x2
2680  2ADB     INCF PLUSW2, F, ACCESS
2682  0E03     MOVLW 0x3
2684  E301     BNC 0x2688
2686  2ADB     INCF PLUSW2, F, ACCESS
2688  D7C9     BRA 0x261C
355:                                   usb_rom_ptr += usb_rom_len;
264C  C0BF     MOVFF usb_rom_len, __tmp_0
264E  F014     NOP
2650  C0C0     MOVFF 0xC0, digit_cnt
2652  F015     NOP
2654  6A16     CLRF prefix_cnt, ACCESS
2656  5014     MOVF __tmp_0, W, ACCESS
2658  0100     MOVLB 0x0
265A  27BC     ADDWF usb_rom_ptr, F, BANKED
265C  5015     MOVF digit_cnt, W, ACCESS
265E  0100     MOVLB 0x0
2660  23BD     ADDWFC 0xBD, F, BANKED
2662  5016     MOVF prefix_cnt, W, ACCESS
2664  0100     MOVLB 0x0
2666  23BE     ADDWFC 0xBE, F, BANKED
356:                                   usb_rom_len = usb_rom_ptr[0];
2668  C0BC     MOVFF usb_rom_ptr, TBLPTRL
266A  FFF6     NOP
266C  C0BD     MOVFF 0xBD, TBLPTRH
266E  FFF7     NOP
2670  C0BE     MOVFF 0xBE, TBLPTRU
2672  FFF8     NOP
2674  0008     TBLRD*
2676  50F5     MOVF TABLAT, W, ACCESS
2678  0100     MOVLB 0x0
267A  6FBF     MOVWF usb_rom_len, BANKED
267C  6BC0     CLRF 0xC0, BANKED
357:                               }
358:                               if ((0 == packet[USB_wLengthHigh] && packet[USB_wLength] < usb_rom_ptr[0]))
268A  CFDE     MOVFF POSTINC2, FSR0L
268C  FFE9     NOP
268E  CFDD     MOVFF POSTDEC2, FSR0H
2690  FFEA     NOP
2692  0E07     MOVLW 0x7
2694  26E9     ADDWF FSR0L, F, ACCESS
2696  0E00     MOVLW 0x0
2698  22EA     ADDWFC FSR0H, F, ACCESS
269A  50EF     MOVF INDF0, W, ACCESS
269C  E120     BNZ 0x26DE
269E  CFDE     MOVFF POSTINC2, FSR0L
26A0  FFE9     NOP
26A2  CFDD     MOVFF POSTDEC2, FSR0H
26A4  FFEA     NOP
26A6  0E06     MOVLW 0x6
26A8  26E9     ADDWF FSR0L, F, ACCESS
26AA  0E00     MOVLW 0x0
26AC  22EA     ADDWFC FSR0H, F, ACCESS
26AE  CFEF     MOVFF INDF0, __tmp_0
26B0  F014     NOP
26B2  C0BC     MOVFF usb_rom_ptr, TBLPTRL
26B4  FFF6     NOP
26B6  C0BD     MOVFF 0xBD, TBLPTRH
26B8  FFF7     NOP
26BA  C0BE     MOVFF 0xBE, TBLPTRU
26BC  FFF8     NOP
26BE  0008     TBLRD*
26C0  50F5     MOVF TABLAT, W, ACCESS
26C2  5C14     SUBWF __tmp_0, W, ACCESS
26C4  E20C     BC 0x26DE
359:                                   usb_rom_len = packet[USB_wLength];
26C6  CFDE     MOVFF POSTINC2, FSR0L
26C8  FFE9     NOP
26CA  CFDD     MOVFF POSTDEC2, FSR0H
26CC  FFEA     NOP
26CE  0E06     MOVLW 0x6
26D0  26E9     ADDWF FSR0L, F, ACCESS
26D2  0E00     MOVLW 0x0
26D4  22EA     ADDWFC FSR0H, F, ACCESS
26D6  50EF     MOVF INDF0, W, ACCESS
26D8  0100     MOVLB 0x0
26DA  6FBF     MOVWF usb_rom_len, BANKED
26DC  6BC0     CLRF 0xC0, BANKED
360:                               break;
26DE  D003     BRA 0x26E6
361:                           case USB_INTERFACE_DESCRIPTOR_TYPE:
362:                           case USB_ENDPOINT_DESCRIPTOR_TYPE:
363:                           default:
364:                               flag_usb_RequestError();
26E0  0100     MOVLB 0x0
26E2  0E01     MOVLW 0x1
26E4  6FC1     MOVWF usbrequesterrorflag, BANKED
365:                       }
366:                       if (0 == usbrequesterrorflag) {
26E6  0100     MOVLB 0x0
26E8  51C1     MOVF usbrequesterrorflag, W, BANKED
26EA  E10E     BNZ 0x2708
367:                           usb_send_rom(); // Send first part of packet right away, the rest is handled by the EP0 IN handler.
26EC  DB65     RCALL usb_send_rom
368:                           usb_set_in_handler(0, usb_send_rom);
26EE  0EB8     MOVLW 0xB8
26F0  6EE6     MOVWF POSTINC1, ACCESS
26F2  0E2D     MOVLW 0x2D
26F4  6EE6     MOVWF POSTINC1, ACCESS
26F6  0E00     MOVLW 0x0
26F8  6EE6     MOVWF POSTINC1, ACCESS
26FA  6AE6     CLRF POSTINC1, ACCESS
26FC  DAD9     RCALL usb_set_in_handler
26FE  52E5     MOVF POSTDEC1, F, ACCESS
2700  52E5     MOVF POSTDEC1, F, ACCESS
2702  52E5     MOVF POSTDEC1, F, ACCESS
2704  52E5     MOVF POSTDEC1, F, ACCESS
369:                       } else {
2706  D001     BRA 0x270A
370:                           usb_RequestError();
2708  DB33     RCALL usb_RequestError
371:                       }
372:           
373:                       break;
270A  D045     BRA 0x2796
374:                   case USB_REQUEST_GET_CONFIGURATION:
375:                       EP0_Inbdp->BDADDR[0] = usb_current_cfg;
270C  C0BA     MOVFF EP0_Inbdp, FSR0L
270E  FFE9     NOP
2710  C0BB     MOVFF 0xBB, FSR0H
2712  FFEA     NOP
2714  0E02     MOVLW 0x2
2716  26E9     ADDWF FSR0L, F, ACCESS
2718  0E00     MOVLW 0x0
271A  22EA     ADDWFC FSR0H, F, ACCESS
271C  50EE     MOVF POSTINC0, W, ACCESS
271E  CFEF     MOVFF INDF0, FSR0H
2720  FFEA     NOP
2722  6EE9     MOVWF FSR0L, ACCESS
2724  C0B3     MOVFF usb_current_cfg, INDF0
2726  FFEF     NOP
376:                       usb_ack_dat1(1);
2728  0E01     MOVLW 0x1
272A  6EE6     MOVWF POSTINC1, ACCESS
272C  6AE6     CLRF POSTINC1, ACCESS
272E  DB00     RCALL usb_ack_dat1
2730  52E5     MOVF POSTDEC1, F, ACCESS
2732  52E5     MOVF POSTDEC1, F, ACCESS
377:                       break;
2734  D030     BRA 0x2796
378:           
379:                   case USB_REQUEST_SET_CONFIGURATION:
380:                       if (USB_NUM_CONFIGURATIONS >= packet[USB_wValue]) {
2736  0E01     MOVLW 0x1
2738  6E14     MOVWF __tmp_0, ACCESS
273A  CFDE     MOVFF POSTINC2, FSR0L
273C  FFE9     NOP
273E  CFDD     MOVFF POSTDEC2, FSR0H
2740  FFEA     NOP
2742  0E02     MOVLW 0x2
2744  26E9     ADDWF FSR0L, F, ACCESS
2746  0E00     MOVLW 0x0
2748  22EA     ADDWFC FSR0H, F, ACCESS
274A  50EF     MOVF INDF0, W, ACCESS
274C  5C14     SUBWF __tmp_0, W, ACCESS
274E  E320     BNC 0x2790
381:                           // TODO: Support multiple configurations
382:                           /* Configure endpoints (USB_UEPn - registers) */
383:                           usb_current_cfg = packet[USB_wValue];
2750  CFDE     MOVFF POSTINC2, FSR0L
2752  FFE9     NOP
2754  CFDD     MOVFF POSTDEC2, FSR0H
2756  FFEA     NOP
2758  0E02     MOVLW 0x2
275A  26E9     ADDWF FSR0L, F, ACCESS
275C  0E00     MOVLW 0x0
275E  22EA     ADDWFC FSR0H, F, ACCESS
2760  50EF     MOVF INDF0, W, ACCESS
2762  0100     MOVLB 0x0
2764  6FB3     MOVWF usb_current_cfg, BANKED
2766  6BB4     CLRF 0xB4, BANKED
384:                           if (usb_current_cfg != 0) {
2768  0100     MOVLB 0x0
276A  51B3     MOVF usb_current_cfg, W, BANKED
276C  11B4     IORWF 0xB4, W, BANKED
276E  E006     BZ 0x277C
385:           
386:                               // JTR user_configured_init major addition. This is a CALLBACK to the USER when the device is enumerated.
387:                               // This is when we setup non EP0 endpoints.
388:                               // TODO: This really could be a function pointer
389:           
390:                               usb_device_state = CONFIGURED_STATE;
2770  0100     MOVLB 0x0
2772  0E20     MOVLW 0x20
2774  6FB5     MOVWF usb_device_state, BANKED
391:                               user_configured_init();
2776  ECBA     CALL 0x3B74, 0
2778  F01D     NOP
392:                           } else {
277A  D003     BRA 0x2782
393:                               usb_device_state = ADDRESS_STATE;
277C  0100     MOVLB 0x0
277E  0E10     MOVLW 0x10
2780  6FB5     MOVWF usb_device_state, BANKED
394:                           }
395:           
396:                           usb_ack_dat1(0);
2782  0E00     MOVLW 0x0
2784  6EE6     MOVWF POSTINC1, ACCESS
2786  6AE6     CLRF POSTINC1, ACCESS
2788  DAD3     RCALL usb_ack_dat1
278A  52E5     MOVF POSTDEC1, F, ACCESS
278C  52E5     MOVF POSTDEC1, F, ACCESS
397:           
398:                       } else
278E  D001     BRA 0x2792
399:                           usb_RequestError();
2790  DAEF     RCALL usb_RequestError
400:                       break;
2792  D001     BRA 0x2796
401:           
402:                   case USB_REQUEST_SET_DESCRIPTOR:
403:                   default:
404:                       usb_RequestError();
2794  DAED     RCALL usb_RequestError
405:               }
406:           }
2796  0E04     MOVLW 0x4
2798  5CE1     SUBWF FSR1L, W, ACCESS
279A  E202     BC 0x27A0
279C  6AE1     CLRF FSR1L, ACCESS
279E  52E5     MOVF POSTDEC1, F, ACCESS
27A0  6EE1     MOVWF FSR1L, ACCESS
27A2  52E5     MOVF POSTDEC1, F, ACCESS
27A4  CFE7     MOVFF INDF1, FSR2L
27A6  FFD9     NOP
27A8  0012     RETURN 0
407:           
408:           void usb_handle_StandardInterfaceRequest(BDentry *bdp) {
27AA  CFD9     MOVFF FSR2L, POSTINC1
27AC  FFE6     NOP
27AE  CFE1     MOVFF FSR1L, FSR2L
27B0  FFD9     NOP
27B2  0E02     MOVLW 0x2
27B4  26E1     ADDWF FSR1L, F, ACCESS
409:               BYTE *packet = bdp->BDADDR;
27B6  0EFD     MOVLW 0xFD
27B8  CFDB     MOVFF PLUSW2, FSR0L
27BA  FFE9     NOP
27BC  0EFE     MOVLW 0xFE
27BE  CFDB     MOVFF PLUSW2, FSR0H
27C0  FFEA     NOP
27C2  0E02     MOVLW 0x2
27C4  26E9     ADDWF FSR0L, F, ACCESS
27C6  0E00     MOVLW 0x0
27C8  22EA     ADDWFC FSR0H, F, ACCESS
27CA  CFEE     MOVFF POSTINC0, POSTINC2
27CC  FFDE     NOP
27CE  CFED     MOVFF POSTDEC0, POSTDEC2
27D0  FFDD     NOP
410:           
411:               switch (packet[USB_bRequest]) {
27D2  CFDE     MOVFF POSTINC2, FSR0L
27D4  FFE9     NOP
27D6  CFDD     MOVFF POSTDEC2, FSR0H
27D8  FFEA     NOP
27DA  0E01     MOVLW 0x1
27DC  26E9     ADDWF FSR0L, F, ACCESS
27DE  0E00     MOVLW 0x0
27E0  22EA     ADDWFC FSR0H, F, ACCESS
27E2  50EF     MOVF INDF0, W, ACCESS
27E4  0A01     XORLW 0x1
27E6  E073     BZ 0x28CE
27E8  0A02     XORLW 0x2
27EA  E071     BZ 0x28CE
27EC  0A08     XORLW 0x8
27EE  E04E     BZ 0x288C
27F0  0A01     XORLW 0x1
27F2  E028     BZ 0x2844
27F4  0A0A     XORLW 0xA
27F6  E001     BZ 0x27FA
27F8  D06A     BRA 0x28CE
412:                   case USB_REQUEST_GET_STATUS:
413:                       EP0_Inbdp->BDADDR[0] = 0x00;
27FA  C0BA     MOVFF EP0_Inbdp, FSR0L
27FC  FFE9     NOP
27FE  C0BB     MOVFF 0xBB, FSR0H
2800  FFEA     NOP
2802  0E02     MOVLW 0x2
2804  26E9     ADDWF FSR0L, F, ACCESS
2806  0E00     MOVLW 0x0
2808  22EA     ADDWFC FSR0H, F, ACCESS
280A  50EE     MOVF POSTINC0, W, ACCESS
280C  CFEF     MOVFF INDF0, FSR0H
280E  FFEA     NOP
2810  6EE9     MOVWF FSR0L, ACCESS
2812  6AEF     CLRF INDF0, ACCESS
414:                       EP0_Inbdp->BDADDR[1] = 0x00;
2814  C0BA     MOVFF EP0_Inbdp, FSR0L
2816  FFE9     NOP
2818  C0BB     MOVFF 0xBB, FSR0H
281A  FFEA     NOP
281C  0E02     MOVLW 0x2
281E  26E9     ADDWF FSR0L, F, ACCESS
2820  0E00     MOVLW 0x0
2822  22EA     ADDWFC FSR0H, F, ACCESS
2824  50EE     MOVF POSTINC0, W, ACCESS
2826  CFEF     MOVFF INDF0, FSR0H
2828  FFEA     NOP
282A  6EE9     MOVWF FSR0L, ACCESS
282C  0E01     MOVLW 0x1
282E  26E9     ADDWF FSR0L, F, ACCESS
2830  0E00     MOVLW 0x0
2832  22EA     ADDWFC FSR0H, F, ACCESS
2834  6AEF     CLRF INDF0, ACCESS
415:                       usb_ack_dat1(2);
2836  0E02     MOVLW 0x2
2838  6EE6     MOVWF POSTINC1, ACCESS
283A  6AE6     CLRF POSTINC1, ACCESS
283C  DA79     RCALL usb_ack_dat1
283E  52E5     MOVF POSTDEC1, F, ACCESS
2840  52E5     MOVF POSTDEC1, F, ACCESS
416:                       break;
2842  D046     BRA 0x28D0
417:                   case USB_REQUEST_GET_INTERFACE:
418:                       if (USB_NUM_INTERFACES > packet[USB_bInterface]) {
2844  0E02     MOVLW 0x2
2846  6E14     MOVWF __tmp_0, ACCESS
2848  CFDE     MOVFF POSTINC2, FSR0L
284A  FFE9     NOP
284C  CFDD     MOVFF POSTDEC2, FSR0H
284E  FFEA     NOP
2850  0E04     MOVLW 0x4
2852  26E9     ADDWF FSR0L, F, ACCESS
2854  0E00     MOVLW 0x0
2856  22EA     ADDWFC FSR0H, F, ACCESS
2858  50EF     MOVF INDF0, W, ACCESS
285A  80D8     BSF STATUS, 0, ACCESS
285C  5414     SUBFWB __tmp_0, W, ACCESS
285E  E214     BC 0x2888
419:                           // TODO: Implement alternative interfaces, or move responsibility to class/vendor functions.
420:                           EP0_Inbdp->BDADDR[0] = 0;
2860  C0BA     MOVFF EP0_Inbdp, FSR0L
2862  FFE9     NOP
2864  C0BB     MOVFF 0xBB, FSR0H
2866  FFEA     NOP
2868  0E02     MOVLW 0x2
286A  26E9     ADDWF FSR0L, F, ACCESS
286C  0E00     MOVLW 0x0
286E  22EA     ADDWFC FSR0H, F, ACCESS
2870  50EE     MOVF POSTINC0, W, ACCESS
2872  CFEF     MOVFF INDF0, FSR0H
2874  FFEA     NOP
2876  6EE9     MOVWF FSR0L, ACCESS
2878  6AEF     CLRF INDF0, ACCESS
421:                           usb_ack_dat1(1);
287A  0E01     MOVLW 0x1
287C  6EE6     MOVWF POSTINC1, ACCESS
287E  6AE6     CLRF POSTINC1, ACCESS
2880  DA57     RCALL usb_ack_dat1
2882  52E5     MOVF POSTDEC1, F, ACCESS
2884  52E5     MOVF POSTDEC1, F, ACCESS
422:                       } else
2886  D001     BRA 0x288A
423:                           usb_RequestError();
2888  DA73     RCALL usb_RequestError
424:                       break;
288A  D022     BRA 0x28D0
425:                   case USB_REQUEST_SET_INTERFACE:
426:                       if (USB_NUM_INTERFACES > packet[USB_bInterface] && 0u == packet[USB_wValue]) {
288C  0E02     MOVLW 0x2
288E  6E14     MOVWF __tmp_0, ACCESS
2890  CFDE     MOVFF POSTINC2, FSR0L
2892  FFE9     NOP
2894  CFDD     MOVFF POSTDEC2, FSR0H
2896  FFEA     NOP
2898  0E04     MOVLW 0x4
289A  26E9     ADDWF FSR0L, F, ACCESS
289C  0E00     MOVLW 0x0
289E  22EA     ADDWFC FSR0H, F, ACCESS
28A0  50EF     MOVF INDF0, W, ACCESS
28A2  80D8     BSF STATUS, 0, ACCESS
28A4  5414     SUBFWB __tmp_0, W, ACCESS
28A6  E211     BC 0x28CA
28A8  CFDE     MOVFF POSTINC2, FSR0L
28AA  FFE9     NOP
28AC  CFDD     MOVFF POSTDEC2, FSR0H
28AE  FFEA     NOP
28B0  0E02     MOVLW 0x2
28B2  26E9     ADDWF FSR0L, F, ACCESS
28B4  0E00     MOVLW 0x0
28B6  22EA     ADDWFC FSR0H, F, ACCESS
28B8  50EF     MOVF INDF0, W, ACCESS
28BA  E107     BNZ 0x28CA
427:                           // TODO: Implement alternative interfaces...
428:                           usb_ack_dat1(0);
28BC  0E00     MOVLW 0x0
28BE  6EE6     MOVWF POSTINC1, ACCESS
28C0  6AE6     CLRF POSTINC1, ACCESS
28C2  DA36     RCALL usb_ack_dat1
28C4  52E5     MOVF POSTDEC1, F, ACCESS
28C6  52E5     MOVF POSTDEC1, F, ACCESS
429:                       } else
28C8  D001     BRA 0x28CC
430:                           usb_RequestError();
28CA  DA52     RCALL usb_RequestError
431:                       break;
28CC  D001     BRA 0x28D0
432:                   case USB_REQUEST_CLEAR_FEATURE: // JTR N/A for interface
433:                   case USB_REQUEST_SET_FEATURE: // This is correct and finished code.
434:                   default:
435:                       usb_RequestError();
28CE  DA50     RCALL usb_RequestError
436:               }
437:           }
28D0  0E02     MOVLW 0x2
28D2  5CE1     SUBWF FSR1L, W, ACCESS
28D4  E202     BC 0x28DA
28D6  6AE1     CLRF FSR1L, ACCESS
28D8  52E5     MOVF POSTDEC1, F, ACCESS
28DA  6EE1     MOVWF FSR1L, ACCESS
28DC  52E5     MOVF POSTDEC1, F, ACCESS
28DE  CFE7     MOVFF INDF1, FSR2L
28E0  FFD9     NOP
28E2  0012     RETURN 0
438:           
439:           void usb_handle_StandardEndpointRequest(BDentry *bdp) {
28E4  CFD9     MOVFF FSR2L, POSTINC1
28E6  FFE6     NOP
28E8  CFE1     MOVFF FSR1L, FSR2L
28EA  FFD9     NOP
28EC  0E08     MOVLW 0x8
28EE  26E1     ADDWF FSR1L, F, ACCESS
440:               BYTE *packet;
441:               BYTE epnum;
442:               BYTE dir;
443:               BDentry *epbd;
444:               usb_uep_t *pUEP;
445:           
446:               packet = bdp->BDADDR;
28F0  0EFD     MOVLW 0xFD
28F2  CFDB     MOVFF PLUSW2, FSR0L
28F4  FFE9     NOP
28F6  0EFE     MOVLW 0xFE
28F8  CFDB     MOVFF PLUSW2, FSR0H
28FA  FFEA     NOP
28FC  0E02     MOVLW 0x2
28FE  26E9     ADDWF FSR0L, F, ACCESS
2900  0E00     MOVLW 0x0
2902  22EA     ADDWFC FSR0H, F, ACCESS
2904  CFEE     MOVFF POSTINC0, POSTINC2
2906  FFDE     NOP
2908  CFED     MOVFF POSTDEC0, POSTDEC2
290A  FFDD     NOP
447:           
448:               switch (packet[USB_bRequest]) {
290C  CFDE     MOVFF POSTINC2, FSR0L
290E  FFE9     NOP
2910  CFDD     MOVFF POSTDEC2, FSR0H
2912  FFEA     NOP
2914  0E01     MOVLW 0x1
2916  26E9     ADDWF FSR0L, F, ACCESS
2918  0E00     MOVLW 0x0
291A  22EA     ADDWFC FSR0H, F, ACCESS
291C  50EF     MOVF INDF0, W, ACCESS
291E  0A0C     XORLW 0xC
2920  E101     BNZ 0x2924
2922  D12D     BRA 0x2B7E
2924  0A0F     XORLW 0xF
2926  E101     BNZ 0x292A
2928  D0E8     BRA 0x2AFA
292A  0A02     XORLW 0x2
292C  E073     BZ 0x2A14
292E  0A01     XORLW 0x1
2930  E001     BZ 0x2934
2932  D125     BRA 0x2B7E
449:                   case USB_REQUEST_GET_STATUS:
450:                       EP0_Inbdp->BDADDR[0] = 0x00; // Assume no stall
2934  C0BA     MOVFF EP0_Inbdp, FSR0L
2936  FFE9     NOP
2938  C0BB     MOVFF 0xBB, FSR0H
293A  FFEA     NOP
293C  0E02     MOVLW 0x2
293E  26E9     ADDWF FSR0L, F, ACCESS
2940  0E00     MOVLW 0x0
2942  22EA     ADDWFC FSR0H, F, ACCESS
2944  50EE     MOVF POSTINC0, W, ACCESS
2946  CFEF     MOVFF INDF0, FSR0H
2948  FFEA     NOP
294A  6EE9     MOVWF FSR0L, ACCESS
294C  6AEF     CLRF INDF0, ACCESS
451:                       EP0_Inbdp->BDADDR[1] = 0x00; // Same for stall or not
294E  C0BA     MOVFF EP0_Inbdp, FSR0L
2950  FFE9     NOP
2952  C0BB     MOVFF 0xBB, FSR0H
2954  FFEA     NOP
2956  0E02     MOVLW 0x2
2958  26E9     ADDWF FSR0L, F, ACCESS
295A  0E00     MOVLW 0x0
295C  22EA     ADDWFC FSR0H, F, ACCESS
295E  50EE     MOVF POSTINC0, W, ACCESS
2960  CFEF     MOVFF INDF0, FSR0H
2962  FFEA     NOP
2964  6EE9     MOVWF FSR0L, ACCESS
2966  0E01     MOVLW 0x1
2968  26E9     ADDWF FSR0L, F, ACCESS
296A  0E00     MOVLW 0x0
296C  22EA     ADDWFC FSR0H, F, ACCESS
296E  6AEF     CLRF INDF0, ACCESS
452:                       epnum = packet[USB_wIndex] & 0x0F;
2970  CFDE     MOVFF POSTINC2, FSR0L
2972  FFE9     NOP
2974  CFDD     MOVFF POSTDEC2, FSR0H
2976  FFEA     NOP
2978  0E04     MOVLW 0x4
297A  26E9     ADDWF FSR0L, F, ACCESS
297C  0E00     MOVLW 0x0
297E  22EA     ADDWFC FSR0H, F, ACCESS
2980  50EF     MOVF INDF0, W, ACCESS
2982  0B0F     ANDLW 0xF
2984  6EE7     MOVWF INDF1, ACCESS
2986  0E02     MOVLW 0x2
2988  CFE7     MOVFF INDF1, PLUSW2
298A  FFDB     NOP
453:                       dir = packet[USB_wIndex] >> 7;
298C  CFDE     MOVFF POSTINC2, FSR0L
298E  FFE9     NOP
2990  CFDD     MOVFF POSTDEC2, FSR0H
2992  FFEA     NOP
2994  0E04     MOVLW 0x4
2996  26E9     ADDWF FSR0L, F, ACCESS
2998  0E00     MOVLW 0x0
299A  22EA     ADDWFC FSR0H, F, ACCESS
299C  50EF     MOVF INDF0, W, ACCESS
299E  44E8     RLNCF WREG, W, ACCESS
29A0  0B01     ANDLW 0x1
29A2  6EE7     MOVWF INDF1, ACCESS
29A4  0E03     MOVLW 0x3
29A6  CFE7     MOVFF INDF1, PLUSW2
29A8  FFDB     NOP
454:                       epbd = &usb_bdt[USB_CALC_BD(epnum, dir, USB_PP_EVEN)];
29AA  0E03     MOVLW 0x3
29AC  CFDB     MOVFF PLUSW2, POSTINC1
29AE  FFE6     NOP
29B0  0E02     MOVLW 0x2
29B2  50DB     MOVF PLUSW2, W, ACCESS
29B4  24E8     ADDWF WREG, W, ACCESS
29B6  52E5     MOVF POSTDEC1, F, ACCESS
29B8  24E7     ADDWF INDF1, W, ACCESS
29BA  0D04     MULLW 0x4
29BC  CFF3     MOVFF PRODL, __tmp_0
29BE  F014     NOP
29C0  CFF4     MOVFF PRODH, digit_cnt
29C2  F015     NOP
29C4  0E00     MOVLW 0x0
29C6  2614     ADDWF __tmp_0, F, ACCESS
29C8  0E04     MOVLW 0x4
29CA  2215     ADDWFC digit_cnt, F, ACCESS
29CC  0E04     MOVLW 0x4
29CE  C014     MOVFF __tmp_0, PLUSW2
29D0  FFDB     NOP
29D2  0E05     MOVLW 0x5
29D4  C015     MOVFF digit_cnt, PLUSW2
29D6  FFDB     NOP
455:                       if (epbd->BDSTAT &= ~BSTALL)
29D8  0E04     MOVLW 0x4
29DA  CFDB     MOVFF PLUSW2, FSR0L
29DC  FFE9     NOP
29DE  0E05     MOVLW 0x5
29E0  CFDB     MOVFF PLUSW2, FSR0H
29E2  FFEA     NOP
29E4  94EF     BCF INDF0, 2, ACCESS
29E6  50EF     MOVF INDF0, W, ACCESS
29E8  E00E     BZ 0x2A06
456:                           EP0_Inbdp->BDADDR[0] = 0x01; // EVEN BD is stall flag set?
29EA  C0BA     MOVFF EP0_Inbdp, FSR0L
29EC  FFE9     NOP
29EE  C0BB     MOVFF 0xBB, FSR0H
29F0  FFEA     NOP
29F2  0E02     MOVLW 0x2
29F4  26E9     ADDWF FSR0L, F, ACCESS
29F6  0E00     MOVLW 0x0
29F8  22EA     ADDWFC FSR0H, F, ACCESS
29FA  50EE     MOVF POSTINC0, W, ACCESS
29FC  CFEF     MOVFF INDF0, FSR0H
29FE  FFEA     NOP
2A00  6EE9     MOVWF FSR0L, ACCESS
2A02  0E01     MOVLW 0x1
2A04  6EEF     MOVWF INDF0, ACCESS
457:                       //epbd = &usb_bdt[USB_CALC_BD(epnum, dir, USB_PP_ODD)];
458:                       //if (epbd->BDSTAT &= ~BSTALL)
459:                       //    rbdp->BDADDR[0] = 0x01; // ODD BD is stall flag set?
460:                       usb_ack_dat1(2);
2A06  0E02     MOVLW 0x2
2A08  6EE6     MOVWF POSTINC1, ACCESS
2A0A  6AE6     CLRF POSTINC1, ACCESS
2A0C  D991     RCALL usb_ack_dat1
2A0E  52E5     MOVF POSTDEC1, F, ACCESS
2A10  52E5     MOVF POSTDEC1, F, ACCESS
461:                       break;
2A12  D0B6     BRA 0x2B80
462:           
463:                   case USB_REQUEST_CLEAR_FEATURE:
464:                       // As this is really is an application event and there
465:                       // should be a call back and protocol for handling the
466:                       // possible lost of a data packet.
467:                       // TODO: ping-ping support.
468:           
469:                       epnum = packet[USB_wIndex] & 0x0F; // JTR Added V0.2 after microchip stuff up with their documentation.
2A14  CFDE     MOVFF POSTINC2, FSR0L
2A16  FFE9     NOP
2A18  CFDD     MOVFF POSTDEC2, FSR0H
2A1A  FFEA     NOP
2A1C  0E04     MOVLW 0x4
2A1E  26E9     ADDWF FSR0L, F, ACCESS
2A20  0E00     MOVLW 0x0
2A22  22EA     ADDWFC FSR0H, F, ACCESS
2A24  50EF     MOVF INDF0, W, ACCESS
2A26  0B0F     ANDLW 0xF
2A28  6EE7     MOVWF INDF1, ACCESS
2A2A  0E02     MOVLW 0x2
2A2C  CFE7     MOVFF INDF1, PLUSW2
2A2E  FFDB     NOP
470:                       pUEP = USB_UEP;
2A30  50D9     MOVF FSR2L, W, ACCESS
2A32  0F06     ADDLW 0x6
2A34  6EE9     MOVWF FSR0L, ACCESS
2A36  CFDA     MOVFF FSR2H, FSR0H
2A38  FFEA     NOP
2A3A  0E70     MOVLW 0x70
2A3C  6EEE     MOVWF POSTINC0, ACCESS
2A3E  0E0F     MOVLW 0xF
2A40  6EED     MOVWF POSTDEC0, ACCESS
471:                       pUEP += epnum;
2A42  0E02     MOVLW 0x2
2A44  50DB     MOVF PLUSW2, W, ACCESS
2A46  6E14     MOVWF __tmp_0, ACCESS
2A48  6A15     CLRF digit_cnt, ACCESS
2A4A  50D9     MOVF FSR2L, W, ACCESS
2A4C  0F06     ADDLW 0x6
2A4E  6EE9     MOVWF FSR0L, ACCESS
2A50  CFDA     MOVFF FSR2H, FSR0H
2A52  FFEA     NOP
2A54  5014     MOVF __tmp_0, W, ACCESS
2A56  26EE     ADDWF POSTINC0, F, ACCESS
2A58  5015     MOVF digit_cnt, W, ACCESS
2A5A  22ED     ADDWFC POSTDEC0, F, ACCESS
472:                       *pUEP &= ~USB_UEP_EPSTALL;
2A5C  0E06     MOVLW 0x6
2A5E  CFDB     MOVFF PLUSW2, FSR0L
2A60  FFE9     NOP
2A62  0E07     MOVLW 0x7
2A64  CFDB     MOVFF PLUSW2, FSR0H
2A66  FFEA     NOP
2A68  90EF     BCF INDF0, 0, ACCESS
473:           
474:                       dir = packet[USB_wIndex] >> 7;
2A6A  CFDE     MOVFF POSTINC2, FSR0L
2A6C  FFE9     NOP
2A6E  CFDD     MOVFF POSTDEC2, FSR0H
2A70  FFEA     NOP
2A72  0E04     MOVLW 0x4
2A74  26E9     ADDWF FSR0L, F, ACCESS
2A76  0E00     MOVLW 0x0
2A78  22EA     ADDWFC FSR0H, F, ACCESS
2A7A  50EF     MOVF INDF0, W, ACCESS
2A7C  44E8     RLNCF WREG, W, ACCESS
2A7E  0B01     ANDLW 0x1
2A80  6EE7     MOVWF INDF1, ACCESS
2A82  0E03     MOVLW 0x3
2A84  CFE7     MOVFF INDF1, PLUSW2
2A86  FFDB     NOP
475:                       epbd = &usb_bdt[USB_CALC_BD(epnum, dir, USB_PP_EVEN)];
2A88  0E03     MOVLW 0x3
2A8A  CFDB     MOVFF PLUSW2, POSTINC1
2A8C  FFE6     NOP
2A8E  0E02     MOVLW 0x2
2A90  50DB     MOVF PLUSW2, W, ACCESS
2A92  24E8     ADDWF WREG, W, ACCESS
2A94  52E5     MOVF POSTDEC1, F, ACCESS
2A96  24E7     ADDWF INDF1, W, ACCESS
2A98  0D04     MULLW 0x4
2A9A  CFF3     MOVFF PRODL, __tmp_0
2A9C  F014     NOP
2A9E  CFF4     MOVFF PRODH, digit_cnt
2AA0  F015     NOP
2AA2  0E00     MOVLW 0x0
2AA4  2614     ADDWF __tmp_0, F, ACCESS
2AA6  0E04     MOVLW 0x4
2AA8  2215     ADDWFC digit_cnt, F, ACCESS
2AAA  0E04     MOVLW 0x4
2AAC  C014     MOVFF __tmp_0, PLUSW2
2AAE  FFDB     NOP
2AB0  0E05     MOVLW 0x5
2AB2  C015     MOVFF digit_cnt, PLUSW2
2AB4  FFDB     NOP
476:                       epbd->BDSTAT &= ~BSTALL;
2AB6  0E04     MOVLW 0x4
2AB8  CFDB     MOVFF PLUSW2, FSR0L
2ABA  FFE9     NOP
2ABC  0E05     MOVLW 0x5
2ABE  CFDB     MOVFF PLUSW2, FSR0H
2AC0  FFEA     NOP
2AC2  94EF     BCF INDF0, 2, ACCESS
477:                       if (dir) epbd->BDSTAT |= DTS; // JTR added IN EP set DTS as it will be toggled to zero next transfer
2AC4  0E03     MOVLW 0x3
2AC6  50DB     MOVF PLUSW2, W, ACCESS
2AC8  E007     BZ 0x2AD8
2ACA  0E04     MOVLW 0x4
2ACC  CFDB     MOVFF PLUSW2, FSR0L
2ACE  FFE9     NOP
2AD0  0E05     MOVLW 0x5
2AD2  CFDB     MOVFF PLUSW2, FSR0H
2AD4  FFEA     NOP
2AD6  8CEF     BSF INDF0, 6, ACCESS
478:                       if (0 == dir) epbd->BDSTAT &= ~DTS; // JTR added
2AD8  0E03     MOVLW 0x3
2ADA  50DB     MOVF PLUSW2, W, ACCESS
2ADC  E107     BNZ 0x2AEC
2ADE  0E04     MOVLW 0x4
2AE0  CFDB     MOVFF PLUSW2, FSR0L
2AE2  FFE9     NOP
2AE4  0E05     MOVLW 0x5
2AE6  CFDB     MOVFF PLUSW2, FSR0H
2AE8  FFEA     NOP
2AEA  9CEF     BCF INDF0, 6, ACCESS
479:           
480:                       // JTR this pointless ATM. If ping-pong is enabled then you need to track PPBI
481:                       // and set up ODD and EVEN BDs in respect to this. See complicated system in
482:                       // microchip stack >= 2.8
483:           
484:                       //		epbd = &usb_bdt[USB_CALC_BD(epnum, dir, USB_PP_ODD)];
485:                       //		epbd->BDSTAT &= ~BSTALL;
486:                       //		if (dir) epbd->BDSTAT |= DTS;		// JTR added
487:                       //		if (0 == dir) epbd->BDSTAT &= ~DTS;	// JTR added
488:           
489:           
490:                       usb_ack_dat1(0);
2AEC  0E00     MOVLW 0x0
2AEE  6EE6     MOVWF POSTINC1, ACCESS
2AF0  6AE6     CLRF POSTINC1, ACCESS
2AF2  D91E     RCALL usb_ack_dat1
2AF4  52E5     MOVF POSTDEC1, F, ACCESS
2AF6  52E5     MOVF POSTDEC1, F, ACCESS
491:                       break;
2AF8  D043     BRA 0x2B80
492:           
493:           
494:                   case USB_REQUEST_SET_FEATURE:
495:                       epnum = packet[USB_wIndex] & 0x0F;
2AFA  CFDE     MOVFF POSTINC2, FSR0L
2AFC  FFE9     NOP
2AFE  CFDD     MOVFF POSTDEC2, FSR0H
2B00  FFEA     NOP
2B02  0E04     MOVLW 0x4
2B04  26E9     ADDWF FSR0L, F, ACCESS
2B06  0E00     MOVLW 0x0
2B08  22EA     ADDWFC FSR0H, F, ACCESS
2B0A  50EF     MOVF INDF0, W, ACCESS
2B0C  0B0F     ANDLW 0xF
2B0E  6EE7     MOVWF INDF1, ACCESS
2B10  0E02     MOVLW 0x2
2B12  CFE7     MOVFF INDF1, PLUSW2
2B14  FFDB     NOP
496:                       dir = packet[USB_wIndex] >> 7;
2B16  CFDE     MOVFF POSTINC2, FSR0L
2B18  FFE9     NOP
2B1A  CFDD     MOVFF POSTDEC2, FSR0H
2B1C  FFEA     NOP
2B1E  0E04     MOVLW 0x4
2B20  26E9     ADDWF FSR0L, F, ACCESS
2B22  0E00     MOVLW 0x0
2B24  22EA     ADDWFC FSR0H, F, ACCESS
2B26  50EF     MOVF INDF0, W, ACCESS
2B28  44E8     RLNCF WREG, W, ACCESS
2B2A  0B01     ANDLW 0x1
2B2C  6EE7     MOVWF INDF1, ACCESS
2B2E  0E03     MOVLW 0x3
2B30  CFE7     MOVFF INDF1, PLUSW2
2B32  FFDB     NOP
497:                       epbd = &usb_bdt[USB_CALC_BD(epnum, dir, USB_PP_EVEN)];
2B34  0E03     MOVLW 0x3
2B36  CFDB     MOVFF PLUSW2, POSTINC1
2B38  FFE6     NOP
2B3A  0E02     MOVLW 0x2
2B3C  50DB     MOVF PLUSW2, W, ACCESS
2B3E  24E8     ADDWF WREG, W, ACCESS
2B40  52E5     MOVF POSTDEC1, F, ACCESS
2B42  24E7     ADDWF INDF1, W, ACCESS
2B44  0D04     MULLW 0x4
2B46  CFF3     MOVFF PRODL, __tmp_0
2B48  F014     NOP
2B4A  CFF4     MOVFF PRODH, digit_cnt
2B4C  F015     NOP
2B4E  0E00     MOVLW 0x0
2B50  2614     ADDWF __tmp_0, F, ACCESS
2B52  0E04     MOVLW 0x4
2B54  2215     ADDWFC digit_cnt, F, ACCESS
2B56  0E04     MOVLW 0x4
2B58  C014     MOVFF __tmp_0, PLUSW2
2B5A  FFDB     NOP
2B5C  0E05     MOVLW 0x5
2B5E  C015     MOVFF digit_cnt, PLUSW2
2B60  FFDB     NOP
498:                       epbd->BDSTAT |= BSTALL;
2B62  0E04     MOVLW 0x4
2B64  CFDB     MOVFF PLUSW2, FSR0L
2B66  FFE9     NOP
2B68  0E05     MOVLW 0x5
2B6A  CFDB     MOVFF PLUSW2, FSR0H
2B6C  FFEA     NOP
2B6E  84EF     BSF INDF0, 2, ACCESS
499:                       //epbd = &usb_bdt[USB_CALC_BD(epnum, dir, USB_PP_ODD)];
500:                       //epbd->BDSTAT |= BSTALL;
501:                       usb_ack_dat1(0);
2B70  0E00     MOVLW 0x0
2B72  6EE6     MOVWF POSTINC1, ACCESS
2B74  6AE6     CLRF POSTINC1, ACCESS
2B76  D8DC     RCALL usb_ack_dat1
2B78  52E5     MOVF POSTDEC1, F, ACCESS
2B7A  52E5     MOVF POSTDEC1, F, ACCESS
502:                       break;
2B7C  D001     BRA 0x2B80
503:                   case USB_REQUEST_SYNCH_FRAME:
504:                   default:
505:                       usb_RequestError();
2B7E  D8F8     RCALL usb_RequestError
506:               }
507:           }
2B80  0E08     MOVLW 0x8
2B82  5CE1     SUBWF FSR1L, W, ACCESS
2B84  E202     BC 0x2B8A
2B86  6AE1     CLRF FSR1L, ACCESS
2B88  52E5     MOVF POSTDEC1, F, ACCESS
2B8A  6EE1     MOVWF FSR1L, ACCESS
2B8C  52E5     MOVF POSTDEC1, F, ACCESS
2B8E  CFE7     MOVFF INDF1, FSR2L
2B90  FFD9     NOP
2B92  0012     RETURN 0
508:           
509:           void usb_handle_in(void) {
510:               if (endpoints[USB_STAT2EP(trn_status)].in_handler) {
2B94  0100     MOVLB 0x0
2B96  51B7     MOVF trn_status, W, BANKED
2B98  40E8     RRNCF WREG, W, ACCESS
2B9A  40E8     RRNCF WREG, W, ACCESS
2B9C  40E8     RRNCF WREG, W, ACCESS
2B9E  0B1F     ANDLW 0x1F
2BA0  0B0F     ANDLW 0xF
2BA2  0D04     MULLW 0x4
2BA4  CFF3     MOVFF PRODL, FSR0L
2BA6  FFE9     NOP
2BA8  CFF4     MOVFF PRODH, FSR0H
2BAA  FFEA     NOP
2BAC  0E71     MOVLW 0x71
2BAE  26E9     ADDWF FSR0L, F, ACCESS
2BB0  0E00     MOVLW 0x0
2BB2  22EA     ADDWFC FSR0H, F, ACCESS
2BB4  50EE     MOVF POSTINC0, W, ACCESS
2BB6  10ED     IORWF POSTDEC0, W, ACCESS
2BB8  E01A     BZ 0x2BEE
511:                   endpoints[USB_STAT2EP(trn_status)].in_handler();
2BBA  0100     MOVLB 0x0
2BBC  51B7     MOVF trn_status, W, BANKED
2BBE  40E8     RRNCF WREG, W, ACCESS
2BC0  40E8     RRNCF WREG, W, ACCESS
2BC2  40E8     RRNCF WREG, W, ACCESS
2BC4  0B1F     ANDLW 0x1F
2BC6  0B0F     ANDLW 0xF
2BC8  0D04     MULLW 0x4
2BCA  CFF3     MOVFF PRODL, FSR0L
2BCC  FFE9     NOP
2BCE  CFF4     MOVFF PRODH, FSR0H
2BD0  FFEA     NOP
2BD2  0E71     MOVLW 0x71
2BD4  26E9     ADDWF FSR0L, F, ACCESS
2BD6  0E00     MOVLW 0x0
2BD8  22EA     ADDWFC FSR0H, F, ACCESS
2BDA  CFEE     MOVFF POSTINC0, __tmp_0
2BDC  F014     NOP
2BDE  CFEF     MOVFF INDF0, digit_cnt
2BE0  F015     NOP
2BE2  D004     BRA 0x2BEC
2BE4  C015     MOVFF digit_cnt, PCLATH
2BE6  FFFA     NOP
2BE8  5014     MOVF __tmp_0, W, ACCESS
2BEA  6EF9     MOVWF PCL, ACCESS
2BEC  DFFB     RCALL 0x2BE4
512:               }
513:           }
2BEE  0012     RETURN 0
514:           
515:           void usb_handle_out(void) {
516:               if (endpoints[USB_STAT2EP(trn_status)].out_handler) {
2BF0  0100     MOVLB 0x0
2BF2  51B7     MOVF trn_status, W, BANKED
2BF4  40E8     RRNCF WREG, W, ACCESS
2BF6  40E8     RRNCF WREG, W, ACCESS
2BF8  40E8     RRNCF WREG, W, ACCESS
2BFA  0B1F     ANDLW 0x1F
2BFC  0B0F     ANDLW 0xF
2BFE  0D04     MULLW 0x4
2C00  CFF3     MOVFF PRODL, FSR0L
2C02  FFE9     NOP
2C04  CFF4     MOVFF PRODH, FSR0H
2C06  FFEA     NOP
2C08  0E71     MOVLW 0x71
2C0A  26E9     ADDWF FSR0L, F, ACCESS
2C0C  0E00     MOVLW 0x0
2C0E  22EA     ADDWFC FSR0H, F, ACCESS
2C10  0E02     MOVLW 0x2
2C12  26E9     ADDWF FSR0L, F, ACCESS
2C14  0E00     MOVLW 0x0
2C16  22EA     ADDWFC FSR0H, F, ACCESS
2C18  50EE     MOVF POSTINC0, W, ACCESS
2C1A  10ED     IORWF POSTDEC0, W, ACCESS
2C1C  E01E     BZ 0x2C5A
517:                   endpoints[USB_STAT2EP(trn_status)].out_handler();
2C1E  0100     MOVLB 0x0
2C20  51B7     MOVF trn_status, W, BANKED
2C22  40E8     RRNCF WREG, W, ACCESS
2C24  40E8     RRNCF WREG, W, ACCESS
2C26  40E8     RRNCF WREG, W, ACCESS
2C28  0B1F     ANDLW 0x1F
2C2A  0B0F     ANDLW 0xF
2C2C  0D04     MULLW 0x4
2C2E  CFF3     MOVFF PRODL, FSR0L
2C30  FFE9     NOP
2C32  CFF4     MOVFF PRODH, FSR0H
2C34  FFEA     NOP
2C36  0E71     MOVLW 0x71
2C38  26E9     ADDWF FSR0L, F, ACCESS
2C3A  0E00     MOVLW 0x0
2C3C  22EA     ADDWFC FSR0H, F, ACCESS
2C3E  0E02     MOVLW 0x2
2C40  26E9     ADDWF FSR0L, F, ACCESS
2C42  0E00     MOVLW 0x0
2C44  22EA     ADDWFC FSR0H, F, ACCESS
2C46  CFEE     MOVFF POSTINC0, __tmp_0
2C48  F014     NOP
2C4A  CFEF     MOVFF INDF0, digit_cnt
2C4C  F015     NOP
2C4E  D004     BRA 0x2C58
2C50  C015     MOVFF digit_cnt, PCLATH
2C52  FFFA     NOP
2C54  5014     MOVF __tmp_0, W, ACCESS
2C56  6EF9     MOVWF PCL, ACCESS
2C58  DFFB     RCALL 0x2C50
518:               }
519:           }
2C5A  0012     RETURN 0
520:           
521:           void usb_register_sof_handler(usb_handler_t handler) {
2C5C  CFD9     MOVFF FSR2L, POSTINC1
2C5E  FFE6     NOP
2C60  CFE1     MOVFF FSR1L, FSR2L
2C62  FFD9     NOP
522:               sof_handler = handler;
2C64  0EFD     MOVLW 0xFD
2C66  CFDB     MOVFF PLUSW2, sof_handler
2C68  F06B     NOP
2C6A  0EFE     MOVLW 0xFE
2C6C  CFDB     MOVFF PLUSW2, 0x6C
2C6E  F06C     NOP
523:           }
2C70  52E5     MOVF POSTDEC1, F, ACCESS
2C72  CFE7     MOVFF INDF1, FSR2L
2C74  FFD9     NOP
2C76  0012     RETURN 0
524:           
525:           void usb_register_class_setup_handler(usb_handler_t handler) {
2C78  CFD9     MOVFF FSR2L, POSTINC1
2C7A  FFE6     NOP
2C7C  CFE1     MOVFF FSR1L, FSR2L
2C7E  FFD9     NOP
526:               class_setup_handler = handler;
2C80  0EFD     MOVLW 0xFD
2C82  CFDB     MOVFF PLUSW2, class_setup_handler
2C84  F06D     NOP
2C86  0EFE     MOVLW 0xFE
2C88  CFDB     MOVFF PLUSW2, 0x6E
2C8A  F06E     NOP
527:           }
2C8C  52E5     MOVF POSTDEC1, F, ACCESS
2C8E  CFE7     MOVFF INDF1, FSR2L
2C90  FFD9     NOP
2C92  0012     RETURN 0
528:           
529:           void usb_register_vendor_setup_handler(usb_handler_t handler) {
2C94  CFD9     MOVFF FSR2L, POSTINC1
2C96  FFE6     NOP
2C98  CFE1     MOVFF FSR1L, FSR2L
2C9A  FFD9     NOP
530:               vendor_setup_handler = handler;
2C9C  0EFD     MOVLW 0xFD
2C9E  CFDB     MOVFF PLUSW2, vendor_setup_handler
2CA0  F06F     NOP
2CA2  0EFE     MOVLW 0xFE
2CA4  CFDB     MOVFF PLUSW2, 0x70
2CA6  F070     NOP
531:           }
2CA8  52E5     MOVF POSTDEC1, F, ACCESS
2CAA  CFE7     MOVFF INDF1, FSR2L
2CAC  FFD9     NOP
2CAE  0012     RETURN 0
532:           
533:           void usb_set_in_handler(int ep, usb_handler_t in_handler) {
2CB0  CFD9     MOVFF FSR2L, POSTINC1
2CB2  FFE6     NOP
2CB4  CFE1     MOVFF FSR1L, FSR2L
2CB6  FFD9     NOP
534:               endpoints[ep].in_handler = in_handler;
2CB8  0EFD     MOVLW 0xFD
2CBA  CFDB     MOVFF PLUSW2, FSR0L
2CBC  FFE9     NOP
2CBE  0EFE     MOVLW 0xFE
2CC0  CFDB     MOVFF PLUSW2, FSR0H
2CC2  FFEA     NOP
2CC4  90D8     BCF STATUS, 0, ACCESS
2CC6  36E9     RLCF FSR0L, F, ACCESS
2CC8  36EA     RLCF FSR0H, F, ACCESS
2CCA  90D8     BCF STATUS, 0, ACCESS
2CCC  36E9     RLCF FSR0L, F, ACCESS
2CCE  36EA     RLCF FSR0H, F, ACCESS
2CD0  0E71     MOVLW 0x71
2CD2  26E9     ADDWF FSR0L, F, ACCESS
2CD4  0E00     MOVLW 0x0
2CD6  22EA     ADDWFC FSR0H, F, ACCESS
2CD8  0EFB     MOVLW 0xFB
2CDA  CFDB     MOVFF PLUSW2, POSTINC0
2CDC  FFEE     NOP
2CDE  0EFC     MOVLW 0xFC
2CE0  CFDB     MOVFF PLUSW2, POSTDEC0
2CE2  FFED     NOP
535:           }
2CE4  52E5     MOVF POSTDEC1, F, ACCESS
2CE6  CFE7     MOVFF INDF1, FSR2L
2CE8  FFD9     NOP
2CEA  0012     RETURN 0
536:           
537:           void usb_set_out_handler(int ep, usb_handler_t out_handler) {
2CEC  CFD9     MOVFF FSR2L, POSTINC1
2CEE  FFE6     NOP
2CF0  CFE1     MOVFF FSR1L, FSR2L
2CF2  FFD9     NOP
538:               endpoints[ep].out_handler = out_handler;
2CF4  0EFD     MOVLW 0xFD
2CF6  CFDB     MOVFF PLUSW2, FSR0L
2CF8  FFE9     NOP
2CFA  0EFE     MOVLW 0xFE
2CFC  CFDB     MOVFF PLUSW2, FSR0H
2CFE  FFEA     NOP
2D00  90D8     BCF STATUS, 0, ACCESS
2D02  36E9     RLCF FSR0L, F, ACCESS
2D04  36EA     RLCF FSR0H, F, ACCESS
2D06  90D8     BCF STATUS, 0, ACCESS
2D08  36E9     RLCF FSR0L, F, ACCESS
2D0A  36EA     RLCF FSR0H, F, ACCESS
2D0C  0E71     MOVLW 0x71
2D0E  26E9     ADDWF FSR0L, F, ACCESS
2D10  0E00     MOVLW 0x0
2D12  22EA     ADDWFC FSR0H, F, ACCESS
2D14  0E02     MOVLW 0x2
2D16  26E9     ADDWF FSR0L, F, ACCESS
2D18  0E00     MOVLW 0x0
2D1A  22EA     ADDWFC FSR0H, F, ACCESS
2D1C  0EFB     MOVLW 0xFB
2D1E  CFDB     MOVFF PLUSW2, POSTINC0
2D20  FFEE     NOP
2D22  0EFC     MOVLW 0xFC
2D24  CFDB     MOVFF PLUSW2, POSTDEC0
2D26  FFED     NOP
539:           }
2D28  52E5     MOVF POSTDEC1, F, ACCESS
2D2A  CFE7     MOVFF INDF1, FSR2L
2D2C  FFD9     NOP
2D2E  0012     RETURN 0
540:           
541:           // JTR New added helper function use extensively by the standard and class
542:           // request handlers. All status IN packets are DAT1 as is the first DATA packet
543:           // of a IN transfer. Currently with this CDC stack the only IN DATA transfers
544:           // that are > 8 bytes is the descriptor transfer and these are transfered in
545:           // usb_send_rom()
546:           
547:           void usb_ack_dat1(int bdcnt) {
2D30  CFD9     MOVFF FSR2L, POSTINC1
2D32  FFE6     NOP
2D34  CFE1     MOVFF FSR1L, FSR2L
2D36  FFD9     NOP
548:               EP0_Inbdp->BDCNT = (bdcnt & 0xFF);
2D38  0EFF     MOVLW 0xFF
2D3A  6EE7     MOVWF INDF1, ACCESS
2D3C  0EFD     MOVLW 0xFD
2D3E  CFDB     MOVFF PLUSW2, __tmp_0
2D40  F014     NOP
2D42  0EFE     MOVLW 0xFE
2D44  CFDB     MOVFF PLUSW2, digit_cnt
2D46  F015     NOP
2D48  50E7     MOVF INDF1, W, ACCESS
2D4A  1614     ANDWF __tmp_0, F, ACCESS
2D4C  6A15     CLRF digit_cnt, ACCESS
2D4E  C0BA     MOVFF EP0_Inbdp, FSR0L
2D50  FFE9     NOP
2D52  C0BB     MOVFF 0xBB, FSR0H
2D54  FFEA     NOP
2D56  52EE     MOVF POSTINC0, F, ACCESS
2D58  C014     MOVFF __tmp_0, INDF0
2D5A  FFEF     NOP
549:               EP0_Inbdp->BDSTAT = (DTS | UOWN | DTSEN); // | ((bdcnt & 0x300) >> 8));
2D5C  C0BA     MOVFF EP0_Inbdp, FSR0L
2D5E  FFE9     NOP
2D60  C0BB     MOVFF 0xBB, FSR0H
2D62  FFEA     NOP
2D64  0EC8     MOVLW 0xC8
2D66  6EEF     MOVWF INDF0, ACCESS
550:           }
2D68  52E5     MOVF POSTDEC1, F, ACCESS
2D6A  CFE7     MOVFF INDF1, FSR2L
2D6C  FFD9     NOP
2D6E  0012     RETURN 0
551:           
552:           void usb_RequestError(void) {
553:           
554:               usb_bdt[USB_CALC_BD(0, USB_DIR_OUT, USB_PP_EVEN)].BDCNT = USB_EP0_BUFFER_SIZE;
2D70  0104     MOVLB 0x4
2D72  0E08     MOVLW 0x8
2D74  6F01     MOVWF c, BANKED
555:               //usb_bdt[USB_CALC_BD(0, USB_DIR_OUT, USB_PP_ODD)].BDCNT = USB_EP0_BUFFER_SIZE;
556:           
557:               usb_bdt[USB_CALC_BD(0, USB_DIR_IN, USB_PP_EVEN)].BDSTAT = UOWN + BSTALL;
2D76  0104     MOVLB 0x4
2D78  0E84     MOVLW 0x84
2D7A  6F04     MOVWF i, BANKED
558:               usb_bdt[USB_CALC_BD(0, USB_DIR_OUT, USB_PP_EVEN)].BDSTAT = UOWN + BSTALL;
2D7C  0104     MOVLB 0x4
2D7E  0E84     MOVLW 0x84
2D80  6F00     MOVWF i, BANKED
559:               //usb_bdt[USB_CALC_BD(0, USB_DIR_IN, USB_PP_ODD)].BDSTAT = UOWN + BSTALL;
560:               //usb_bdt[USB_CALC_BD(0, USB_DIR_OUT, USB_PP_ODD)].BDSTAT = UOWN + BSTALL;
561:           
562:               // JTR TODO: Should also kill the IN and OUT handlers?
563:           
564:           }
2D82  0012     RETURN 0
565:           
566:           void usb_set_address(void) {
567:               if (0x00u == usb_addr_pending) {
2D84  0100     MOVLB 0x0
2D86  51B6     MOVF usb_addr_pending, W, BANKED
2D88  E104     BNZ 0x2D92
568:                   usb_device_state = DEFAULT_STATE;
2D8A  0100     MOVLB 0x0
2D8C  0E04     MOVLW 0x4
2D8E  6FB5     MOVWF usb_device_state, BANKED
569:               } else {
2D90  D003     BRA 0x2D98
570:                   usb_device_state = ADDRESS_STATE;
2D92  0100     MOVLB 0x0
2D94  0E10     MOVLW 0x10
2D96  6FB5     MOVWF usb_device_state, BANKED
571:               }
572:               SetUsbAddress(usb_addr_pending);
2D98  C0B6     MOVFF usb_addr_pending, UADDR
2D9A  FF6E     NOP
573:               usb_addr_pending = 0xFF;
2D9C  0100     MOVLB 0x0
2D9E  69B6     SETF usb_addr_pending, BANKED
574:               usb_unset_in_handler(0); // Unregister handler
2DA0  0E00     MOVLW 0x0
2DA2  6EE6     MOVWF POSTINC1, ACCESS
2DA4  6AE6     CLRF POSTINC1, ACCESS
2DA6  0E00     MOVLW 0x0
2DA8  6EE6     MOVWF POSTINC1, ACCESS
2DAA  6AE6     CLRF POSTINC1, ACCESS
2DAC  DF81     RCALL usb_set_in_handler
2DAE  52E5     MOVF POSTDEC1, F, ACCESS
2DB0  52E5     MOVF POSTDEC1, F, ACCESS
2DB2  52E5     MOVF POSTDEC1, F, ACCESS
2DB4  52E5     MOVF POSTDEC1, F, ACCESS
575:           }
2DB6  0012     RETURN 0
576:           
577:           void usb_send_rom(void) {
2DB8  CFD9     MOVFF FSR2L, POSTINC1
2DBA  FFE6     NOP
2DBC  CFE1     MOVFF FSR1L, FSR2L
2DBE  FFD9     NOP
2DC0  0E04     MOVLW 0x4
2DC2  26E1     ADDWF FSR1L, F, ACCESS
578:           
579:               unsigned int i;
580:               size_t packet_len;
581:               if (usb_rom_len) {
2DC4  0100     MOVLB 0x0
2DC6  51BF     MOVF usb_rom_len, W, BANKED
2DC8  11C0     IORWF 0xC0, W, BANKED
2DCA  E05A     BZ 0x2E80
582:                   packet_len = (usb_rom_len < USB_EP0_BUFFER_SIZE) ? usb_rom_len : USB_EP0_BUFFER_SIZE; // JTR changed from MAX_BUFFER_SIZE
2DCC  0100     MOVLB 0x0
2DCE  0E08     MOVLW 0x8
2DD0  5DBF     SUBWF usb_rom_len, W, BANKED
2DD2  0E00     MOVLW 0x0
2DD4  59C0     SUBWFB 0xC0, W, BANKED
2DD6  E205     BC 0x2DE2
2DD8  C0BF     MOVFF usb_rom_len, __tmp_0
2DDA  F014     NOP
2DDC  C0C0     MOVFF 0xC0, digit_cnt
2DDE  F015     NOP
2DE0  D003     BRA 0x2DE8
2DE2  0E08     MOVLW 0x8
2DE4  6E14     MOVWF __tmp_0, ACCESS
2DE6  6A15     CLRF digit_cnt, ACCESS
2DE8  0E02     MOVLW 0x2
2DEA  C014     MOVFF __tmp_0, PLUSW2
2DEC  FFDB     NOP
2DEE  0E03     MOVLW 0x3
2DF0  C015     MOVFF digit_cnt, PLUSW2
2DF2  FFDB     NOP
583:           
584:                   for (i = 0; i < packet_len; i++) {
2DF4  6ADE     CLRF POSTINC2, ACCESS
2DF6  6ADD     CLRF POSTDEC2, ACCESS
2DF8  CFDE     MOVFF POSTINC2, __tmp_0
2DFA  F014     NOP
2DFC  CFDD     MOVFF POSTDEC2, digit_cnt
2DFE  F015     NOP
2E00  0E02     MOVLW 0x2
2E02  CFDB     MOVFF PLUSW2, prefix_cnt
2E04  F016     NOP
2E06  0E03     MOVLW 0x3
2E08  CFDB     MOVFF PLUSW2, sign_char
2E0A  F017     NOP
2E0C  5016     MOVF prefix_cnt, W, ACCESS
2E0E  5C14     SUBWF __tmp_0, W, ACCESS
2E10  5017     MOVF sign_char, W, ACCESS
2E12  5815     SUBWFB digit_cnt, W, ACCESS
2E14  E234     BC 0x2E7E
2E74  2ADF     INCF INDF2, F, ACCESS
2E76  0E01     MOVLW 0x1
2E78  E301     BNC 0x2E7C
2E7A  2ADB     INCF PLUSW2, F, ACCESS
2E7C  D7BD     BRA 0x2DF8
585:                       EP0_Inbdp->BDADDR[i] = usb_rom_ptr[i];
2E16  CFDE     MOVFF POSTINC2, prefix_cnt
2E18  F016     NOP
2E1A  CFDD     MOVFF POSTDEC2, sign_char
2E1C  F017     NOP
2E1E  6A18     CLRF buf, ACCESS
2E20  0100     MOVLB 0x0
2E22  51BC     MOVF usb_rom_ptr, W, BANKED
2E24  2416     ADDWF prefix_cnt, W, ACCESS
2E26  6EF3     MOVWF PRODL, ACCESS
2E28  0100     MOVLB 0x0
2E2A  51BD     MOVF 0xBD, W, BANKED
2E2C  2017     ADDWFC sign_char, W, ACCESS
2E2E  6EF4     MOVWF PRODH, ACCESS
2E30  0100     MOVLB 0x0
2E32  51BE     MOVF 0xBE, W, BANKED
2E34  2018     ADDWFC buf, W, ACCESS
2E36  6EF8     MOVWF TBLPTRU, ACCESS
2E38  CFF4     MOVFF PRODH, TBLPTRH
2E3A  FFF7     NOP
2E3C  CFF3     MOVFF PRODL, TBLPTRL
2E3E  FFF6     NOP
2E40  0008     TBLRD*
2E42  50F5     MOVF TABLAT, W, ACCESS
2E44  6EE6     MOVWF POSTINC1, ACCESS
2E46  CFDE     MOVFF POSTINC2, __tmp_0
2E48  F014     NOP
2E4A  CFDD     MOVFF POSTDEC2, digit_cnt
2E4C  F015     NOP
2E4E  C0BA     MOVFF EP0_Inbdp, FSR0L
2E50  FFE9     NOP
2E52  C0BB     MOVFF 0xBB, FSR0H
2E54  FFEA     NOP
2E56  0E02     MOVLW 0x2
2E58  26E9     ADDWF FSR0L, F, ACCESS
2E5A  0E00     MOVLW 0x0
2E5C  22EA     ADDWFC FSR0H, F, ACCESS
2E5E  5014     MOVF __tmp_0, W, ACCESS
2E60  24EE     ADDWF POSTINC0, W, ACCESS
2E62  6EE7     MOVWF INDF1, ACCESS
2E64  5015     MOVF digit_cnt, W, ACCESS
2E66  20EE     ADDWFC POSTINC0, W, ACCESS
2E68  6EEA     MOVWF FSR0H, ACCESS
2E6A  CFE7     MOVFF INDF1, FSR0L
2E6C  FFE9     NOP
2E6E  52E5     MOVF POSTDEC1, F, ACCESS
2E70  50E7     MOVF INDF1, W, ACCESS
2E72  6EEF     MOVWF INDF0, ACCESS
586:                   }
587:               } else {
2E7E  D00F     BRA 0x2E9E
588:                   packet_len = 0;
2E80  0E02     MOVLW 0x2
2E82  6ADB     CLRF PLUSW2, ACCESS
2E84  0E03     MOVLW 0x3
2E86  6ADB     CLRF PLUSW2, ACCESS
589:                   usb_unset_in_handler(0);
2E88  0E00     MOVLW 0x0
2E8A  6EE6     MOVWF POSTINC1, ACCESS
2E8C  6AE6     CLRF POSTINC1, ACCESS
2E8E  0E00     MOVLW 0x0
2E90  6EE6     MOVWF POSTINC1, ACCESS
2E92  6AE6     CLRF POSTINC1, ACCESS
2E94  DF0D     RCALL usb_set_in_handler
2E96  52E5     MOVF POSTDEC1, F, ACCESS
2E98  52E5     MOVF POSTDEC1, F, ACCESS
2E9A  52E5     MOVF POSTDEC1, F, ACCESS
2E9C  52E5     MOVF POSTDEC1, F, ACCESS
590:               }
591:           
592:               EP0_Inbdp->BDCNT = (BYTE) packet_len;
2E9E  C0BA     MOVFF EP0_Inbdp, FSR0L
2EA0  FFE9     NOP
2EA2  C0BB     MOVFF 0xBB, FSR0H
2EA4  FFEA     NOP
2EA6  52EE     MOVF POSTINC0, F, ACCESS
2EA8  0E02     MOVLW 0x2
2EAA  CFDB     MOVFF PLUSW2, INDF0
2EAC  FFEF     NOP
593:               EP0_Inbdp->BDSTAT = ((EP0_Inbdp->BDSTAT ^ DTS) & DTS) | UOWN | DTSEN; // Packet length always less then 256 on endpoint 0
2EAE  C0BA     MOVFF EP0_Inbdp, FSR0L
2EB0  FFE9     NOP
2EB2  C0BB     MOVFF 0xBB, FSR0H
2EB4  FFEA     NOP
2EB6  50EF     MOVF INDF0, W, ACCESS
2EB8  0A40     XORLW 0x40
2EBA  0B40     ANDLW 0x40
2EBC  0980     IORLW 0x80
2EBE  0908     IORLW 0x8
2EC0  6EE6     MOVWF POSTINC1, ACCESS
2EC2  C0BA     MOVFF EP0_Inbdp, FSR0L
2EC4  FFE9     NOP
2EC6  C0BB     MOVFF 0xBB, FSR0H
2EC8  FFEA     NOP
2ECA  52E5     MOVF POSTDEC1, F, ACCESS
2ECC  50E7     MOVF INDF1, W, ACCESS
2ECE  6EEF     MOVWF INDF0, ACCESS
594:           
595:               usb_rom_ptr += packet_len;
2ED0  0E02     MOVLW 0x2
2ED2  CFDB     MOVFF PLUSW2, __tmp_0
2ED4  F014     NOP
2ED6  0E03     MOVLW 0x3
2ED8  CFDB     MOVFF PLUSW2, digit_cnt
2EDA  F015     NOP
2EDC  6A16     CLRF prefix_cnt, ACCESS
2EDE  5014     MOVF __tmp_0, W, ACCESS
2EE0  0100     MOVLB 0x0
2EE2  27BC     ADDWF usb_rom_ptr, F, BANKED
2EE4  5015     MOVF digit_cnt, W, ACCESS
2EE6  0100     MOVLB 0x0
2EE8  23BD     ADDWFC 0xBD, F, BANKED
2EEA  5016     MOVF prefix_cnt, W, ACCESS
2EEC  0100     MOVLB 0x0
2EEE  23BE     ADDWFC 0xBE, F, BANKED
596:               usb_rom_len -= packet_len;
2EF0  0E02     MOVLW 0x2
2EF2  CFDB     MOVFF PLUSW2, pUEP
2EF4  F006     NOP
2EF6  0E03     MOVLW 0x3
2EF8  CFDB     MOVFF PLUSW2, size
2EFA  F007     NOP
2EFC  5006     MOVF pUEP, W, ACCESS
2EFE  0100     MOVLB 0x0
2F00  5FBF     SUBWF usb_rom_len, F, BANKED
2F02  5007     MOVF size, W, ACCESS
2F04  0100     MOVLB 0x0
2F06  5BC0     SUBWFB 0xC0, F, BANKED
597:           }
2F08  0E04     MOVLW 0x4
2F0A  5CE1     SUBWF FSR1L, W, ACCESS
2F0C  E202     BC 0x2F12
2F0E  6AE1     CLRF FSR1L, ACCESS
2F10  52E5     MOVF POSTDEC1, F, ACCESS
2F12  6EE1     MOVWF FSR1L, ACCESS
2F14  52E5     MOVF POSTDEC1, F, ACCESS
2F16  CFE7     MOVFF INDF1, FSR2L
2F18  FFD9     NOP
2F1A  0012     RETURN 0
598:           
---  /home/antoine/Documents/Pic/DP_USB/USB_stack/dp_usb/cdc.c  -----------------------------------------
1:             /*
2:             This work is licensed under the Creative Commons Attribution 3.0 Unported License.
3:             To view a copy of this license, visit http://creativecommons.org/licenses/by/3.0/
4:             or send a letter to
5:                     Creative Commons,
6:                     171 Second Street,
7:                     Suite 300,
8:                     San Francisco,
9:                     California,
10:                    94105,
11:                    USA.
12:             */
13:            
14:            // JTR V0.1a
15:            // JTR v0.1b
16:            // JTR v0.1c	// tidy up added code line code handler to set the SPBRG based on line coding.
17:            // JTR V0.2a   // 26th Jan 2012
18:            
19:            #include "usb_stack_globals.h"    // USB stack only defines Not function related.
20:            
21:            #include <string.h>
22:            
23:            enum stopbits {
24:                one = 0, oneandahalf = 1, two = 2
25:            };
26:            
27:            enum parity {
28:                none = 0, odd = 1, even = 2, mark = 3, space = 4
29:            };
30:            const char parity_str[] = {'N', 'O', 'E', 'M', 'S'};
31:            
32:            struct cdc_LineCodeing {
33:                unsigned long int dwDTERate;
34:                enum stopbits bCharFormat;
35:                enum parity bParityType;
36:                BYTE bDataBits;
37:            } linecodeing;
38:            
39:            
40:            #pragma udata usb_data
41:            BYTE cdc_acm_in_buffer[CDC_NOTICE_BUFFER_SIZE]; //JTR NEWLY defined NOTICE BUFFER SIZE and increased from 8 to 10 bytes in usb_config.h
42:            
43:            #pragma udata usb_data3
44:            BYTE cdc_In_bufferA[CDC_BUFFER_SIZE];
45:            BYTE cdc_In_bufferB[CDC_BUFFER_SIZE];
46:            BYTE cdc_Out_bufferA[CDC_BUFFER_SIZE];
47:            BYTE cdc_Out_bufferB[CDC_BUFFER_SIZE];
48:            
49:            #pragma udata
50:            
51:            struct _cdc_ControlLineState cls;
52:            BYTE cdc_In_len; // total cdc In length
53:            volatile BYTE cdc_Out_len; // total cdc out length
54:            BYTE IsInBufferA;
55:            BYTE IsOutBufferA;
56:            BYTE *InPtr;
57:            BYTE *OutPtr;
58:            BYTE LineStateUpdated = 0;
59:            BYTE cdc_timeout_count = 0;
60:            BYTE ZLPpending = 0;
61:            BYTE lock = 0;
62:            
63:            BDentry *CDC_Outbdp, *CDC_Inbdp;
64:            BYTE CDCFunctionError;
65:            
66:            volatile BYTE cdc_trf_state; // JTR don't see that it is really volatile in current context may be in future.
67:            
68:            void initCDC(void) {
69:            
70:                // JTR The function usb_init() is now called from main.c prior to anything else belonging to the CDC CLASS
71:                // If we have multiple functions we want the USB initialization to be in only one consistant place.
72:                // The sort of things we would do in InitCDC would be to setup I/O pins and the HARDWARE UART so it
73:                // is not transmitting junk between a RESET and the device being enumerated. Hardware CTS/RTS
74:                // would also be setup here if being used.
75:            
76:                linecodeing.dwDTERate = 115200;
3B3E  0100     MOVLB 0x0
3B40  6BC2     CLRF linecodeing, BANKED
3B42  0EC2     MOVLW 0xC2
3B44  6FC3     MOVWF 0xC3, BANKED
3B46  0E01     MOVLW 0x1
3B48  6FC4     MOVWF 0xC4, BANKED
3B4A  6BC5     CLRF 0xC5, BANKED
77:                linecodeing.bCharFormat = one;
3B4C  0100     MOVLB 0x0
3B4E  6BC6     CLRF 0xC6, BANKED
78:                linecodeing.bParityType = none;
3B50  0100     MOVLB 0x0
3B52  6BC7     CLRF 0xC7, BANKED
79:                linecodeing.bDataBits = 8;
3B54  0100     MOVLB 0x0
3B56  0E08     MOVLW 0x8
3B58  6FC8     MOVWF 0xC8, BANKED
80:                cls.DTR = 0;
3B5A  0100     MOVLB 0x0
3B5C  91C9     BCF cls, 0, BANKED
81:                cls.RTS = 0;
3B5E  0100     MOVLB 0x0
3B60  93C9     BCF cls, 1, BANKED
82:                usb_register_class_setup_handler(cdc_setup);
3B62  0E88     MOVLW 0x88
3B64  6EE6     MOVWF POSTINC1, ACCESS
3B66  0E3C     MOVLW 0x3C
3B68  6EE6     MOVWF POSTINC1, ACCESS
3B6A  EC3C     CALL 0x2C78, 0
3B6C  F016     NOP
3B6E  52E5     MOVF POSTDEC1, F, ACCESS
3B70  52E5     MOVF POSTDEC1, F, ACCESS
83:            }
3B72  0012     RETURN 0
84:            
85:            void user_configured_init(void) {
86:                // JTR NEW FUNCTION
87:                // After the device is enumerated and configured then we set up non EP0 endpoints.
88:                // We only enable the endpoints we are using, not all of them.
89:                // Prior to this they are held in a disarmed state.
90:            
91:                // This function belongs to the current USB function and IS NOT generic. This is CLASS specific
92:                // and will vary from implementation to implementation.
93:            
94:                usb_unset_in_handler(1);
3B74  0E00     MOVLW 0x0
3B76  6EE6     MOVWF POSTINC1, ACCESS
3B78  6AE6     CLRF POSTINC1, ACCESS
3B7A  0E01     MOVLW 0x1
3B7C  6EE6     MOVWF POSTINC1, ACCESS
3B7E  6AE6     CLRF POSTINC1, ACCESS
3B80  EC58     CALL 0x2CB0, 0
3B82  F016     NOP
3B84  52E5     MOVF POSTDEC1, F, ACCESS
3B86  52E5     MOVF POSTDEC1, F, ACCESS
3B88  52E5     MOVF POSTDEC1, F, ACCESS
3B8A  52E5     MOVF POSTDEC1, F, ACCESS
95:                usb_unset_in_handler(2);
3B8C  0E00     MOVLW 0x0
3B8E  6EE6     MOVWF POSTINC1, ACCESS
3B90  6AE6     CLRF POSTINC1, ACCESS
3B92  0E02     MOVLW 0x2
3B94  6EE6     MOVWF POSTINC1, ACCESS
3B96  6AE6     CLRF POSTINC1, ACCESS
3B98  EC58     CALL 0x2CB0, 0
3B9A  F016     NOP
3B9C  52E5     MOVF POSTDEC1, F, ACCESS
3B9E  52E5     MOVF POSTDEC1, F, ACCESS
3BA0  52E5     MOVF POSTDEC1, F, ACCESS
3BA2  52E5     MOVF POSTDEC1, F, ACCESS
96:                usb_unset_out_handler(2);
3BA4  0E00     MOVLW 0x0
3BA6  6EE6     MOVWF POSTINC1, ACCESS
3BA8  6AE6     CLRF POSTINC1, ACCESS
3BAA  0E02     MOVLW 0x2
3BAC  6EE6     MOVWF POSTINC1, ACCESS
3BAE  6AE6     CLRF POSTINC1, ACCESS
3BB0  EC76     CALL 0x2CEC, 0
3BB2  F016     NOP
3BB4  52E5     MOVF POSTDEC1, F, ACCESS
3BB6  52E5     MOVF POSTDEC1, F, ACCESS
3BB8  52E5     MOVF POSTDEC1, F, ACCESS
3BBA  52E5     MOVF POSTDEC1, F, ACCESS
97:            
98:                USB_UEP1 = USB_EP_IN;
3BBC  0E1A     MOVLW 0x1A
3BBE  6E71     MOVWF UEP1, ACCESS
99:                USB_UEP2 = USB_EP_INOUT;
3BC0  0E1E     MOVLW 0x1E
3BC2  6E72     MOVWF UEP2, ACCESS
100:           
101:               /* Configure buffer descriptors */
102:           #if USB_PP_BUF_MODE == 0
103:               // JTR Setup CDC LINE_NOTICE EP (Interrupt IN)
104:               usb_bdt[USB_CALC_BD(1, USB_DIR_IN, USB_PP_EVEN)].BDCNT = 0;
3BC4  0104     MOVLB 0x4
3BC6  6B0D     CLRF 0xD, BANKED
105:               usb_bdt[USB_CALC_BD(1, USB_DIR_IN, USB_PP_EVEN)].BDADDR = cdc_acm_in_buffer;
3BC8  0104     MOVLB 0x4
3BCA  0E80     MOVLW 0x80
3BCC  6F0E     MOVWF romstring, BANKED
3BCE  0E04     MOVLW 0x4
3BD0  6F0F     MOVWF 0xF, BANKED
106:               usb_bdt[USB_CALC_BD(1, USB_DIR_IN, USB_PP_EVEN)].BDSTAT = DTS + DTSEN; // Set DTS => First packet inverts, ie. is Data0
3BD2  0104     MOVLB 0x4
3BD4  0E48     MOVLW 0x48
3BD6  6F0C     MOVWF 0xC, BANKED
107:           #else
108:               // TODO: Implement Ping-Pong buffering setup.
109:           #error "PP Mode not implemented yet"
110:           #endif
111:           
112:               usb_register_class_setup_handler(cdc_setup);
3BD8  0E88     MOVLW 0x88
3BDA  6EE6     MOVWF POSTINC1, ACCESS
3BDC  0E3C     MOVLW 0x3C
3BDE  6EE6     MOVWF POSTINC1, ACCESS
3BE0  EC3C     CALL 0x2C78, 0
3BE2  F016     NOP
3BE4  52E5     MOVF POSTDEC1, F, ACCESS
3BE6  52E5     MOVF POSTDEC1, F, ACCESS
113:               cdc_trf_state = 0;
3BE8  0100     MOVLB 0x0
3BEA  6BD8     CLRF cdc_trf_state, BANKED
114:               CDC_Outbdp = &usb_bdt[USB_CALC_BD(2, USB_DIR_OUT, USB_PP_EVEN)];
3BEC  0100     MOVLB 0x0
3BEE  0E10     MOVLW 0x10
3BF0  6FD3     MOVWF CDC_Outbdp, BANKED
3BF2  0E04     MOVLW 0x4
3BF4  6FD4     MOVWF 0xD4, BANKED
115:               CDC_Inbdp = &usb_bdt[USB_CALC_BD(2, USB_DIR_IN, USB_PP_EVEN)];
3BF6  0100     MOVLB 0x0
3BF8  0E14     MOVLW 0x14
3BFA  6FD5     MOVWF CDC_Inbdp, BANKED
3BFC  0E04     MOVLW 0x4
3BFE  6FD6     MOVWF 0xD6, BANKED
116:           
117:               IsInBufferA = 0xFF;
3C00  0100     MOVLB 0x0
3C02  69CD     SETF IsInBufferA, BANKED
118:               InPtr = cdc_In_bufferA;
3C04  0100     MOVLB 0x0
3C06  0E80     MOVLW 0x80
3C08  6FCF     MOVWF InPtr, BANKED
3C0A  0E05     MOVLW 0x5
3C0C  6FD0     MOVWF 0xD0, BANKED
119:               cdc_In_len = 0;
3C0E  0100     MOVLB 0x0
3C10  6BCB     CLRF cdc_In_len, BANKED
120:               CDC_Inbdp->BDADDR = &cdc_In_bufferA[0];
3C12  C0D5     MOVFF CDC_Inbdp, FSR0L
3C14  FFE9     NOP
3C16  C0D6     MOVFF 0xD6, FSR0H
3C18  FFEA     NOP
3C1A  0E02     MOVLW 0x2
3C1C  26E9     ADDWF FSR0L, F, ACCESS
3C1E  0E00     MOVLW 0x0
3C20  22EA     ADDWFC FSR0H, F, ACCESS
3C22  0E80     MOVLW 0x80
3C24  6EEE     MOVWF POSTINC0, ACCESS
3C26  0E05     MOVLW 0x5
3C28  6EED     MOVWF POSTDEC0, ACCESS
121:               CDC_Inbdp->BDCNT = 0;
3C2A  C0D5     MOVFF CDC_Inbdp, FSR0L
3C2C  FFE9     NOP
3C2E  C0D6     MOVFF 0xD6, FSR0H
3C30  FFEA     NOP
3C32  52EE     MOVF POSTINC0, F, ACCESS
3C34  6AEF     CLRF INDF0, ACCESS
122:               CDC_Inbdp->BDSTAT = DTS + DTSEN;
3C36  C0D5     MOVFF CDC_Inbdp, FSR0L
3C38  FFE9     NOP
3C3A  C0D6     MOVFF 0xD6, FSR0H
3C3C  FFEA     NOP
3C3E  0E48     MOVLW 0x48
3C40  6EEF     MOVWF INDF0, ACCESS
123:           
124:               cdc_Out_len = 0;
3C42  0100     MOVLB 0x0
3C44  6BCC     CLRF cdc_Out_len, BANKED
125:               IsOutBufferA = 0xFF;
3C46  0100     MOVLB 0x0
3C48  69CE     SETF IsOutBufferA, BANKED
126:               OutPtr = cdc_Out_bufferA;
3C4A  0100     MOVLB 0x0
3C4C  0E00     MOVLW 0x0
3C4E  6FD1     MOVWF OutPtr, BANKED
3C50  0E06     MOVLW 0x6
3C52  6FD2     MOVWF 0xD2, BANKED
127:               CDC_Outbdp->BDCNT = CDC_BUFFER_SIZE;
3C54  C0D3     MOVFF CDC_Outbdp, FSR0L
3C56  FFE9     NOP
3C58  C0D4     MOVFF 0xD4, FSR0H
3C5A  FFEA     NOP
3C5C  52EE     MOVF POSTINC0, F, ACCESS
3C5E  0E40     MOVLW 0x40
3C60  6EEF     MOVWF INDF0, ACCESS
128:               CDC_Outbdp->BDADDR = &cdc_Out_bufferA[0];
3C62  C0D3     MOVFF CDC_Outbdp, FSR0L
3C64  FFE9     NOP
3C66  C0D4     MOVFF 0xD4, FSR0H
3C68  FFEA     NOP
3C6A  0E02     MOVLW 0x2
3C6C  26E9     ADDWF FSR0L, F, ACCESS
3C6E  0E00     MOVLW 0x0
3C70  22EA     ADDWFC FSR0H, F, ACCESS
3C72  0E00     MOVLW 0x0
3C74  6EEE     MOVWF POSTINC0, ACCESS
3C76  0E06     MOVLW 0x6
3C78  6EED     MOVWF POSTDEC0, ACCESS
129:               CDC_Outbdp->BDSTAT = UOWN + DTSEN;
3C7A  C0D3     MOVFF CDC_Outbdp, FSR0L
3C7C  FFE9     NOP
3C7E  C0D4     MOVFF 0xD4, FSR0H
3C80  FFEA     NOP
3C82  0E88     MOVLW 0x88
3C84  6EEF     MOVWF INDF0, ACCESS
130:           }
3C86  0012     RETURN 0
131:           
132:           void cdc_setup(void) {
3C88  CFD9     MOVFF FSR2L, POSTINC1
3C8A  FFE6     NOP
3C8C  CFE1     MOVFF FSR1L, FSR2L
3C8E  FFD9     NOP
3C90  0E04     MOVLW 0x4
3C92  26E1     ADDWF FSR1L, F, ACCESS
133:               BYTE *packet;
134:               size_t reply_len;
135:               packet = EP0_Outbdp->BDADDR;
3C94  C0B8     MOVFF EP0_Outbdp, FSR0L
3C96  FFE9     NOP
3C98  C0B9     MOVFF 0xB9, FSR0H
3C9A  FFEA     NOP
3C9C  0E02     MOVLW 0x2
3C9E  26E9     ADDWF FSR0L, F, ACCESS
3CA0  0E00     MOVLW 0x0
3CA2  22EA     ADDWFC FSR0H, F, ACCESS
3CA4  CFEE     MOVFF POSTINC0, POSTINC2
3CA6  FFDE     NOP
3CA8  CFED     MOVFF POSTDEC0, POSTDEC2
3CAA  FFDD     NOP
136:           
137:               switch (packet[USB_bmRequestType] & (USB_bmRequestType_TypeMask | USB_bmRequestType_RecipientMask)) {
3CAC  CFDE     MOVFF POSTINC2, FSR0L
3CAE  FFE9     NOP
3CB0  CFDD     MOVFF POSTDEC2, FSR0H
3CB2  FFEA     NOP
3CB4  50EF     MOVF INDF0, W, ACCESS
3CB6  0B63     ANDLW 0x63
3CB8  0A21     XORLW 0x21
3CBA  E001     BZ 0x3CBE
3CBC  D0BB     BRA 0x3E34
138:                   case (USB_bmRequestType_Class | USB_bmRequestType_Interface):
139:                       switch (packet[USB_bRequest]) {
3CBE  CFDE     MOVFF POSTINC2, FSR0L
3CC0  FFE9     NOP
3CC2  CFDD     MOVFF POSTDEC2, FSR0H
3CC4  FFEA     NOP
3CC6  0E01     MOVLW 0x1
3CC8  26E9     ADDWF FSR0L, F, ACCESS
3CCA  0E00     MOVLW 0x0
3CCC  22EA     ADDWFC FSR0H, F, ACCESS
3CCE  50EF     MOVF INDF0, W, ACCESS
3CD0  0A23     XORLW 0x23
3CD2  E101     BNZ 0x3CD6
3CD4  D0AC     BRA 0x3E2E
3CD6  0A01     XORLW 0x1
3CD8  E101     BNZ 0x3CDC
3CDA  D085     BRA 0x3DE6
3CDC  0A03     XORLW 0x3
3CDE  E02E     BZ 0x3D3C
3CE0  0A01     XORLW 0x1
3CE2  E01E     BZ 0x3D20
3CE4  0A22     XORLW 0x22
3CE6  E019     BZ 0x3D1A
3CE8  0A01     XORLW 0x1
3CEA  E017     BZ 0x3D1A
3CEC  0A07     XORLW 0x7
3CEE  E015     BZ 0x3D1A
3CF0  0A05     XORLW 0x5
3CF2  E00B     BZ 0x3D0A
3CF4  0A01     XORLW 0x1
3CF6  E001     BZ 0x3CFA
3CF8  D09A     BRA 0x3E2E
140:           
141:                               //JTR This is just a dummy, nothing defined to do for CDC ACM
142:                           case CDC_SEND_ENCAPSULATED_COMMAND:
143:                               usb_ack_dat1(0);
3CFA  0E00     MOVLW 0x0
3CFC  6EE6     MOVWF POSTINC1, ACCESS
3CFE  6AE6     CLRF POSTINC1, ACCESS
3D00  EC98     CALL 0x2D30, 0
3D02  F016     NOP
3D04  52E5     MOVF POSTDEC1, F, ACCESS
3D06  52E5     MOVF POSTDEC1, F, ACCESS
144:                               break;
3D08  D094     BRA 0x3E32
145:           
146:                               //JTR This is just a dummy, nothing defined to do for CDC ACM
147:                           case CDC_GET_ENCAPSULATED_RESPONSE:
148:                               //usb_ack_zero(rbdp);
149:                               usb_ack_dat1(0);
3D0A  0E00     MOVLW 0x0
3D0C  6EE6     MOVWF POSTINC1, ACCESS
3D0E  6AE6     CLRF POSTINC1, ACCESS
3D10  EC98     CALL 0x2D30, 0
3D12  F016     NOP
3D14  52E5     MOVF POSTDEC1, F, ACCESS
3D16  52E5     MOVF POSTDEC1, F, ACCESS
150:                               break;
3D18  D08C     BRA 0x3E32
151:           
152:                           case CDC_SET_COMM_FEATURE: // Optional
153:                           case CDC_GET_COMM_FEATURE: // Optional
154:                           case CDC_CLEAR_COMM_FEATURE: // Optional
155:                               usb_RequestError(); // Not advertised in ACM functional descriptor
3D1A  ECB8     CALL 0x2D70, 0
3D1C  F016     NOP
156:                               break;
3D1E  D089     BRA 0x3E32
157:           
158:                           case CDC_SET_LINE_CODING: // Optional, strongly recomended
159:                               usb_set_out_handler(0, cdc_set_line_coding_data); // Register out handler function
3D20  0E66     MOVLW 0x66
3D22  6EE6     MOVWF POSTINC1, ACCESS
3D24  0E3E     MOVLW 0x3E
3D26  6EE6     MOVWF POSTINC1, ACCESS
3D28  0E00     MOVLW 0x0
3D2A  6EE6     MOVWF POSTINC1, ACCESS
3D2C  6AE6     CLRF POSTINC1, ACCESS
3D2E  EC76     CALL 0x2CEC, 0
3D30  F016     NOP
3D32  52E5     MOVF POSTDEC1, F, ACCESS
3D34  52E5     MOVF POSTDEC1, F, ACCESS
3D36  52E5     MOVF POSTDEC1, F, ACCESS
3D38  52E5     MOVF POSTDEC1, F, ACCESS
160:                               break;
3D3A  D07B     BRA 0x3E32
161:           
162:                           case CDC_GET_LINE_CODING: // Optional, strongly recomended
163:                               // JTR reply length (7) is always going to be less than minimum EP0 size (8)
164:           
165:                               reply_len = *((unsigned int *) &packet[USB_wLength]);
3D3C  CFDE     MOVFF POSTINC2, FSR0L
3D3E  FFE9     NOP
3D40  CFDD     MOVFF POSTDEC2, FSR0H
3D42  FFEA     NOP
3D44  0E06     MOVLW 0x6
3D46  26E9     ADDWF FSR0L, F, ACCESS
3D48  0E00     MOVLW 0x0
3D4A  22EA     ADDWFC FSR0H, F, ACCESS
3D4C  0E02     MOVLW 0x2
3D4E  CFEE     MOVFF POSTINC0, PLUSW2
3D50  FFDB     NOP
3D52  0E03     MOVLW 0x3
3D54  CFED     MOVFF POSTDEC0, PLUSW2
3D56  FFDB     NOP
166:                               if (sizeof (struct cdc_LineCodeing) < reply_len) {
3D58  0E02     MOVLW 0x2
3D5A  CFDB     MOVFF PLUSW2, __tmp_0
3D5C  F014     NOP
3D5E  0E03     MOVLW 0x3
3D60  CFDB     MOVFF PLUSW2, digit_cnt
3D62  F015     NOP
3D64  0E07     MOVLW 0x7
3D66  80D8     BSF STATUS, 0, ACCESS
3D68  5414     SUBFWB __tmp_0, W, ACCESS
3D6A  0E00     MOVLW 0x0
3D6C  5415     SUBFWB digit_cnt, W, ACCESS
3D6E  E207     BC 0x3D7E
167:                                   reply_len = sizeof (struct cdc_LineCodeing);
3D70  0E07     MOVLW 0x7
3D72  6EF3     MOVWF PRODL, ACCESS
3D74  0E02     MOVLW 0x2
3D76  CFF3     MOVFF PRODL, PLUSW2
3D78  FFDB     NOP
3D7A  0E03     MOVLW 0x3
3D7C  6ADB     CLRF PLUSW2, ACCESS
168:                               }
169:                               memcpy(EP0_Inbdp->BDADDR, (const void *) &linecodeing, reply_len);
3D7E  0E02     MOVLW 0x2
3D80  CFDB     MOVFF PLUSW2, POSTINC1
3D82  FFE6     NOP
3D84  0E03     MOVLW 0x3
3D86  CFDB     MOVFF PLUSW2, POSTINC1
3D88  FFE6     NOP
3D8A  0EC2     MOVLW 0xC2
3D8C  6EE6     MOVWF POSTINC1, ACCESS
3D8E  0E00     MOVLW 0x0
3D90  6EE6     MOVWF POSTINC1, ACCESS
3D92  C0BA     MOVFF EP0_Inbdp, FSR0L
3D94  FFE9     NOP
3D96  C0BB     MOVFF 0xBB, FSR0H
3D98  FFEA     NOP
3D9A  0E02     MOVLW 0x2
3D9C  26E9     ADDWF FSR0L, F, ACCESS
3D9E  0E00     MOVLW 0x0
3DA0  22EA     ADDWFC FSR0H, F, ACCESS
3DA2  CFEE     MOVFF POSTINC0, POSTINC1
3DA4  FFE6     NOP
3DA6  CFEF     MOVFF INDF0, POSTINC1
3DA8  FFE6     NOP
3DAA  EC62     CALL 0x46C4, 0
3DAC  F023     NOP
3DAE  6E14     MOVWF __tmp_0, ACCESS
3DB0  0E06     MOVLW 0x6
3DB2  5EE1     SUBWF FSR1L, F, ACCESS
3DB4  5014     MOVF __tmp_0, W, ACCESS
170:                               usb_ack_dat1(reply_len); // JTR common addition for STD and CLASS ACK
3DB6  0E02     MOVLW 0x2
3DB8  CFDB     MOVFF PLUSW2, POSTINC1
3DBA  FFE6     NOP
3DBC  0E03     MOVLW 0x3
3DBE  CFDB     MOVFF PLUSW2, POSTINC1
3DC0  FFE6     NOP
3DC2  EC98     CALL 0x2D30, 0
3DC4  F016     NOP
3DC6  52E5     MOVF POSTDEC1, F, ACCESS
3DC8  52E5     MOVF POSTDEC1, F, ACCESS
171:                               usb_set_in_handler(0, cdc_get_line_coding);
3DCA  0E4C     MOVLW 0x4C
3DCC  6EE6     MOVWF POSTINC1, ACCESS
3DCE  0E3E     MOVLW 0x3E
3DD0  6EE6     MOVWF POSTINC1, ACCESS
3DD2  0E00     MOVLW 0x0
3DD4  6EE6     MOVWF POSTINC1, ACCESS
3DD6  6AE6     CLRF POSTINC1, ACCESS
3DD8  EC58     CALL 0x2CB0, 0
3DDA  F016     NOP
3DDC  52E5     MOVF POSTDEC1, F, ACCESS
3DDE  52E5     MOVF POSTDEC1, F, ACCESS
3DE0  52E5     MOVF POSTDEC1, F, ACCESS
3DE2  52E5     MOVF POSTDEC1, F, ACCESS
172:                               break;
3DE4  D026     BRA 0x3E32
173:           
174:                           case CDC_SET_CONTROL_LINE_STATE: // Optional
175:                               cls = *((struct _cdc_ControlLineState *) &packet[USB_wValue]);
3DE6  CFDE     MOVFF POSTINC2, FSR0L
3DE8  FFE9     NOP
3DEA  CFDD     MOVFF POSTDEC2, FSR0H
3DEC  FFEA     NOP
3DEE  0E02     MOVLW 0x2
3DF0  26E9     ADDWF FSR0L, F, ACCESS
3DF2  0E00     MOVLW 0x0
3DF4  22EA     ADDWFC FSR0H, F, ACCESS
3DF6  CFEE     MOVFF POSTINC0, cls
3DF8  F0C9     NOP
3DFA  CFED     MOVFF POSTDEC0, 0xCA
3DFC  F0CA     NOP
176:                               usb_set_in_handler(0, cdc_set_control_line_state_status); // JTR why bother?
3DFE  0E00     MOVLW 0x0
3E00  6EE6     MOVWF POSTINC1, ACCESS
3E02  0E40     MOVLW 0x40
3E04  6EE6     MOVWF POSTINC1, ACCESS
3E06  0E00     MOVLW 0x0
3E08  6EE6     MOVWF POSTINC1, ACCESS
3E0A  6AE6     CLRF POSTINC1, ACCESS
3E0C  EC58     CALL 0x2CB0, 0
3E0E  F016     NOP
3E10  52E5     MOVF POSTDEC1, F, ACCESS
3E12  52E5     MOVF POSTDEC1, F, ACCESS
3E14  52E5     MOVF POSTDEC1, F, ACCESS
3E16  52E5     MOVF POSTDEC1, F, ACCESS
177:                               usb_ack_dat1(0); // JTR common addition for STD and CLASS ACK
3E18  0E00     MOVLW 0x0
3E1A  6EE6     MOVWF POSTINC1, ACCESS
3E1C  6AE6     CLRF POSTINC1, ACCESS
3E1E  EC98     CALL 0x2D30, 0
3E20  F016     NOP
3E22  52E5     MOVF POSTDEC1, F, ACCESS
3E24  52E5     MOVF POSTDEC1, F, ACCESS
178:                               LineStateUpdated = 1;
3E26  0100     MOVLB 0x0
3E28  0E01     MOVLW 0x1
3E2A  6FE8     MOVWF LineStateUpdated, BANKED
179:                               break;
3E2C  D002     BRA 0x3E32
180:           
181:                           case CDC_SEND_BREAK: // Optional
182:                           default:
183:                               usb_RequestError();
3E2E  ECB8     CALL 0x2D70, 0
3E30  F016     NOP
184:                       }
185:                       break;
3E32  D002     BRA 0x3E38
186:                   default:
187:                       usb_RequestError();
3E34  ECB8     CALL 0x2D70, 0
3E36  F016     NOP
188:               }
189:           }
3E38  0E04     MOVLW 0x4
3E3A  5CE1     SUBWF FSR1L, W, ACCESS
3E3C  E202     BC 0x3E42
3E3E  6AE1     CLRF FSR1L, ACCESS
3E40  52E5     MOVF POSTDEC1, F, ACCESS
3E42  6EE1     MOVWF FSR1L, ACCESS
3E44  52E5     MOVF POSTDEC1, F, ACCESS
3E46  CFE7     MOVFF INDF1, FSR2L
3E48  FFD9     NOP
3E4A  0012     RETURN 0
190:           
191:           void cdc_get_line_coding(void) {
192:               usb_unset_in_handler(0); // Unregister IN handler;
3E4C  0E00     MOVLW 0x0
3E4E  6EE6     MOVWF POSTINC1, ACCESS
3E50  6AE6     CLRF POSTINC1, ACCESS
3E52  0E00     MOVLW 0x0
3E54  6EE6     MOVWF POSTINC1, ACCESS
3E56  6AE6     CLRF POSTINC1, ACCESS
3E58  EC58     CALL 0x2CB0, 0
3E5A  F016     NOP
3E5C  52E5     MOVF POSTDEC1, F, ACCESS
3E5E  52E5     MOVF POSTDEC1, F, ACCESS
3E60  52E5     MOVF POSTDEC1, F, ACCESS
3E62  52E5     MOVF POSTDEC1, F, ACCESS
193:           }
3E64  0012     RETURN 0
194:           
195:           void cdc_set_line_coding_data(void) { // JTR handling an OUT token In the CDC stack this is the only function that handles an OUT data stage.
3E66  CFD9     MOVFF FSR2L, POSTINC1
3E68  FFE6     NOP
3E6A  CFE1     MOVFF FSR1L, FSR2L
3E6C  FFD9     NOP
3E6E  0E08     MOVLW 0x8
3E70  26E1     ADDWF FSR1L, F, ACCESS
196:               unsigned long dwBaud, dwBaudrem;
197:           
198:               memcpy(&linecodeing, (const void *) EP0_Outbdp->BDADDR, sizeof (struct cdc_LineCodeing));
3E72  0E07     MOVLW 0x7
3E74  6EE6     MOVWF POSTINC1, ACCESS
3E76  6AE6     CLRF POSTINC1, ACCESS
3E78  C0B8     MOVFF EP0_Outbdp, FSR0L
3E7A  FFE9     NOP
3E7C  C0B9     MOVFF 0xB9, FSR0H
3E7E  FFEA     NOP
3E80  0E02     MOVLW 0x2
3E82  26E9     ADDWF FSR0L, F, ACCESS
3E84  0E00     MOVLW 0x0
3E86  22EA     ADDWFC FSR0H, F, ACCESS
3E88  CFEE     MOVFF POSTINC0, POSTINC1
3E8A  FFE6     NOP
3E8C  CFEF     MOVFF INDF0, POSTINC1
3E8E  FFE6     NOP
3E90  0EC2     MOVLW 0xC2
3E92  6EE6     MOVWF POSTINC1, ACCESS
3E94  0E00     MOVLW 0x0
3E96  6EE6     MOVWF POSTINC1, ACCESS
3E98  EC62     CALL 0x46C4, 0
3E9A  F023     NOP
3E9C  6E14     MOVWF __tmp_0, ACCESS
3E9E  0E06     MOVLW 0x6
3EA0  5EE1     SUBWF FSR1L, F, ACCESS
3EA2  5014     MOVF __tmp_0, W, ACCESS
199:           
200:               dwBaud = BAUDCLOCK_FREQ / linecodeing.dwDTERate;
3EA4  6A14     CLRF __tmp_0, ACCESS
3EA6  0E1B     MOVLW 0x1B
3EA8  6E15     MOVWF digit_cnt, ACCESS
3EAA  0EB7     MOVLW 0xB7
3EAC  6E16     MOVWF prefix_cnt, ACCESS
3EAE  6A17     CLRF sign_char, ACCESS
3EB0  C014     MOVFF __tmp_0, i
3EB2  F004     NOP
3EB4  C015     MOVFF digit_cnt, precision
3EB6  F005     NOP
3EB8  C016     MOVFF prefix_cnt, pUEP
3EBA  F006     NOP
3EBC  C017     MOVFF sign_char, size
3EBE  F007     NOP
3EC0  C0C2     MOVFF linecodeing, cval
3EC2  F009     NOP
3EC4  C0C3     MOVFF 0xC3, larg
3EC6  F00A     NOP
3EC8  C0C4     MOVFF 0xC4, 0xB
3ECA  F00B     NOP
3ECC  C0C5     MOVFF 0xC5, 0xC
3ECE  F00C     NOP
3ED0  EC9B     CALL 0x4B36, 0
3ED2  F025     NOP
3ED4  C004     MOVFF i, POSTINC2
3ED6  FFDE     NOP
3ED8  C005     MOVFF precision, POSTINC2
3EDA  FFDE     NOP
3EDC  C006     MOVFF pUEP, POSTINC2
3EDE  FFDE     NOP
3EE0  C007     MOVFF size, POSTDEC2
3EE2  FFDD     NOP
3EE4  52DD     MOVF POSTDEC2, F, ACCESS
3EE6  52DD     MOVF POSTDEC2, F, ACCESS
201:               dwBaudrem = BAUDCLOCK_FREQ % linecodeing.dwDTERate;
3EE8  C0C2     MOVFF linecodeing, cval
3EEA  F009     NOP
3EEC  C0C3     MOVFF 0xC3, larg
3EEE  F00A     NOP
3EF0  C0C4     MOVFF 0xC4, 0xB
3EF2  F00B     NOP
3EF4  C0C5     MOVFF 0xC5, 0xC
3EF6  F00C     NOP
3EF8  6A04     CLRF i, ACCESS
3EFA  0E1B     MOVLW 0x1B
3EFC  6E05     MOVWF precision, ACCESS
3EFE  0EB7     MOVLW 0xB7
3F00  6E06     MOVWF pUEP, ACCESS
3F02  6A07     CLRF size, ACCESS
3F04  EC9B     CALL 0x4B36, 0
3F06  F025     NOP
3F08  0E04     MOVLW 0x4
3F0A  C000     MOVFF i, PLUSW2
3F0C  FFDB     NOP
3F0E  0E05     MOVLW 0x5
3F10  C001     MOVFF c, PLUSW2
3F12  FFDB     NOP
3F14  0E06     MOVLW 0x6
3F16  C002     MOVFF c2, PLUSW2
3F18  FFDB     NOP
3F1A  0E07     MOVLW 0x7
3F1C  C003     MOVFF n, PLUSW2
3F1E  FFDB     NOP
202:               if (linecodeing.dwDTERate > (dwBaudrem << 1))
3F20  0E04     MOVLW 0x4
3F22  CFDB     MOVFF PLUSW2, __tmp_0
3F24  F014     NOP
3F26  0E05     MOVLW 0x5
3F28  CFDB     MOVFF PLUSW2, digit_cnt
3F2A  F015     NOP
3F2C  0E06     MOVLW 0x6
3F2E  CFDB     MOVFF PLUSW2, prefix_cnt
3F30  F016     NOP
3F32  0E07     MOVLW 0x7
3F34  CFDB     MOVFF PLUSW2, sign_char
3F36  F017     NOP
3F38  0E01     MOVLW 0x1
3F3A  0B1F     ANDLW 0x1F
3F3C  E007     BZ 0x3F4C
3F3E  90D8     BCF STATUS, 0, ACCESS
3F40  3614     RLCF __tmp_0, F, ACCESS
3F42  3615     RLCF digit_cnt, F, ACCESS
3F44  3616     RLCF prefix_cnt, F, ACCESS
3F46  3617     RLCF sign_char, F, ACCESS
3F48  06E8     DECF WREG, F, ACCESS
3F4A  E1F9     BNZ 0x3F3E
3F4C  0100     MOVLB 0x0
3F4E  51C2     MOVF linecodeing, W, BANKED
3F50  5C14     SUBWF __tmp_0, W, ACCESS
3F52  0100     MOVLB 0x0
3F54  51C3     MOVF 0xC3, W, BANKED
3F56  5815     SUBWFB digit_cnt, W, ACCESS
3F58  0100     MOVLB 0x0
3F5A  51C4     MOVF 0xC4, W, BANKED
3F5C  5816     SUBWFB prefix_cnt, W, ACCESS
3F5E  0100     MOVLB 0x0
3F60  51C5     MOVF 0xC5, W, BANKED
3F62  5817     SUBWFB sign_char, W, ACCESS
3F64  E209     BC 0x3F78
203:                   dwBaud--;
3F66  CFD9     MOVFF FSR2L, FSR0L
3F68  FFE9     NOP
3F6A  CFDA     MOVFF FSR2H, FSR0H
3F6C  FFEA     NOP
3F6E  06EE     DECF POSTINC0, F, ACCESS
3F70  0E00     MOVLW 0x0
3F72  5AEE     SUBWFB POSTINC0, F, ACCESS
3F74  5AEE     SUBWFB POSTINC0, F, ACCESS
3F76  5AEE     SUBWFB POSTINC0, F, ACCESS
204:           
205:               UART_BAUD_setup(dwBaud);
206:           
207:               usb_unset_out_handler(0); // Unregister OUT handler; JTR serious bug fix in macro!
3F78  0E00     MOVLW 0x0
3F7A  6EE6     MOVWF POSTINC1, ACCESS
3F7C  6AE6     CLRF POSTINC1, ACCESS
3F7E  0E00     MOVLW 0x0
3F80  6EE6     MOVWF POSTINC1, ACCESS
3F82  6AE6     CLRF POSTINC1, ACCESS
3F84  EC76     CALL 0x2CEC, 0
3F86  F016     NOP
3F88  52E5     MOVF POSTDEC1, F, ACCESS
3F8A  52E5     MOVF POSTDEC1, F, ACCESS
3F8C  52E5     MOVF POSTDEC1, F, ACCESS
3F8E  52E5     MOVF POSTDEC1, F, ACCESS
208:               usb_set_in_handler(0, cdc_set_line_coding_status); // JTR why bother?
3F90  0EE6     MOVLW 0xE6
3F92  6EE6     MOVWF POSTINC1, ACCESS
3F94  0E3F     MOVLW 0x3F
3F96  6EE6     MOVWF POSTINC1, ACCESS
3F98  0E00     MOVLW 0x0
3F9A  6EE6     MOVWF POSTINC1, ACCESS
3F9C  6AE6     CLRF POSTINC1, ACCESS
3F9E  EC58     CALL 0x2CB0, 0
3FA0  F016     NOP
3FA2  52E5     MOVF POSTDEC1, F, ACCESS
3FA4  52E5     MOVF POSTDEC1, F, ACCESS
3FA6  52E5     MOVF POSTDEC1, F, ACCESS
3FA8  52E5     MOVF POSTDEC1, F, ACCESS
209:               usb_ack_dat1(0); // JTR common addition for STD and CLASS ACK
3FAA  0E00     MOVLW 0x0
3FAC  6EE6     MOVWF POSTINC1, ACCESS
3FAE  6AE6     CLRF POSTINC1, ACCESS
3FB0  EC98     CALL 0x2D30, 0
3FB2  F016     NOP
3FB4  52E5     MOVF POSTDEC1, F, ACCESS
3FB6  52E5     MOVF POSTDEC1, F, ACCESS
210:           
211:               // JTR This part of the USB-CDC stack is worth highlighting
212:               // This is the only place that we have an OUT DATA packet on
213:               // EP0. At this point it has been completed. This stack unlike
214:               // the microchip stack does not have a common IN or OUT data
215:               // packet complete tail and therefore it is the responsibility
216:               // of each section to ensure that EP0 is set-up correctly for
217:               // the next setup packet.
218:           
219:           
220:               //  Force EP0 OUT to the DAT0 state
221:               //  after we have all our data packets.
222:               EP0_Outbdp->BDCNT = USB_EP0_BUFFER_SIZE;
3FB8  C0B8     MOVFF EP0_Outbdp, FSR0L
3FBA  FFE9     NOP
3FBC  C0B9     MOVFF 0xB9, FSR0H
3FBE  FFEA     NOP
3FC0  52EE     MOVF POSTINC0, F, ACCESS
3FC2  0E08     MOVLW 0x8
3FC4  6EEF     MOVWF INDF0, ACCESS
223:               EP0_Outbdp->BDSTAT = UOWN | DTSEN;
3FC6  C0B8     MOVFF EP0_Outbdp, FSR0L
3FC8  FFE9     NOP
3FCA  C0B9     MOVFF 0xB9, FSR0H
3FCC  FFEA     NOP
3FCE  0E88     MOVLW 0x88
3FD0  6EEF     MOVWF INDF0, ACCESS
224:           }
3FD2  0E08     MOVLW 0x8
3FD4  5CE1     SUBWF FSR1L, W, ACCESS
3FD6  E202     BC 0x3FDC
3FD8  6AE1     CLRF FSR1L, ACCESS
3FDA  52E5     MOVF POSTDEC1, F, ACCESS
3FDC  6EE1     MOVWF FSR1L, ACCESS
3FDE  52E5     MOVF POSTDEC1, F, ACCESS
3FE0  CFE7     MOVFF INDF1, FSR2L
3FE2  FFD9     NOP
3FE4  0012     RETURN 0
225:           
226:           void cdc_set_line_coding_status(void) {
227:               usb_unset_in_handler(0);
3FE6  0E00     MOVLW 0x0
3FE8  6EE6     MOVWF POSTINC1, ACCESS
3FEA  6AE6     CLRF POSTINC1, ACCESS
3FEC  0E00     MOVLW 0x0
3FEE  6EE6     MOVWF POSTINC1, ACCESS
3FF0  6AE6     CLRF POSTINC1, ACCESS
3FF2  EC58     CALL 0x2CB0, 0
3FF4  F016     NOP
3FF6  52E5     MOVF POSTDEC1, F, ACCESS
3FF8  52E5     MOVF POSTDEC1, F, ACCESS
3FFA  52E5     MOVF POSTDEC1, F, ACCESS
3FFC  52E5     MOVF POSTDEC1, F, ACCESS
228:           }
3FFE  0012     RETURN 0
229:           
230:           void cdc_set_control_line_state_status(void) {
231:               usb_unset_in_handler(0);
4000  0E00     MOVLW 0x0
4002  6EE6     MOVWF POSTINC1, ACCESS
4004  6AE6     CLRF POSTINC1, ACCESS
4006  0E00     MOVLW 0x0
4008  6EE6     MOVWF POSTINC1, ACCESS
400A  6AE6     CLRF POSTINC1, ACCESS
400C  EC58     CALL 0x2CB0, 0
400E  F016     NOP
4010  52E5     MOVF POSTDEC1, F, ACCESS
4012  52E5     MOVF POSTDEC1, F, ACCESS
4014  52E5     MOVF POSTDEC1, F, ACCESS
4016  52E5     MOVF POSTDEC1, F, ACCESS
232:           }
4018  0012     RETURN 0
233:           
234:           /*****************************************************************************/
235:           void WaitOutReady() // JTR2 added reduced overhead
236:           {
237:               while ((CDC_Outbdp->BDSTAT & UOWN));
401A  C0D3     MOVFF CDC_Outbdp, FSR0L
401C  FFE9     NOP
401E  C0D4     MOVFF 0xD4, FSR0H
4020  FFEA     NOP
4022  50EF     MOVF INDF0, W, ACCESS
4024  0B80     ANDLW 0x80
4026  E001     BZ 0x402A
4028  D7F8     BRA WaitOutReady
238:           }
402A  0012     RETURN 0
239:           
240:           /******************************************************************************/
241:           
242:           void WaitInReady() // JTR2 added reduced overhead
243:           {
244:               while ((CDC_Inbdp->BDSTAT & UOWN));
402C  C0D5     MOVFF CDC_Inbdp, FSR0L
402E  FFE9     NOP
4030  C0D6     MOVFF 0xD6, FSR0H
4032  FFEA     NOP
4034  50EF     MOVF INDF0, W, ACCESS
4036  0B80     ANDLW 0x80
4038  E001     BZ 0x403C
403A  D7F8     BRA WaitInReady
245:           }//end WaitInReady
403C  0012     RETURN 0
246:           
247:           /******************************************************************************/
248:           BYTE getOutReady(void) {
249:           
250:               return !(CDC_Outbdp->BDSTAT & UOWN); // Do we have a packet from host?
403E  C0D3     MOVFF CDC_Outbdp, FSR0L
4040  FFE9     NOP
4042  C0D4     MOVFF 0xD4, FSR0H
4044  FFEA     NOP
4046  50EF     MOVF INDF0, W, ACCESS
4048  0B80     ANDLW 0x80
404A  E002     BZ 0x4050
404C  0E00     MOVLW 0x0
404E  D001     BRA 0x4052
4050  0E01     MOVLW 0x1
4052  D000     BRA 0x4054
251:           }
4054  0012     RETURN 0
252:           
253:           /******************************************************************************/
254:           BYTE getInReady(void) {
255:           
256:               return !(CDC_Inbdp->BDSTAT & UOWN); // Is the CDC In buffer ready?
4056  C0D5     MOVFF CDC_Inbdp, FSR0L
4058  FFE9     NOP
405A  C0D6     MOVFF 0xD6, FSR0H
405C  FFEA     NOP
405E  50EF     MOVF INDF0, W, ACCESS
4060  0B80     ANDLW 0x80
4062  E002     BZ 0x4068
4064  0E00     MOVLW 0x0
4066  D001     BRA 0x406A
4068  0E01     MOVLW 0x1
406A  D000     BRA 0x406C
257:           }
406C  0012     RETURN 0
258:           
259:           /******************************************************************************/
260:           BYTE getda_cdc(void) {
261:           
262:               CDCFunctionError = 0;
406E  0100     MOVLB 0x0
4070  6BD7     CLRF CDCFunctionError, BANKED
263:           
264:               WaitOutReady();
4072  DFD3     RCALL WaitOutReady
265:           
266:               if ((IsOutBufferA & 1)) {
4074  0100     MOVLB 0x0
4076  A1CE     BTFSS IsOutBufferA, 0, BANKED
4078  D012     BRA 0x409E
267:                   OutPtr = &cdc_Out_bufferA[0];
407A  0100     MOVLB 0x0
407C  0E00     MOVLW 0x0
407E  6FD1     MOVWF OutPtr, BANKED
4080  0E06     MOVLW 0x6
4082  6FD2     MOVWF 0xD2, BANKED
268:                   CDC_Outbdp->BDADDR = &cdc_Out_bufferB[0];
4084  C0D3     MOVFF CDC_Outbdp, FSR0L
4086  FFE9     NOP
4088  C0D4     MOVFF 0xD4, FSR0H
408A  FFEA     NOP
408C  0E02     MOVLW 0x2
408E  26E9     ADDWF FSR0L, F, ACCESS
4090  0E00     MOVLW 0x0
4092  22EA     ADDWFC FSR0H, F, ACCESS
4094  0E40     MOVLW 0x40
4096  6EEE     MOVWF POSTINC0, ACCESS
4098  0E06     MOVLW 0x6
409A  6EED     MOVWF POSTDEC0, ACCESS
269:               } else {
409C  D011     BRA 0x40C0
270:                   OutPtr = &cdc_Out_bufferB[0];
409E  0100     MOVLB 0x0
40A0  0E40     MOVLW 0x40
40A2  6FD1     MOVWF OutPtr, BANKED
40A4  0E06     MOVLW 0x6
40A6  6FD2     MOVWF 0xD2, BANKED
271:                   CDC_Outbdp->BDADDR = &cdc_Out_bufferA[0];
40A8  C0D3     MOVFF CDC_Outbdp, FSR0L
40AA  FFE9     NOP
40AC  C0D4     MOVFF 0xD4, FSR0H
40AE  FFEA     NOP
40B0  0E02     MOVLW 0x2
40B2  26E9     ADDWF FSR0L, F, ACCESS
40B4  0E00     MOVLW 0x0
40B6  22EA     ADDWFC FSR0H, F, ACCESS
40B8  0E00     MOVLW 0x0
40BA  6EEE     MOVWF POSTINC0, ACCESS
40BC  0E06     MOVLW 0x6
40BE  6EED     MOVWF POSTDEC0, ACCESS
272:               }
273:               IsOutBufferA ^= 0xFF;
40C0  0100     MOVLB 0x0
40C2  1FCE     COMF IsOutBufferA, F, BANKED
274:               cdc_Out_len = CDC_Outbdp->BDCNT;
40C4  C0D3     MOVFF CDC_Outbdp, FSR0L
40C6  FFE9     NOP
40C8  C0D4     MOVFF 0xD4, FSR0H
40CA  FFEA     NOP
40CC  52EE     MOVF POSTINC0, F, ACCESS
40CE  CFEF     MOVFF INDF0, cdc_Out_len
40D0  F0CC     NOP
275:               CDC_Outbdp->BDCNT = CDC_BUFFER_SIZE;
40D2  C0D3     MOVFF CDC_Outbdp, FSR0L
40D4  FFE9     NOP
40D6  C0D4     MOVFF 0xD4, FSR0H
40D8  FFEA     NOP
40DA  52EE     MOVF POSTINC0, F, ACCESS
40DC  0E40     MOVLW 0x40
40DE  6EEF     MOVWF INDF0, ACCESS
276:               CDC_Outbdp->BDSTAT = ((CDC_Outbdp->BDSTAT ^ DTS) & DTS) | UOWN | DTSEN;
40E0  C0D3     MOVFF CDC_Outbdp, FSR0L
40E2  FFE9     NOP
40E4  C0D4     MOVFF 0xD4, FSR0H
40E6  FFEA     NOP
40E8  50EF     MOVF INDF0, W, ACCESS
40EA  0A40     XORLW 0x40
40EC  0B40     ANDLW 0x40
40EE  0980     IORLW 0x80
40F0  0908     IORLW 0x8
40F2  6EE6     MOVWF POSTINC1, ACCESS
40F4  C0D3     MOVFF CDC_Outbdp, FSR0L
40F6  FFE9     NOP
40F8  C0D4     MOVFF 0xD4, FSR0H
40FA  FFEA     NOP
40FC  52E5     MOVF POSTDEC1, F, ACCESS
40FE  50E7     MOVF INDF1, W, ACCESS
4100  6EEF     MOVWF INDF0, ACCESS
277:           #ifndef USB_INTERRUPTS
278:               usb_handler();
279:           #endif
280:               return cdc_Out_len;
4102  0100     MOVLB 0x0
4104  51CC     MOVF cdc_Out_len, W, BANKED
4106  D000     BRA 0x4108
281:           }//end getCDC_Out_ArmNext
4108  0012     RETURN 0
282:           
283:           BYTE putda_cdc(BYTE count) {
410A  CFD9     MOVFF FSR2L, POSTINC1
410C  FFE6     NOP
410E  CFE1     MOVFF FSR1L, FSR2L
4110  FFD9     NOP
284:           
285:               //    CDCFunctionError = 0;
286:               //    WaitInReady();
287:               while ((CDC_Inbdp->BDSTAT & UOWN));
4112  C0D5     MOVFF CDC_Inbdp, FSR0L
4114  FFE9     NOP
4116  C0D6     MOVFF 0xD6, FSR0H
4118  FFEA     NOP
411A  50EF     MOVF INDF0, W, ACCESS
411C  0B80     ANDLW 0x80
411E  E001     BZ 0x4122
4120  D7F8     BRA 0x4112
288:               if (IsInBufferA) {
4122  0100     MOVLB 0x0
4124  51CD     MOVF IsInBufferA, W, BANKED
4126  E012     BZ 0x414C
289:                   CDC_Inbdp->BDADDR = cdc_In_bufferA;
4128  C0D5     MOVFF CDC_Inbdp, FSR0L
412A  FFE9     NOP
412C  C0D6     MOVFF 0xD6, FSR0H
412E  FFEA     NOP
4130  0E02     MOVLW 0x2
4132  26E9     ADDWF FSR0L, F, ACCESS
4134  0E00     MOVLW 0x0
4136  22EA     ADDWFC FSR0H, F, ACCESS
4138  0E80     MOVLW 0x80
413A  6EEE     MOVWF POSTINC0, ACCESS
413C  0E05     MOVLW 0x5
413E  6EED     MOVWF POSTDEC0, ACCESS
290:                   InPtr = cdc_In_bufferB;
4140  0100     MOVLB 0x0
4142  0EC0     MOVLW 0xC0
4144  6FCF     MOVWF InPtr, BANKED
4146  0E05     MOVLW 0x5
4148  6FD0     MOVWF 0xD0, BANKED
291:               } else {
414A  D011     BRA 0x416E
292:                   CDC_Inbdp->BDADDR = cdc_In_bufferB;
414C  C0D5     MOVFF CDC_Inbdp, FSR0L
414E  FFE9     NOP
4150  C0D6     MOVFF 0xD6, FSR0H
4152  FFEA     NOP
4154  0E02     MOVLW 0x2
4156  26E9     ADDWF FSR0L, F, ACCESS
4158  0E00     MOVLW 0x0
415A  22EA     ADDWFC FSR0H, F, ACCESS
415C  0EC0     MOVLW 0xC0
415E  6EEE     MOVWF POSTINC0, ACCESS
4160  0E05     MOVLW 0x5
4162  6EED     MOVWF POSTDEC0, ACCESS
293:                   InPtr = cdc_In_bufferA;
4164  0100     MOVLB 0x0
4166  0E80     MOVLW 0x80
4168  6FCF     MOVWF InPtr, BANKED
416A  0E05     MOVLW 0x5
416C  6FD0     MOVWF 0xD0, BANKED
294:               }
295:               CDC_Inbdp->BDCNT = count;
416E  C0D5     MOVFF CDC_Inbdp, FSR0L
4170  FFE9     NOP
4172  C0D6     MOVFF 0xD6, FSR0H
4174  FFEA     NOP
4176  52EE     MOVF POSTINC0, F, ACCESS
4178  0EFE     MOVLW 0xFE
417A  CFDB     MOVFF PLUSW2, INDF0
417C  FFEF     NOP
296:               CDC_Inbdp->BDSTAT = ((CDC_Inbdp->BDSTAT ^ DTS) & DTS) | UOWN | DTSEN;
417E  C0D5     MOVFF CDC_Inbdp, FSR0L
4180  FFE9     NOP
4182  C0D6     MOVFF 0xD6, FSR0H
4184  FFEA     NOP
4186  50EF     MOVF INDF0, W, ACCESS
4188  0A40     XORLW 0x40
418A  0B40     ANDLW 0x40
418C  0980     IORLW 0x80
418E  0908     IORLW 0x8
4190  6EE6     MOVWF POSTINC1, ACCESS
4192  C0D5     MOVFF CDC_Inbdp, FSR0L
4194  FFE9     NOP
4196  C0D6     MOVFF 0xD6, FSR0H
4198  FFEA     NOP
419A  52E5     MOVF POSTDEC1, F, ACCESS
419C  50E7     MOVF INDF1, W, ACCESS
419E  6EEF     MOVWF INDF0, ACCESS
297:               IsInBufferA ^= 0xFF;
41A0  0100     MOVLB 0x0
41A2  1FCD     COMF IsInBufferA, F, BANKED
298:           #ifndef USB_INTERRUPTS
299:               usb_handler();
300:           #endif
301:               return 0; //CDCFunctionError;
41A4  0E00     MOVLW 0x0
41A6  D000     BRA 0x41A8
302:           }
41A8  52E5     MOVF POSTDEC1, F, ACCESS
41AA  CFE7     MOVFF INDF1, FSR2L
41AC  FFD9     NOP
41AE  0012     RETURN 0
303:           
304:           void SendZLP(void) {
305:               putda_cdc(0);
41B0  6AE6     CLRF POSTINC1, ACCESS
41B2  DFAB     RCALL putda_cdc
41B4  52E5     MOVF POSTDEC1, F, ACCESS
306:           }
41B6  0012     RETURN 0
307:           
308:           /******************************************************************************/
309:           void CDC_Flush_In_Now(void) {
310:               if (cdc_In_len > 0) {
41B8  0100     MOVLB 0x0
41BA  51CB     MOVF cdc_In_len, W, BANKED
41BC  0800     SUBLW 0x0
41BE  E216     BC 0x41EC
311:                   while (!getInReady());
41C0  DF4A     RCALL getInReady
41C2  0900     IORLW 0x0
41C4  E101     BNZ 0x41C8
41C6  D7FC     BRA 0x41C0
312:                   putda_cdc(cdc_In_len);
41C8  C0CB     MOVFF cdc_In_len, POSTINC1
41CA  FFE6     NOP
41CC  DF9E     RCALL putda_cdc
41CE  52E5     MOVF POSTDEC1, F, ACCESS
313:                   if (cdc_In_len == CDC_BUFFER_SIZE) {
41D0  0E40     MOVLW 0x40
41D2  0100     MOVLB 0x0
41D4  5DCB     SUBWF cdc_In_len, W, BANKED
41D6  E104     BNZ 0x41E0
314:                       ZLPpending = 1;
41D8  0100     MOVLB 0x0
41DA  0E01     MOVLW 0x1
41DC  6FEA     MOVWF ZLPpending, BANKED
315:                   } else {
41DE  D002     BRA 0x41E4
316:                       ZLPpending = 0;
41E0  0100     MOVLB 0x0
41E2  6BEA     CLRF ZLPpending, BANKED
317:                   }
318:                   cdc_In_len = 0;
41E4  0100     MOVLB 0x0
41E6  6BCB     CLRF cdc_In_len, BANKED
319:                   cdc_timeout_count = 0;
41E8  0100     MOVLB 0x0
41EA  6BE9     CLRF cdc_timeout_count, BANKED
320:               }
321:           }
41EC  0012     RETURN 0
322:           
323:           /******************************************************************************/
324:           void CDCFlushOnTimeout(void) {
325:           
326:               if (cdc_timeout_count >= CDC_FLUSH_MS) { // For timeout value see: cdc_config.h -> [hardware] -> CDC_FLUSH_MS
41EE  0E04     MOVLW 0x4
41F0  0100     MOVLB 0x0
41F2  5DE9     SUBWF cdc_timeout_count, W, BANKED
41F4  E328     BNC 0x4246
327:           
328:                   if (cdc_In_len > 0) {
41F6  0100     MOVLB 0x0
41F8  51CB     MOVF cdc_In_len, W, BANKED
41FA  0800     SUBLW 0x0
41FC  E219     BC 0x4230
329:                       if ((lock == 0) && getInReady()) {
41FE  0100     MOVLB 0x0
4200  51EB     MOVF lock, W, BANKED
4202  E115     BNZ 0x422E
4204  DF28     RCALL getInReady
4206  0900     IORLW 0x0
4208  E012     BZ 0x422E
330:                           putda_cdc(cdc_In_len);
420A  C0CB     MOVFF cdc_In_len, POSTINC1
420C  FFE6     NOP
420E  DF7D     RCALL putda_cdc
4210  52E5     MOVF POSTDEC1, F, ACCESS
331:                           if (cdc_In_len == CDC_BUFFER_SIZE) {
4212  0E40     MOVLW 0x40
4214  0100     MOVLB 0x0
4216  5DCB     SUBWF cdc_In_len, W, BANKED
4218  E104     BNZ 0x4222
332:                               ZLPpending = 1;
421A  0100     MOVLB 0x0
421C  0E01     MOVLW 0x1
421E  6FEA     MOVWF ZLPpending, BANKED
333:                           } else {
4220  D002     BRA 0x4226
334:                               ZLPpending = 0;
4222  0100     MOVLB 0x0
4224  6BEA     CLRF ZLPpending, BANKED
335:                           }
336:                           cdc_In_len = 0;
4226  0100     MOVLB 0x0
4228  6BCB     CLRF cdc_In_len, BANKED
337:                           cdc_timeout_count = 0;
422A  0100     MOVLB 0x0
422C  6BE9     CLRF cdc_timeout_count, BANKED
338:                       }
339:                   } else if (ZLPpending) {
422E  D00A     BRA 0x4244
4230  0100     MOVLB 0x0
4232  51EA     MOVF ZLPpending, W, BANKED
4234  E007     BZ 0x4244
340:                       putda_cdc(0);
4236  6AE6     CLRF POSTINC1, ACCESS
4238  DF68     RCALL putda_cdc
423A  52E5     MOVF POSTDEC1, F, ACCESS
341:                       ZLPpending = 0;
423C  0100     MOVLB 0x0
423E  6BEA     CLRF ZLPpending, BANKED
342:                       cdc_timeout_count = 0;
4240  0100     MOVLB 0x0
4242  6BE9     CLRF cdc_timeout_count, BANKED
343:                   }
344:               } else {
4244  D002     BRA 0x424A
345:                   cdc_timeout_count++;
4246  0100     MOVLB 0x0
4248  2BE9     INCF cdc_timeout_count, F, BANKED
346:               }
347:           }
424A  0012     RETURN 0
348:           
349:           /******************************************************************************/
350:           void putc_cdc(BYTE c) {
424C  CFD9     MOVFF FSR2L, POSTINC1
424E  FFE6     NOP
4250  CFE1     MOVFF FSR1L, FSR2L
4252  FFD9     NOP
351:               lock = 1; // Stops CDCFlushOnTimeout() from sending per chance it is on interrupts.
4254  0100     MOVLB 0x0
4256  0E01     MOVLW 0x1
4258  6FEB     MOVWF lock, BANKED
352:               *InPtr = c;
425A  0EFE     MOVLW 0xFE
425C  50DB     MOVF PLUSW2, W, ACCESS
425E  C0CF     MOVFF InPtr, FSR0L
4260  FFE9     NOP
4262  C0D0     MOVFF 0xD0, FSR0H
4264  FFEA     NOP
4266  6EEF     MOVWF INDF0, ACCESS
353:               InPtr++;
4268  0100     MOVLB 0x0
426A  2BCF     INCF InPtr, F, BANKED
426C  0E00     MOVLW 0x0
426E  23D0     ADDWFC 0xD0, F, BANKED
354:               cdc_In_len++;
4270  0100     MOVLB 0x0
4272  2BCB     INCF cdc_In_len, F, BANKED
355:               ZLPpending = 0;
4274  0100     MOVLB 0x0
4276  6BEA     CLRF ZLPpending, BANKED
356:               if (cdc_In_len == CDC_BUFFER_SIZE) {
4278  0E40     MOVLW 0x40
427A  0100     MOVLB 0x0
427C  5DCB     SUBWF cdc_In_len, W, BANKED
427E  E109     BNZ 0x4292
357:                   putda_cdc(cdc_In_len); // This will stall tranfers if both buffers are full then return when a buffer is available.
4280  C0CB     MOVFF cdc_In_len, POSTINC1
4282  FFE6     NOP
4284  DF42     RCALL putda_cdc
4286  52E5     MOVF POSTDEC1, F, ACCESS
358:                   cdc_In_len = 0;
4288  0100     MOVLB 0x0
428A  6BCB     CLRF cdc_In_len, BANKED
359:                   ZLPpending = 1; // timeout handled in the SOF handler below.
428C  0100     MOVLB 0x0
428E  0E01     MOVLW 0x1
4290  6FEA     MOVWF ZLPpending, BANKED
360:               }
361:               lock = 0;
4292  0100     MOVLB 0x0
4294  6BEB     CLRF lock, BANKED
362:               cdc_timeout_count = 0; //setup timer to throw data if the buffer doesn't fill
4296  0100     MOVLB 0x0
4298  6BE9     CLRF cdc_timeout_count, BANKED
363:           }
429A  52E5     MOVF POSTDEC1, F, ACCESS
429C  CFE7     MOVFF INDF1, FSR2L
429E  FFD9     NOP
42A0  0012     RETURN 0
364:           
365:           /******************************************************************************/
366:           // Waits for a byte to be available and returns that byte as a
367:           // function return value. The byte is removed from the CDC OUT queue.
368:           // No return count is required as this function always returns one byte.
369:           
370:           BYTE getc_cdc(void) { // Must be used only in double buffer mode.
42A2  CFD9     MOVFF FSR2L, POSTINC1
42A4  FFE6     NOP
42A6  CFE1     MOVFF FSR1L, FSR2L
42A8  FFD9     NOP
42AA  52E6     MOVF POSTINC1, F, ACCESS
371:               BYTE c = 0;
42AC  6ADF     CLRF INDF2, ACCESS
372:           
373:               if (cdc_Out_len == 0) {
42AE  0100     MOVLB 0x0
42B0  51CC     MOVF cdc_Out_len, W, BANKED
42B2  E106     BNZ 0x42C0
374:                   do {
375:                       cdc_Out_len = getda_cdc();
42B4  DEDC     RCALL getda_cdc
42B6  0100     MOVLB 0x0
42B8  6FCC     MOVWF cdc_Out_len, BANKED
376:                   } while (cdc_Out_len == 0); // Skip any ZLP
42BA  0100     MOVLB 0x0
42BC  51CC     MOVF cdc_Out_len, W, BANKED
42BE  E0FA     BZ 0x42B4
377:               }
378:               c = *OutPtr;
42C0  C0D1     MOVFF OutPtr, FSR0L
42C2  FFE9     NOP
42C4  C0D2     MOVFF 0xD2, FSR0H
42C6  FFEA     NOP
42C8  CFEF     MOVFF INDF0, INDF2
42CA  FFDF     NOP
379:               OutPtr++;
42CC  0100     MOVLB 0x0
42CE  2BD1     INCF OutPtr, F, BANKED
42D0  0E00     MOVLW 0x0
42D2  23D2     ADDWFC 0xD2, F, BANKED
380:               cdc_Out_len--;
42D4  0100     MOVLB 0x0
42D6  07CC     DECF cdc_Out_len, F, BANKED
381:               return c;
42D8  50DF     MOVF INDF2, W, ACCESS
42DA  D000     BRA 0x42DC
382:           }
42DC  52E5     MOVF POSTDEC1, F, ACCESS
42DE  52E5     MOVF POSTDEC1, F, ACCESS
42E0  CFE7     MOVFF INDF1, FSR2L
42E2  FFD9     NOP
42E4  0012     RETURN 0
383:           
384:           /******************************************************************************/
385:           // Checks to see if there is a byte available in the CDC buffer.
386:           // If so, it returns that byte at the dereferenced pointer *C
387:           // and the function returns a count of 1. The byte is effectively
388:           // removed from the queue.
389:           // IF no byte is available function returns immediately with a count of zero.
390:           
391:           BYTE poll_getc_cdc(BYTE * c) { // Must be used only in double buffer mode.
42E6  CFD9     MOVFF FSR2L, POSTINC1
42E8  FFE6     NOP
42EA  CFE1     MOVFF FSR1L, FSR2L
42EC  FFD9     NOP
392:           
393:               if (cdc_Out_len) { // Do we have a byte waiting?
42EE  0100     MOVLB 0x0
42F0  51CC     MOVF cdc_Out_len, W, BANKED
42F2  E017     BZ 0x4322
394:                   *c = *OutPtr; // pass it on and adjust OutPtr and count
42F4  C0D1     MOVFF OutPtr, FSR0L
42F6  FFE9     NOP
42F8  C0D2     MOVFF 0xD2, FSR0H
42FA  FFEA     NOP
42FC  50EF     MOVF INDF0, W, ACCESS
42FE  6EE6     MOVWF POSTINC1, ACCESS
4300  0EFD     MOVLW 0xFD
4302  CFDB     MOVFF PLUSW2, FSR0L
4304  FFE9     NOP
4306  0EFE     MOVLW 0xFE
4308  CFDB     MOVFF PLUSW2, FSR0H
430A  FFEA     NOP
430C  52E5     MOVF POSTDEC1, F, ACCESS
430E  50E7     MOVF INDF1, W, ACCESS
4310  6EEF     MOVWF INDF0, ACCESS
395:                   OutPtr++;
4312  0100     MOVLB 0x0
4314  2BD1     INCF OutPtr, F, BANKED
4316  0E00     MOVLW 0x0
4318  23D2     ADDWFC 0xD2, F, BANKED
396:                   cdc_Out_len--;
431A  0100     MOVLB 0x0
431C  07CC     DECF cdc_Out_len, F, BANKED
397:                   return 1; // Return byte count, always one.
431E  0E01     MOVLW 0x1
4320  D022     BRA 0x4366
398:               }
399:               if (getOutReady()) { // No byte in queue check for new arrivals.
4322  DE8D     RCALL getOutReady
4324  0900     IORLW 0x0
4326  E01D     BZ 0x4362
400:                   cdc_Out_len = getda_cdc();
4328  DEA2     RCALL getda_cdc
432A  0100     MOVLB 0x0
432C  6FCC     MOVWF cdc_Out_len, BANKED
401:                   if (cdc_Out_len) {
432E  0100     MOVLB 0x0
4330  51CC     MOVF cdc_Out_len, W, BANKED
4332  E017     BZ 0x4362
402:                       *c = *OutPtr;
4334  C0D1     MOVFF OutPtr, FSR0L
4336  FFE9     NOP
4338  C0D2     MOVFF 0xD2, FSR0H
433A  FFEA     NOP
433C  50EF     MOVF INDF0, W, ACCESS
433E  6EE6     MOVWF POSTINC1, ACCESS
4340  0EFD     MOVLW 0xFD
4342  CFDB     MOVFF PLUSW2, FSR0L
4344  FFE9     NOP
4346  0EFE     MOVLW 0xFE
4348  CFDB     MOVFF PLUSW2, FSR0H
434A  FFEA     NOP
434C  52E5     MOVF POSTDEC1, F, ACCESS
434E  50E7     MOVF INDF1, W, ACCESS
4350  6EEF     MOVWF INDF0, ACCESS
403:                       OutPtr++;
4352  0100     MOVLB 0x0
4354  2BD1     INCF OutPtr, F, BANKED
4356  0E00     MOVLW 0x0
4358  23D2     ADDWFC 0xD2, F, BANKED
404:                       cdc_Out_len--;
435A  0100     MOVLB 0x0
435C  07CC     DECF cdc_Out_len, F, BANKED
405:                       return 1;
435E  0E01     MOVLW 0x1
4360  D002     BRA 0x4366
406:                   }
407:               }
408:               return 0;
4362  0E00     MOVLW 0x0
4364  D000     BRA 0x4366
409:           }
4366  52E5     MOVF POSTDEC1, F, ACCESS
4368  CFE7     MOVFF INDF1, FSR2L
436A  FFD9     NOP
436C  0012     RETURN 0
410:           
411:           /******************************************************************************/
412:           // Checks (PEEKS) to see if there is a byte available in the CDC buffer.
413:           // If so, it returns that byte at the dereferenced pointer *C
414:           // and the function returns a count of 1. The byte however is NOT
415:           // removed from the queue and can still be read with the poll_getc_cdc()
416:           // and getc_cdc() functions that will remove it from the queue.
417:           // IF no byte is available function returns immediately with a count of zero.
418:           
419:           BYTE peek_getc_cdc(BYTE * c) { // Must be used only in double buffer mode.
436E  CFD9     MOVFF FSR2L, POSTINC1
4370  FFE6     NOP
4372  CFE1     MOVFF FSR1L, FSR2L
4374  FFD9     NOP
420:           
421:               if (cdc_Out_len) {
4376  0100     MOVLB 0x0
4378  51CC     MOVF cdc_Out_len, W, BANKED
437A  E011     BZ 0x439E
422:                   *c = *OutPtr;
437C  C0D1     MOVFF OutPtr, FSR0L
437E  FFE9     NOP
4380  C0D2     MOVFF 0xD2, FSR0H
4382  FFEA     NOP
4384  50EF     MOVF INDF0, W, ACCESS
4386  6EE6     MOVWF POSTINC1, ACCESS
4388  0EFD     MOVLW 0xFD
438A  CFDB     MOVFF PLUSW2, FSR0L
438C  FFE9     NOP
438E  0EFE     MOVLW 0xFE
4390  CFDB     MOVFF PLUSW2, FSR0H
4392  FFEA     NOP
4394  52E5     MOVF POSTDEC1, F, ACCESS
4396  50E7     MOVF INDF1, W, ACCESS
4398  6EEF     MOVWF INDF0, ACCESS
423:                   return 1;
439A  0E01     MOVLW 0x1
439C  D01C     BRA 0x43D6
424:               }
425:               if (getOutReady()) {
439E  DE4F     RCALL getOutReady
43A0  0900     IORLW 0x0
43A2  E017     BZ 0x43D2
426:                   cdc_Out_len = getda_cdc();
43A4  DE64     RCALL getda_cdc
43A6  0100     MOVLB 0x0
43A8  6FCC     MOVWF cdc_Out_len, BANKED
427:                   if (cdc_Out_len) {
43AA  0100     MOVLB 0x0
43AC  51CC     MOVF cdc_Out_len, W, BANKED
43AE  E011     BZ 0x43D2
428:                       *c = *OutPtr;
43B0  C0D1     MOVFF OutPtr, FSR0L
43B2  FFE9     NOP
43B4  C0D2     MOVFF 0xD2, FSR0H
43B6  FFEA     NOP
43B8  50EF     MOVF INDF0, W, ACCESS
43BA  6EE6     MOVWF POSTINC1, ACCESS
43BC  0EFD     MOVLW 0xFD
43BE  CFDB     MOVFF PLUSW2, FSR0L
43C0  FFE9     NOP
43C2  0EFE     MOVLW 0xFE
43C4  CFDB     MOVFF PLUSW2, FSR0H
43C6  FFEA     NOP
43C8  52E5     MOVF POSTDEC1, F, ACCESS
43CA  50E7     MOVF INDF1, W, ACCESS
43CC  6EEF     MOVWF INDF0, ACCESS
429:                       return 1;
43CE  0E01     MOVLW 0x1
43D0  D002     BRA 0x43D6
430:                   }
431:               }
432:               return 0;
43D2  0E00     MOVLW 0x0
43D4  D000     BRA 0x43D6
433:           }
43D6  52E5     MOVF POSTDEC1, F, ACCESS
43D8  CFE7     MOVFF INDF1, FSR2L
43DA  FFD9     NOP
43DC  0012     RETURN 0
434:           
---  /home/antoine/Documents/Pic/DP_USB/USB_stack/FraiseMaster1.2.2/main.c  -----------------------------
1:             // Open source PIC USB stack echo demo
2:             // USB stack by JTR and Honken
3:             // CC-BY
4:             //
5:             // USB driver files should be in '..\dp_usb\'
6:             // Enter a USB VID and PID in prj_usb_config.h
7:             
8:             //USB stack
9:             #include "../dp_usb/usb_stack_globals.h"    // USB stack only defines Not function related.
10:            #include "descriptors.h"	// JTR Only included in main.c
11:            //#include "configwords.h"	// JTR only included in main.c
12:            #include "fraisemaster.h"
13:            #include "stdio.h"
14:            
15:            // PIC18F Move reset vectors for bootloader compatibility
16:            #ifdef __18CXX
17:            	#define REMAPPED_RESET_VECTOR_ADDRESS		0x800
18:            	#define REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS	0x808
19:            	#define REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS	0x818
20:            #endif
21:            
22:            void SetupBoard(void);
23:            void InterruptHandlerHigh();
24:            void InterruptHandlerLow();
25:            void USBSuspend(void);
26:            
27:            int _user_putc(char c)
43DE  CFD9     MOVFF FSR2L, POSTINC1
43E0  FFE6     NOP
43E2  CFE1     MOVFF FSR1L, FSR2L
43E4  FFD9     NOP
28:            {
29:               putc_cdc(c);
43E6  0EFE     MOVLW 0xFE
43E8  CFDB     MOVFF PLUSW2, POSTINC1
43EA  FFE6     NOP
43EC  EC26     CALL 0x424C, 0
43EE  F021     NOP
43F0  52E5     MOVF POSTDEC1, F, ACCESS
30:            }
43F2  52E5     MOVF POSTDEC1, F, ACCESS
43F4  CFE7     MOVFF INDF1, FSR2L
43F6  FFD9     NOP
43F8  0012     RETURN 0
31:            
32:            #pragma udata
33:            extern BYTE usb_device_state;
34:            
35:            //BYTE LineFromUsb[96];
36:            //BYTE LineFromUsbLen=0;
37:            //#pragma udata accessram
38:            volatile BYTE SofFlag;
39:            
40:            #pragma code
41:            
42:            void SOFHandler(void)
43:            {
44:                //static BYTE il;
45:            
46:                //if(il++==200) { il=0; mLED_2_Toggle(); }
47:                SofFlag=1;
43FA  0101     MOVLB 0x1
43FC  0E01     MOVLW 0x1
43FE  6FFE     MOVWF 0xFE, BANKED
48:                CDCFlushOnTimeout();
4400  ECF7     CALL 0x41EE, 0
4402  F020     NOP
49:            }
4404  0012     RETURN 0
50:            
51:            
52:            #ifdef PIC_18F
53:            void main(void)
4406  CFD9     MOVFF FSR2L, POSTINC1
4408  FFE6     NOP
440A  CFE1     MOVFF FSR1L, FSR2L
440C  FFD9     NOP
440E  0E05     MOVLW 0x5
4410  26E1     ADDWF FSR1L, F, ACCESS
54:            #else
55:            int main(void)
56:            #endif
57:            {
58:                BYTE RecvdByte;
59:                    long int jj;
60:            
61:                stdout = _H_USER; // Use our own special output function for STDOUT
4412  0101     MOVLB 0x1
4414  69FB     SETF 0xFB, BANKED
4416  69FC     SETF 0xFC, BANKED
62:            
63:                initCDC(); // setup the CDC state machine
4418  EC9F     CALL 0x3B3E, 0
441A  F01D     NOP
64:                SetupBoard(); //setup the hardware, customize for your hardware
441C  D8B9     RCALL SetupBoard
65:                usb_init(cdc_device_descriptor, cdc_config_descriptor, cdc_str_descs, USB_NUM_STRINGS); // initialize USB. TODO: Remove magic with macro
441E  0E04     MOVLW 0x4
4420  6EE6     MOVWF POSTINC1, ACCESS
4422  6AE6     CLRF POSTINC1, ACCESS
4424  0ED5     MOVLW 0xD5
4426  6EE6     MOVWF POSTINC1, ACCESS
4428  0E47     MOVLW 0x47
442A  6EE6     MOVWF POSTINC1, ACCESS
442C  0E00     MOVLW 0x0
442E  6EE6     MOVWF POSTINC1, ACCESS
4430  0E92     MOVLW 0x92
4432  6EE6     MOVWF POSTINC1, ACCESS
4434  0E47     MOVLW 0x47
4436  6EE6     MOVWF POSTINC1, ACCESS
4438  0E00     MOVLW 0x0
443A  6EE6     MOVWF POSTINC1, ACCESS
443C  0E80     MOVLW 0x80
443E  6EE6     MOVWF POSTINC1, ACCESS
4440  0E47     MOVLW 0x47
4442  6EE6     MOVWF POSTINC1, ACCESS
4444  0E00     MOVLW 0x0
4446  6EE6     MOVWF POSTINC1, ACCESS
4448  EC97     CALL 0x1D2E, 0
444A  F00E     NOP
444C  6E14     MOVWF __tmp_0, ACCESS
444E  0E0B     MOVLW 0xB
4450  5EE1     SUBWF FSR1L, F, ACCESS
4452  5014     MOVF __tmp_0, W, ACCESS
66:                usb_start(); //start the USB peripheral
4454  ECE5     CALL 0x1DCA, 0
4456  F00E     NOP
67:                
68:            
69:            
70:            // PIC18 INTERRUPTS
71:            // It is the users resposibility to set up high, low or legacy mode
72:            // interrupt operation. The following macros for high and low interrupt
73:            // setup have been removed:
74:            
75:            #define EnableUsbHighPriInterrupt()             do { RCONbits.IPEN = 1; IPR2bits.USBIP = 1; INTCONbits.GIEH = 1;} while(0) // JTR new
76:            #define EnableUsbLowPriInterrupt()              do { RCONbits.IPEN = 1; IPR2bits.USBIP = 0; INTCONbits.GIEL = 1;} while(0)  // JTR new
77:            
78:            // By default, the interrupt mode will be LEGACY (ISR Vector 0x08)
79:            // (Same as high priority vector wise but the operation (latency) is
80:            // not the same. Consult the data sheet for details.)
81:            
82:            // If a priority mode is enabled then this affects ALL other interrupt
83:            // sources therefore it does not belong to the usb stack to be
84:            // doing this. It is a global, user application choice.
85:            
86:            #if defined USB_INTERRUPTS // See the prj_usb_config.h file.
87:                EnableUsbPerifInterrupts(USB_TRN + USB_SOF + USB_UERR + USB_URST);
4458  0E4B     MOVLW 0x4B
445A  1269     IORWF UIE, F, ACCESS
88:            #if defined __18CXX //turn on interrupts for PIC18
89:                //EnableUsbHighPriInterrupt();
90:                EnableUsbLowPriInterrupt();
445C  8ED0     BSF RCON, 7, ACCESS
445E  9AA2     BCF IPR2, 5, ACCESS
4460  8CF2     BSF INTCON, 6, ACCESS
91:                INTCONbits.PEIE = 1;
4462  8CF2     BSF INTCON, 6, ACCESS
92:                INTCONbits.GIE = 1;
4464  8EF2     BSF INTCON, 7, ACCESS
93:            #endif
94:                EnableUsbGlobalInterrupt(); // Only enables global USB interrupt. Chip interrupts must be enabled by the user (PIC18)
4466  8AA0     BSF PIE2, 5, ACCESS
95:            #endif
96:            
97:            
98:            // Wait for USB to connect
99:                do {
100:           #ifndef USB_INTERRUPTS
101:                   usb_handler();
102:           #endif
103:               } while (usb_device_state < CONFIGURED_STATE);
4468  0E20     MOVLW 0x20
446A  0100     MOVLB 0x0
446C  5DB5     SUBWF usb_device_state, W, BANKED
446E  E3FC     BNC 0x4468
104:           
105:               usb_register_sof_handler(SOFHandler); // Register our CDC timeout handler after device configured
4470  0EFA     MOVLW 0xFA
4472  6EE6     MOVWF POSTINC1, ACCESS
4474  0E43     MOVLW 0x43
4476  6EE6     MOVWF POSTINC1, ACCESS
4478  EC2E     CALL 0x2C5C, 0
447A  F016     NOP
447C  52E5     MOVF POSTDEC1, F, ACCESS
447E  52E5     MOVF POSTDEC1, F, ACCESS
106:               //usb_register_sof_handler(CDCFlushOnTimeout); // Register our CDC timeout handler after device configured
107:               
108:               FraiseInit();
4480  EC34     CALL 0x868, 0
4482  F004     NOP
109:           
110:           // Main echo loop
111:               do {
112:           
113:           // If USB_INTERRUPT is not defined each loop should have at least one additional call to the usb handler to allow for control transfers.
114:           #ifndef USB_INTERRUPTS
115:                   usb_handler();
116:           #endif
117:           
118:           // Receive and send method 1
119:           // The CDC module will call usb_handler each time a BULK CDC packet is sent or received.
120:           // If there is a byte ready will return with the number of bytes available and received byte in RecvdByte
121:                   /*if (poll_getc_cdc(&RecvdByte))
122:                       putc_cdc(RecvdByte); */
123:                       
124:                   if(!FrGotLineFromUsb) {
4484  0101     MOVLB 0x1
4486  5141     MOVF 0x41, W, BANKED
4488  E126     BNZ 0x44D6
125:                       while(poll_getc_cdc(&RecvdByte)) {
448A  CFD9     MOVFF FSR2L, POSTINC1
448C  FFE6     NOP
448E  CFDA     MOVFF FSR2H, POSTINC1
4490  FFE6     NOP
4492  EC73     CALL 0x42E6, 0
4494  F021     NOP
4496  52E5     MOVF POSTDEC1, F, ACCESS
4498  52E5     MOVF POSTDEC1, F, ACCESS
449A  0900     IORLW 0x0
449C  E01C     BZ 0x44D6
44D4  D7DA     BRA 0x448A
126:                           if(RecvdByte=='\n') {
449E  0E0A     MOVLW 0xA
44A0  5CDF     SUBWF INDF2, W, ACCESS
44A2  E105     BNZ 0x44AE
127:                               FrGotLineFromUsb=1;
44A4  0101     MOVLB 0x1
44A6  0E01     MOVLW 0x1
44A8  6F41     MOVWF 0x41, BANKED
128:                               //printf((const far rom char*)"rcvd line !\n");
129:                               break;
44AA  D015     BRA 0x44D6
130:                           }
131:                           else if(LineFromUsbLen<(sizeof(LineFromUsb)-1))
44AC  D013     BRA 0x44D4
44AE  0101     MOVLB 0x1
44B0  5140     MOVF 0x40, W, BANKED
44B2  6E14     MOVWF __tmp_0, ACCESS
44B4  6A15     CLRF digit_cnt, ACCESS
44B6  0E3F     MOVLW 0x3F
44B8  5C14     SUBWF __tmp_0, W, ACCESS
44BA  0E00     MOVLW 0x0
44BC  5815     SUBWFB digit_cnt, W, ACCESS
44BE  E20A     BC 0x44D4
132:                               LineFromUsb[LineFromUsbLen++]=RecvdByte;
44C0  0101     MOVLB 0x1
44C2  5140     MOVF 0x40, W, BANKED
44C4  2B40     INCF 0x40, F, BANKED
44C6  6AEA     CLRF FSR0H, ACCESS
44C8  0F00     ADDLW 0x0
44CA  6EE9     MOVWF FSR0L, ACCESS
44CC  0E01     MOVLW 0x1
44CE  22EA     ADDWFC FSR0H, F, ACCESS
44D0  CFDF     MOVFF INDF2, INDF0
44D2  FFEF     NOP
133:                       }
134:                   }
135:           
136:                   if(SofFlag==1) { FraiseSOF(); SofFlag=0; }
44D6  0101     MOVLB 0x1
44D8  05FE     DECF 0xFE, W, BANKED
44DA  E104     BNZ 0x44E4
44DC  EC84     CALL 0x1D08, 0
44DE  F00E     NOP
44E0  0101     MOVLB 0x1
44E2  6BFE     CLRF 0xFE, BANKED
137:           
138:                   FraiseService();
44E4  ECBC     CALL 0x1B78, 0
44E6  F00D     NOP
139:           
140:           
141:                   if(!UserSW) { //goto booloader... doesn't work well... bouhou !
44E8  B482     BTFSC PORTC, 2, ACCESS
44EA  D047     BRA 0x457A
142:                       INTCONbits.GIEH=0;
44EC  9EF2     BCF INTCON, 7, ACCESS
143:                       INTCONbits.GIEL=0;
44EE  9CF2     BCF INTCON, 6, ACCESS
144:                       //SuspendUsb();
145:                       //UCONbits.USBEN = 0;
146:                       UCFGbits.UPUEN=0;
44F0  986F     BCF UCFG, 4, ACCESS
147:                       UCFGbits.UTRDIS=1;
44F2  866F     BSF UCFG, 3, ACCESS
148:                       mLED_2_On();
44F4  828B     BSF LATC, 1, ACCESS
149:                       while(jj++<600000) ;
44F6  50D9     MOVF FSR2L, W, ACCESS
44F8  0F01     ADDLW 0x1
44FA  6EE9     MOVWF FSR0L, ACCESS
44FC  CFDA     MOVFF FSR2H, FSR0H
44FE  FFEA     NOP
4500  CFEF     MOVFF INDF0, __tmp_0
4502  F014     NOP
4504  2AEE     INCF POSTINC0, F, ACCESS
4506  0E00     MOVLW 0x0
4508  CFEF     MOVFF INDF0, digit_cnt
450A  F015     NOP
450C  22EE     ADDWFC POSTINC0, F, ACCESS
450E  CFEF     MOVFF INDF0, prefix_cnt
4510  F016     NOP
4512  22EE     ADDWFC POSTINC0, F, ACCESS
4514  CFEF     MOVFF INDF0, sign_char
4516  F017     NOP
4518  22EF     ADDWFC INDF0, F, ACCESS
451A  90D8     BCF STATUS, 0, ACCESS
451C  5017     MOVF sign_char, W, ACCESS
451E  0A00     XORLW 0x0
4520  E608     BN 0x4532
4522  0EC0     MOVLW 0xC0
4524  5C14     SUBWF __tmp_0, W, ACCESS
4526  0E27     MOVLW 0x27
4528  5815     SUBWFB digit_cnt, W, ACCESS
452A  0E09     MOVLW 0x9
452C  5816     SUBWFB prefix_cnt, W, ACCESS
452E  0E00     MOVLW 0x0
4530  5817     SUBWFB sign_char, W, ACCESS
4532  E201     BC 0x4536
4534  D7E0     BRA 0x44F6
150:                       mLED_2_Off();
4536  928B     BCF LATC, 1, ACCESS
151:                       while(jj++<600000) ;
4538  50D9     MOVF FSR2L, W, ACCESS
453A  0F01     ADDLW 0x1
453C  6EE9     MOVWF FSR0L, ACCESS
453E  CFDA     MOVFF FSR2H, FSR0H
4540  FFEA     NOP
4542  CFEF     MOVFF INDF0, __tmp_0
4544  F014     NOP
4546  2AEE     INCF POSTINC0, F, ACCESS
4548  0E00     MOVLW 0x0
454A  CFEF     MOVFF INDF0, digit_cnt
454C  F015     NOP
454E  22EE     ADDWFC POSTINC0, F, ACCESS
4550  CFEF     MOVFF INDF0, prefix_cnt
4552  F016     NOP
4554  22EE     ADDWFC POSTINC0, F, ACCESS
4556  CFEF     MOVFF INDF0, sign_char
4558  F017     NOP
455A  22EF     ADDWFC INDF0, F, ACCESS
455C  90D8     BCF STATUS, 0, ACCESS
455E  5017     MOVF sign_char, W, ACCESS
4560  0A00     XORLW 0x0
4562  E608     BN 0x4574
4564  0EC0     MOVLW 0xC0
4566  5C14     SUBWF __tmp_0, W, ACCESS
4568  0E27     MOVLW 0x27
456A  5815     SUBWFB digit_cnt, W, ACCESS
456C  0E09     MOVLW 0x9
456E  5816     SUBWFB prefix_cnt, W, ACCESS
4570  0E00     MOVLW 0x0
4572  5817     SUBWFB sign_char, W, ACCESS
4574  E201     BC 0x4578
4576  D7E0     BRA 0x4538
152:                       Reset();
4578  00FF     RESET
153:                   }
154:           // Receive and send method 2
155:           // Same as poll_getc_cdc except that byte is NOT removed from queue.
156:           // This function will wait for a byte and return and remove it from the queue when it arrives.
157:                   /*if (peek_getc_cdc(&RecvdByte)) {
158:                       RecvdByte = getc_cdc(); 
159:                       putc_cdc(RecvdByte+1);
160:                   }*/
161:           
162:           // Receive and send method 3
163:           // If there is a byte ready will return with the number of bytes available and received byte in RecvdByte
164:           // use CDC_Flush_In_Now(); when it has to be sent immediately and not wait for a timeout condition.
165:                 /*  if (poll_getc_cdc(&RecvdByte)) {
166:                       putc_cdc(RecvdByte+1); //
167:                       CDC_Flush_In_Now(); 
168:                   }*/
169:               } while (1);
457A  D784     BRA 0x4484
170:           
171:           } //end main
457C  0E05     MOVLW 0x5
457E  5CE1     SUBWF FSR1L, W, ACCESS
4580  E202     BC 0x4586
4582  6AE1     CLRF FSR1L, ACCESS
4584  52E5     MOVF POSTDEC1, F, ACCESS
4586  6EE1     MOVWF FSR1L, ACCESS
4588  52E5     MOVF POSTDEC1, F, ACCESS
458A  CFE7     MOVFF INDF1, FSR2L
458C  FFD9     NOP
458E  0012     RETURN 0
172:           
173:           //board hardware setup
174:           //add your hardware here
175:           void SetupBoard(void) {
176:           
177:           #if defined (PIEDUSB)
178:               //disable some defaults
179:               ADCON1 |= 0b1111; //all pins digital
4590  0E0F     MOVLW 0xF
4592  12C1     IORWF ADCON1, F, ACCESS
180:               CVRCON = 0b00000000;
4594  6AB5     CLRF CVRCON, ACCESS
181:               LATC = 0x00;
4596  6A8B     CLRF LATC, ACCESS
182:               TRISC = 0xFF;
4598  6894     SETF TRISC, ACCESS
183:           #endif
184:           
185:           }
459A  0012     RETURN 0
186:           
187:           // USB suspend not yet enabled
188:           void USBSuspend(void) {}
459C  0012     RETURN 0
189:           
190:           //interrupt routines for PIC 18 and PIC24
191:           #if defined(USB_INTERRUPTS)
192:           
193:           //PIC 24F type USB interrupts
194:           #if defined(__PIC24FJ64GB106__) || defined(__PIC24FJ128GB106__) || defined(__PIC24FJ192GB106__) || defined(__PIC24FJ256GB106__) || defined(__PIC24FJ64GB108__) || defined(__PIC24FJ128GB108__) || defined(__PIC24FJ192GB108__) || defined(__PIC24FJ256GB108__) || defined(__PIC24FJ64GB110__) || defined(__PIC24FJ128GB110__) || defined(__PIC24FJ192GB110__) || defined(__PIC24FJ256GB110__) 
195:           #pragma interrupt _USB1Interrupt
196:           void __attribute__((interrupt, auto_psv)) _USB1Interrupt() {
197:               //USB interrupt
198:               //IRQ enable IEC5bits.USB1IE
199:               //IRQ flag	IFS5bits.USB1IF
200:               //IRQ priority IPC21<10:8>
201:               usb_handler();
202:               ClearGlobalUsbInterruptFlag();
203:           }
204:           #elif defined (__18CXX) //PIC18F style interrupts with remapping for bootloader
205:           //	Interrupt remap chain
206:           //
207:           //This function directs the interrupt to
208:           // the proper function depending on the mode
209:           // set in the mode variable.
210:           //USB stack on low priority interrupts,
211:           #pragma interruptlow InterruptHandlerLow nosave= PROD, PCLATH, PCLATU, TBLPTR, TBLPTRU, TABLAT, section (".tmpdata"), section("MATH_DATA")
212:           void InterruptHandlerLow(void) {
459E  CFD8     MOVFF STATUS, PREINC1
45A0  FFE4     NOP
45A2  CFE0     MOVFF BSR, PREINC1
45A4  FFE4     NOP
45A6  6EE4     MOVWF PREINC1, ACCESS
45A8  CFDA     MOVFF FSR2H, PREINC1
45AA  FFE4     NOP
45AC  CFE2     MOVFF FSR1H, FSR2H
45AE  FFDA     NOP
45B0  CFE9     MOVFF FSR0L, PREINC1
45B2  FFE4     NOP
45B4  CFEA     MOVFF FSR0H, PREINC1
45B6  FFE4     NOP
45B8  52E6     MOVF POSTINC1, F, ACCESS
213:               usb_handler();
45BA  EC9F     CALL 0x1F3E, 0
45BC  F00F     NOP
214:               ClearGlobalUsbInterruptFlag();
45BE  9AA1     BCF PIR2, 5, ACCESS
215:               //FraiseISR();
216:           }
45C0  52E5     MOVF POSTDEC1, F, ACCESS
45C2  CFE5     MOVFF POSTDEC1, FSR0H
45C4  FFEA     NOP
45C6  CFE5     MOVFF POSTDEC1, FSR0L
45C8  FFE9     NOP
45CA  CFE5     MOVFF POSTDEC1, FSR2H
45CC  FFDA     NOP
45CE  50E5     MOVF POSTDEC1, W, ACCESS
45D0  CFE5     MOVFF POSTDEC1, BSR
45D2  FFE0     NOP
45D4  CFE5     MOVFF POSTDEC1, STATUS
45D6  FFD8     NOP
45D8  0010     RETFIE 0
217:           
218:           #pragma interrupt InterruptHandlerHigh nosave= PROD, PCLATH, PCLATU, TBLPTR, TBLPTRU, TABLAT, section (".tmpdata"), section("MATH_DATA")
219:           void InterruptHandlerHigh(void) { //Also legacy mode interrupt.
45DA  CFDA     MOVFF FSR2H, PREINC1
45DC  FFE4     NOP
45DE  CFE2     MOVFF FSR1H, FSR2H
45E0  FFDA     NOP
45E2  CFE9     MOVFF FSR0L, PREINC1
45E4  FFE4     NOP
45E6  CFEA     MOVFF FSR0H, PREINC1
45E8  FFE4     NOP
45EA  52E6     MOVF POSTINC1, F, ACCESS
220:               //usb_handler();
221:               //ClearGlobalUsbInterruptFlag();
222:               FraiseISR();
45EC  EC73     CALL 0x18E6, 0
45EE  F00C     NOP
223:           }
45F0  52E5     MOVF POSTDEC1, F, ACCESS
45F2  CFE5     MOVFF POSTDEC1, FSR0H
45F4  FFEA     NOP
45F6  CFE5     MOVFF POSTDEC1, FSR0L
45F8  FFE9     NOP
45FA  CFE5     MOVFF POSTDEC1, FSR2H
45FC  FFDA     NOP
45FE  0011     RETFIE 1
224:           
225:           //these statements remap the vector to our function
226:           //When the interrupt fires the PIC checks here for directions
227:           #pragma code REMAPPED_HIGH_INTERRUPT_VECTOR = REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS
228:           
229:           void Remapped_High_ISR(void) {
230:               _asm goto InterruptHandlerHigh _endasm
0808  EFED     GOTO 0x45DA
080A  F022     NOP
231:           }
080C  0012     RETURN 0
232:           
233:           #pragma code REMAPPED_LOW_INTERRUPT_VECTOR = REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS
234:           
235:           void Remapped_Low_ISR(void) {
236:               _asm goto InterruptHandlerLow _endasm
0818  EFCF     GOTO 0x459E
081A  F022     NOP
237:           }
081C  0012     RETURN 0
238:           
239:           //relocate the reset vector
240:           extern void _startup(void);
241:           #pragma code REMAPPED_RESET_VECTOR = REMAPPED_RESET_VECTOR_ADDRESS
242:           
243:           void _reset(void) {
244:               _asm goto _startup _endasm
0800  EFE1     GOTO 0x4BC2
0802  F025     NOP
245:           }
0804  0012     RETURN 0
246:           //set the initial vectors so this works without the bootloader too.
247:           #if 0
248:           #pragma code HIGH_INTERRUPT_VECTOR = 0x08
249:           
250:           void High_ISR(void) {
251:               _asm goto REMAPPED_HIGH_INTERRUPT_VECTOR_ADDRESS _endasm
252:           }
253:           #pragma code LOW_INTERRUPT_VECTOR = 0x18
254:           
255:           void Low_ISR(void) {
256:               _asm goto REMAPPED_LOW_INTERRUPT_VECTOR_ADDRESS _endasm
257:           }
258:           #endif
259:           
260:           #endif //defined (__18CXX)
261:           #endif //defined(USB_INTERRUPTS)
262:           
263:           #pragma code
264:           
265:           
---  /home/antoine/Documents/Pic/DP_USB/USB_stack/FraiseMaster1.2.2/fraisemaster.c  ---------------------
1:             /*********************************************************************
2:              *
3:              *                Fraise master firmware v2.1
4:              *
5:              *********************************************************************
6:             
7:               This program is free software; you can redistribute it and/or modify
8:               it under the terms of the GNU General Public License as published by
9:               the Free Software Foundation; either version 2 of the License, or
10:              (at your option) any later version.
11:            
12:              This program is distributed in the hope that it will be useful,
13:              but WITHOUT ANY WARRANTY; without even the implied warranty of
14:              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
15:              GNU General Public License for more details.
16:            
17:              You should have received a copy of the GNU General Public License
18:              along with this program; if not, write to the Free Software Foundation,
19:              Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
20:            
21:             *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
22:             * Copyright (c) Antoine Rousseau   2009-2011   
23:             ********************************************************************/
24:             
25:            #ifdef SDCC
26:            #include <pic18f2550.h>
27:            #else
28:            #include <p18cxxx.h>
29:            #endif
30:            #include <usart.h>
31:            #include <stdio.h>
32:            #include <ctype.h>
33:            #ifndef SDCC
34:            #include <delays.h>
35:            #endif
36:            //#include "system/typedefs.h"
37:            //#include "system/usb/usb.h"
38:            //#include "io_cfg.h"            // I/O pin mapping
39:            #include "prj_usb_config.h"
40:            #include "fraisemaster.h"
41:            
42:            //#pragma udata
43:            
44:            extern int _user_putc(char c);
45:            typedef const rom far char *STRING;
46:            typedef unsigned char BYTE;
47:            
48:            #define VERSION_STRING (STRING)"UsbFraise2.1 Version 2 (DP_USB open source stack)\n"
49:            
50:            BYTE LineFromUsb[LINE_FROM_USB_MAXLEN];
51:            BYTE LineFromUsbLen;
52:            BYTE FrGotLineFromUsb;
53:            
54:            extern void putc_cdc(BYTE c);
55:            #define putchar putc_cdc
56:            
57:            extern union USART USART_Status;
58:            
59:            //---------- FrTX : Host to Master  -------------------------------------------
60:            /*unsigned char FrTXbuf[256]; //Fraise TX ring buffer; don't change size of this table : hardcoded in asm..
61:            unsigned char FrTXin=0,FrTXout=0; //Pointers to Fraise TX buffer
62:            unsigned char FrTXfree=255;
63:            #define FrTXempty (FrTXin==FrTXout)*/
64:            
65:            //---------- FrTXPacket : Master to Device(s) -------------------------------------------
66:            unsigned char FrTXpacket[64]; //Fraise TX packet buffer
67:            unsigned char FrTXpacket_i;
68:            unsigned char FrTXpacket_len;
69:            unsigned char FrTXchksum;
70:            unsigned char FrTXtries; //number of tries to send the TX packet
71:            
72:            //---------- FrRX : Device to Master -------------------------------------------
73:            unsigned char FrRXbuf[64]; //Fraise RX buffer:32 bytes
74:            unsigned char FrRXin;
75:            unsigned char FrRXout;
76:            //#define FrRXfull (FrRXin!=0)
77:            unsigned char FrRXchksum;
78:            unsigned char PollDelay;
79:            volatile unsigned char PollCount;
80:            //---------- FraiseStatus bits -------------------------------------------
81:            union {
82:            	unsigned char VAL;
83:            	struct {
84:            		unsigned RXFULL :1; // a RX packet has been received
85:            		unsigned RXCHAR	:1;	// the RX packet is char (do not convert to hexa string)
86:            //		unsigned TXFULL :1; // the TX packet buffer is ready to be sent 
87:            		unsigned TXCHAR	:1; // the TX packet was char (was not converted from hexa string)
88:            		unsigned TX_NEEDACK :1; // the TX packet needs an acknowledge
89:            		unsigned FBLDON :1;
90:            		unsigned OERR :1;
91:            		unsigned FERR :1;
92:            	};
93:            } FraiseStatus;
94:            
95:            unsigned char i,c,c2; // general counter and tmp  
96:            unsigned char t1,t2,t3; // general asm tmp 
97:            unsigned int  p; 
98:            //---------- finite state machine FraiseState ----------------------------
99:            typedef enum {
100:           	fIDLE
101:           	,fWAITACK
102:           	,fOUT
103:           	,fIN
104:           	,fBLOUT
105:           	,fBLIN
106:           } tFraiseState;
107:           tFraiseState FraiseState;
108:           
109:           //---------- FraiseMessage from interrupt routine -------------------------
110:           typedef enum {
111:           	fmessNONE
112:           	,fmessFOUND // polled device has been found
113:           	,fmessLOST  // polled device has been lost
114:           	,fmessCHKSUM // checksum error on a packet from polled device
115:           	,fmessNACK  // destination device refused packet (packet error | buffer full)
116:           	,fmessTOUT  // destination device didn't acknowledge packet (timeout)
117:           } tFraiseMessage;
118:           tFraiseMessage FraiseMessage;
119:           
120:           
121:           //---------- Devices State tables ----------------------------------------	
122:           unsigned char _PolledChild; // id of the polled child
123:           unsigned char _bit_PolledChild; // 1<<PolledChild%8
124:           unsigned char MaxPolledChild; // maximum id of the polled child
125:           unsigned char Children[16]; // 16*8=128 bits: bit(Children[i],j)=child[i*8+j] is polled
126:           unsigned char ChildrenOK[16]; // 16*8=128 bits: bit(Children[i],j)=child[i*8+j] is present
127:           unsigned char AckChild; //child which must send a ACK now
128:           #define incPolledChild() { _PolledChild++ ; if(_PolledChild>MaxPolledChild) {_PolledChild=1;_bit_PolledChild =2;} else _bit_PolledChild = ((_bit_PolledChild << 1) | (_bit_PolledChild >> 7)); }
129:           //#define clearPolledChild() { _PolledChild=0 ; _bit_PolledChild=1 ; }
130:           #define PolledChild() _PolledChild
131:           
132:           #define bitset(var,bitno) ((var) |= (1 << (bitno)))
133:           #define bitclr(var,bitno) ((var) &= ~(1 << (bitno)))
134:           #define bittst(var,bitno) ((var) & (1 << (bitno)))
135:           
136:           /*const unsigned char _bits_table[8]={1,2,4,8,32,64,128};
137:           #define bitset(var,bitno) ((var) |= _bits_table[bitno])
138:           #define bitclr(var,bitno) ((var) &= ~_bits_table[bitno])
139:           #define bittst(var,bitno) (var& _bits_table[bitno])*/
140:           
141:           #define SET_CHILD(num) bitset(Children[(num)>>3],((num)&7))
142:           #define CLR_CHILD(num) bitclr(Children[(num)>>3],((num)&7))
143:           #define TST_CHILD(num) bittst(Children[(num)>>3],((num)&7))
144:           
145:           #define SET_CHILDOK(num) bitset(ChildrenOK[(num)>>3],((num)&7))
146:           #define CLR_CHILDOK(num) bitclr(ChildrenOK[(num)>>3],((num)&7))
147:           #define TST_CHILDOK(num) bittst(ChildrenOK[(num)>>3],((num)&7))
148:           
149:           #define SET_POLLEDCHILD() ( Children[_PolledChild>>3]|= _bit_PolledChild )
150:           #define CLR_POLLEDCHILD() ( Children[_PolledChild>>3]&= ~_bit_PolledChild )
151:           #define TST_POLLEDCHILD() ( Children[_PolledChild>>3]& _bit_PolledChild )
152:           
153:           #define SET_POLLEDCHILDOK() ( ChildrenOK[_PolledChild>>3]|= _bit_PolledChild )
154:           #define CLR_POLLEDCHILDOK() ( ChildrenOK[_PolledChild>>3]&= ~_bit_PolledChild )
155:           #define TST_POLLEDCHILDOK() ( ChildrenOK[_PolledChild>>3]& _bit_PolledChild )
156:           
157:           
158:           //------------- other globals -----------------------------------------
159:           //unsigned short nexttime; //timer
160:           //unsigned short time;
161:           //extern unsigned char g_TX_buf_free; //free space in "printf" buffer...
162:           
163:           //-------------- byte to HEX string -----------------------------------
164:           #define HI_CHAR(N) ( ((N)>>4)<10?((N)>>4)+'0':((N)>>4)-10+'A' )
165:           #define LO_CHAR(N) ( ((N)&15)<10?((N)&15)+'0':((N)&15)-10+'A' )
166:           
167:           
168:           //---------------serial macros ---------------------------------------
169:           void Serial_Init_Receiver(void)
170:           {
171:           	while(TXSTAbits.TRMT==0);
0850  A2AC     BTFSS TXSTA, 1, ACCESS
0852  D7FE     BRA Serial_Init_Receiver
172:                   WREG=RCREG;
0854  50AE     MOVF RCREG, W, ACCESS
0856  6EE8     MOVWF WREG, ACCESS
173:           	WREG=RCREG;
0858  50AE     MOVF RCREG, W, ACCESS
085A  6EE8     MOVWF WREG, ACCESS
174:           	RCSTAbits.CREN=0;
085C  98AB     BCF RCSTA, 4, ACCESS
175:           	RCSTAbits.CREN=1;
085E  88AB     BSF RCSTA, 4, ACCESS
176:           	PIE1bits.RCIE=1;
0860  8A9D     BSF PIE1, 5, ACCESS
177:           	PIE1bits.TXIE=0;
0862  989D     BCF PIE1, 4, ACCESS
178:           	mSerDrv_Off();
0864  808B     BSF LATC, 0, ACCESS
179:           }
0866  0012     RETURN 0
180:           
181:           #define Serial_Init_Driver() {\
182:           	mSerDrv_On();		\
183:           	PIE1bits.RCIE=0;		\
184:           }
185:           
186:           #define Serial_Init_None() {\
187:           	mSerDrv_Off();		\
188:           	PIE1bits.RCIE=0;        \
189:                   PIE1bits.TXIE=0;        \
190:           }
191:           
192:           //#define Serial_Is_Driver() mSerDrv_isOn()
193:           #define Serial_Is_Receiver() (PIE1bits.RCIE)
194:           //---------------------------------------------------------------------
195:           
196:           void FraiseInit(void)
197:           {
198:           	/*FrTXin=0;
199:           	FrTXout=0;
200:           	FrTXfree=255;*/
201:                   FrGotLineFromUsb=0;
0868  0101     MOVLB 0x1
086A  6B41     CLRF 0x41, BANKED
202:                   LineFromUsbLen=0;
086C  0101     MOVLB 0x1
086E  6B40     CLRF 0x40, BANKED
203:           
204:           	FraiseStatus.VAL=0;
0870  0101     MOVLB 0x1
0872  6BCB     CLRF cdc_In_len, BANKED
205:           	FraiseState=fIDLE;
0874  0101     MOVLB 0x1
0876  6BD4     CLRF 0xD4, BANKED
206:                   FraiseMessage=fmessNONE;
0878  0101     MOVLB 0x1
087A  6BD5     CLRF CDC_Inbdp, BANKED
207:           	FrRXin=0;
087C  0101     MOVLB 0x1
087E  6BC6     CLRF 0xC6, BANKED
208:           	FrRXout=0;
0880  0101     MOVLB 0x1
0882  6BC7     CLRF 0xC7, BANKED
209:                   PollDelay=0;
0884  0101     MOVLB 0x1
0886  6BC9     CLRF cls, BANKED
210:           	//OpenUSART(USART_TX_INT_OFF & USART_RX_INT_OFF & USART_ASYNCH_MODE & USART_EIGHT_BIT & USART_CONT_RX & USART_BRGH_HIGH, 103);  // 48 MHz/4/115200 = 104
211:           	BAUDCON = 0x08;     // BRG16 = 1	
0888  0E08     MOVLW 0x8
088A  6EB8     MOVWF BAUDCON, ACCESS
212:           	OpenUSART(USART_TX_INT_OFF & USART_RX_INT_OFF & USART_ASYNCH_MODE & USART_NINE_BIT & USART_CONT_RX & USART_BRGH_HIGH & USART_ADDEN_OFF, 47);  // 48 MHz/4/250000 = 48
088C  0E2F     MOVLW 0x2F
088E  6EE6     MOVWF POSTINC1, ACCESS
0890  6AE6     CLRF POSTINC1, ACCESS
0892  0E1E     MOVLW 0x1E
0894  6EE6     MOVWF POSTINC1, ACCESS
0896  ECAF     CALL 0x495E, 0
0898  F024     NOP
089A  52E5     MOVF POSTDEC1, F, ACCESS
089C  52E5     MOVF POSTDEC1, F, ACCESS
089E  52E5     MOVF POSTDEC1, F, ACCESS
213:           	USART_Status.TX_NINE=1;
08A0  0101     MOVLB 0x1
08A2  83FD     BSF 0xFD, 1, BANKED
214:           
215:                   // Initialize Timer2
216:                       // The prescaler will be at 16
217:                   T2CONbits.T2CKPS1 = 1;
08A4  82CA     BSF T2CON, 1, ACCESS
218:                   T2CONbits.T2CKPS0 = 1;
08A6  80CA     BSF T2CON, 0, ACCESS
219:                   // We want no TMR2 post scaler
220:                   T2CONbits.T2OUTPS3 = 0;
08A8  9CCA     BCF T2CON, 6, ACCESS
221:                   T2CONbits.T2OUTPS2 = 0;
08AA  9ACA     BCF T2CON, 5, ACCESS
222:                   T2CONbits.T2OUTPS1 = 0;
08AC  98CA     BCF T2CON, 4, ACCESS
223:                   T2CONbits.T2OUTPS0 = 0;
08AE  96CA     BCF T2CON, 3, ACCESS
224:            	// Set our reload value
225:           	//PR2 = kPR2_RELOAD;
226:           	PR2 = 255;
08B0  68CB     SETF PR2, ACCESS
227:                   T2CONbits.TMR2ON = 1;
08B2  84CA     BSF T2CON, 2, ACCESS
228:           
229:           	// Initalize switchs and leds
230:                   mInitAllLEDs();
08B4  0EFC     MOVLW 0xFC
08B6  168B     ANDWF LATC, F, ACCESS
08B8  0EFC     MOVLW 0xFC
08BA  1694     ANDWF TRISC, F, ACCESS
231:                   mInitSwitch();
08BC  8494     BSF TRISC, 2, ACCESS
232:           
233:                   mInitSerDrv();
08BE  9094     BCF TRISC, 0, ACCESS
234:                   //Serial_Init_Receiver();
235:           	Serial_Init_Driver();
08C0  908B     BCF LATC, 0, ACCESS
08C2  9A9D     BCF PIE1, 5, ACCESS
236:           	for(i=0;i<16;i++) {
08C4  0101     MOVLB 0x1
08C6  6BCC     CLRF cdc_Out_len, BANKED
08C8  0E10     MOVLW 0x10
08CA  0101     MOVLB 0x1
08CC  5DCC     SUBWF cdc_Out_len, W, BANKED
08CE  E213     BC 0x8F6
08F0  0101     MOVLB 0x1
08F2  2BCC     INCF cdc_Out_len, F, BANKED
08F4  D7E9     BRA 0x8C8
237:           		Children[i]=0;
08D0  0101     MOVLB 0x1
08D2  51CC     MOVF cdc_Out_len, W, BANKED
08D4  6AEA     CLRF FSR0H, ACCESS
08D6  0FD9     ADDLW 0xD9
08D8  6EE9     MOVWF FSR0L, ACCESS
08DA  0E01     MOVLW 0x1
08DC  22EA     ADDWFC FSR0H, F, ACCESS
08DE  6AEF     CLRF INDF0, ACCESS
238:           		ChildrenOK[i]=0;
08E0  0101     MOVLB 0x1
08E2  51CC     MOVF cdc_Out_len, W, BANKED
08E4  6AEA     CLRF FSR0H, ACCESS
08E6  0FE9     ADDLW 0xE9
08E8  6EE9     MOVWF FSR0L, ACCESS
08EA  0E01     MOVLW 0x1
08EC  22EA     ADDWFC FSR0H, F, ACCESS
08EE  6AEF     CLRF INDF0, ACCESS
239:           	}
240:           	MaxPolledChild=4;
08F6  0101     MOVLB 0x1
08F8  0E04     MOVLW 0x4
08FA  6FD8     MOVWF cdc_trf_state, BANKED
241:           	_PolledChild=1;_bit_PolledChild =2;
08FC  0101     MOVLB 0x1
08FE  0E01     MOVLW 0x1
0900  6FD6     MOVWF 0xD6, BANKED
0902  0101     MOVLB 0x1
0904  0E02     MOVLW 0x2
0906  6FD7     MOVWF CDCFunctionError, BANKED
242:           
243:                       // Set interrupt priorities
244:                   PIE1bits.TMR2IE = 0;
0908  929D     BCF PIE1, 1, ACCESS
245:                   IPR1bits.TMR2IP = 1;
090A  829F     BSF IPR1, 1, ACCESS
246:                   IPR1bits.TXIP = 1;
090C  889F     BSF IPR1, 4, ACCESS
247:                   IPR1bits.RCIP = 1;
090E  8A9F     BSF IPR1, 5, ACCESS
248:           
249:                   INTCONbits.GIEH = 1;
0910  8EF2     BSF INTCON, 7, ACCESS
250:           }
0912  0012     RETURN 0
251:           
252:           /*-----------------------------------------------------------------------------------*/
253:           /*          Send received fraise packet to usb.                                      */
254:           /*-----------------------------------------------------------------------------------*/
255:           
256:           void FrSendtoUsb(void)
0914  CFD9     MOVFF FSR2L, POSTINC1
0916  FFE6     NOP
0918  CFE1     MOVFF FSR1L, FSR2L
091A  FFD9     NOP
091C  0E03     MOVLW 0x3
091E  26E1     ADDWF FSR1L, F, ACCESS
257:           {
258:           	unsigned char i=0,c,c2;
0920  6ADF     CLRF INDF2, ACCESS
259:           
260:                   if(!FraiseStatus.RXFULL) return;
0922  0101     MOVLB 0x1
0924  A1CB     BTFSS cdc_In_len, 0, BANKED
0926  D0AE     BRA 0xA84
261:           
262:                   c=FrRXbuf[i++]; //discard len byte
0928  50DF     MOVF INDF2, W, ACCESS
092A  2ADF     INCF INDF2, F, ACCESS
092C  6AEA     CLRF FSR0H, ACCESS
092E  0F86     ADDLW 0x86
0930  6EE9     MOVWF FSR0L, ACCESS
0932  0E01     MOVLW 0x1
0934  22EA     ADDWFC FSR0H, F, ACCESS
0936  0E01     MOVLW 0x1
0938  CFEF     MOVFF INDF0, PLUSW2
093A  FFDB     NOP
263:           
264:                   // send hex string of PolledChild+128*packet_is_char
265:                   c2=(PolledChild()>>4)+'0'; if(c2>'9') c2+='A'-'9'-1;
093C  0101     MOVLB 0x1
093E  39D6     SWAPF 0xD6, W, BANKED
0940  0B0F     ANDLW 0xF
0942  0F30     ADDLW 0x30
0944  6EE7     MOVWF INDF1, ACCESS
0946  0E02     MOVLW 0x2
0948  CFE7     MOVFF INDF1, PLUSW2
094A  FFDB     NOP
094C  0E02     MOVLW 0x2
094E  50DB     MOVF PLUSW2, W, ACCESS
0950  0839     SUBLW 0x39
0952  E20A     BC 0x968
0954  0E07     MOVLW 0x7
0956  6E14     MOVWF __tmp_0, ACCESS
0958  0E02     MOVLW 0x2
095A  CFDB     MOVFF PLUSW2, INDF1
095C  FFE7     NOP
095E  5014     MOVF __tmp_0, W, ACCESS
0960  26E7     ADDWF INDF1, F, ACCESS
0962  0E02     MOVLW 0x2
0964  CFE7     MOVFF INDF1, PLUSW2
0966  FFDB     NOP
266:                   if(FraiseStatus.RXCHAR) c2|=8;
0968  0101     MOVLB 0x1
096A  A3CB     BTFSS cdc_In_len, 1, BANKED
096C  D002     BRA 0x972
096E  0E02     MOVLW 0x2
0970  86DB     BSF PLUSW2, 3, ACCESS
267:                   putchar(c2);
0972  0E02     MOVLW 0x2
0974  CFDB     MOVFF PLUSW2, POSTINC1
0976  FFE6     NOP
0978  EC26     CALL 0x424C, 0
097A  F021     NOP
097C  52E5     MOVF POSTDEC1, F, ACCESS
268:           
269:                   c2=(PolledChild()&15)+'0'; if(c2>'9') c2+='A'-'9'-1;
097E  0E0F     MOVLW 0xF
0980  0101     MOVLB 0x1
0982  15D6     ANDWF 0xD6, W, BANKED
0984  0F30     ADDLW 0x30
0986  6EE7     MOVWF INDF1, ACCESS
0988  0E02     MOVLW 0x2
098A  CFE7     MOVFF INDF1, PLUSW2
098C  FFDB     NOP
098E  0E02     MOVLW 0x2
0990  50DB     MOVF PLUSW2, W, ACCESS
0992  0839     SUBLW 0x39
0994  E20A     BC 0x9AA
0996  0E07     MOVLW 0x7
0998  6E14     MOVWF __tmp_0, ACCESS
099A  0E02     MOVLW 0x2
099C  CFDB     MOVFF PLUSW2, INDF1
099E  FFE7     NOP
09A0  5014     MOVF __tmp_0, W, ACCESS
09A2  26E7     ADDWF INDF1, F, ACCESS
09A4  0E02     MOVLW 0x2
09A6  CFE7     MOVFF INDF1, PLUSW2
09A8  FFDB     NOP
270:                   putchar(c2);
09AA  0E02     MOVLW 0x2
09AC  CFDB     MOVFF PLUSW2, POSTINC1
09AE  FFE6     NOP
09B0  EC26     CALL 0x424C, 0
09B2  F021     NOP
09B4  52E5     MOVF POSTDEC1, F, ACCESS
271:           
272:                   if(FraiseStatus.RXCHAR)
09B6  0101     MOVLB 0x1
09B8  A3CB     BTFSS cdc_In_len, 1, BANKED
09BA  D012     BRA 0x9E0
273:                       while(i<FrRXin) putchar(FrRXbuf[i++]);
09BC  0101     MOVLB 0x1
09BE  51C6     MOVF 0xC6, W, BANKED
09C0  5CDF     SUBWF INDF2, W, ACCESS
09C2  E20D     BC 0x9DE
09C4  50DF     MOVF INDF2, W, ACCESS
09C6  2ADF     INCF INDF2, F, ACCESS
09C8  6AEA     CLRF FSR0H, ACCESS
09CA  0F86     ADDLW 0x86
09CC  6EE9     MOVWF FSR0L, ACCESS
09CE  0E01     MOVLW 0x1
09D0  22EA     ADDWFC FSR0H, F, ACCESS
09D2  50EF     MOVF INDF0, W, ACCESS
09D4  6EE6     MOVWF POSTINC1, ACCESS
09D6  EC26     CALL 0x424C, 0
09D8  F021     NOP
09DA  52E5     MOVF POSTDEC1, F, ACCESS
09DC  D7EF     BRA 0x9BC
274:                   else
09DE  D047     BRA 0xA6E
275:                       while(i<FrRXin) {
09E0  0101     MOVLB 0x1
09E2  51C6     MOVF 0xC6, W, BANKED
09E4  5CDF     SUBWF INDF2, W, ACCESS
09E6  E243     BC 0xA6E
0A6C  D7B9     BRA 0x9E0
276:                       c=FrRXbuf[i++];
09E8  50DF     MOVF INDF2, W, ACCESS
09EA  2ADF     INCF INDF2, F, ACCESS
09EC  6AEA     CLRF FSR0H, ACCESS
09EE  0F86     ADDLW 0x86
09F0  6EE9     MOVWF FSR0L, ACCESS
09F2  0E01     MOVLW 0x1
09F4  22EA     ADDWFC FSR0H, F, ACCESS
09F6  0E01     MOVLW 0x1
09F8  CFEF     MOVFF INDF0, PLUSW2
09FA  FFDB     NOP
277:                       c2=(c>>4)+'0'; if(c2>'9') c2+='A'-'9'-1;
09FC  0E01     MOVLW 0x1
09FE  38DB     SWAPF PLUSW2, W, ACCESS
0A00  0B0F     ANDLW 0xF
0A02  0F30     ADDLW 0x30
0A04  6EE7     MOVWF INDF1, ACCESS
0A06  0E02     MOVLW 0x2
0A08  CFE7     MOVFF INDF1, PLUSW2
0A0A  FFDB     NOP
0A0C  0E02     MOVLW 0x2
0A0E  50DB     MOVF PLUSW2, W, ACCESS
0A10  0839     SUBLW 0x39
0A12  E20A     BC 0xA28
0A14  0E07     MOVLW 0x7
0A16  6E14     MOVWF __tmp_0, ACCESS
0A18  0E02     MOVLW 0x2
0A1A  CFDB     MOVFF PLUSW2, INDF1
0A1C  FFE7     NOP
0A1E  5014     MOVF __tmp_0, W, ACCESS
0A20  26E7     ADDWF INDF1, F, ACCESS
0A22  0E02     MOVLW 0x2
0A24  CFE7     MOVFF INDF1, PLUSW2
0A26  FFDB     NOP
278:                       putchar(c2);
0A28  0E02     MOVLW 0x2
0A2A  CFDB     MOVFF PLUSW2, POSTINC1
0A2C  FFE6     NOP
0A2E  EC26     CALL 0x424C, 0
0A30  F021     NOP
0A32  52E5     MOVF POSTDEC1, F, ACCESS
279:                       c2=(c&15)+'0'; if(c2>'9') c2+='A'-'9'-1;
0A34  0E01     MOVLW 0x1
0A36  50DB     MOVF PLUSW2, W, ACCESS
0A38  0B0F     ANDLW 0xF
0A3A  0F30     ADDLW 0x30
0A3C  6EE7     MOVWF INDF1, ACCESS
0A3E  0E02     MOVLW 0x2
0A40  CFE7     MOVFF INDF1, PLUSW2
0A42  FFDB     NOP
0A44  0E02     MOVLW 0x2
0A46  50DB     MOVF PLUSW2, W, ACCESS
0A48  0839     SUBLW 0x39
0A4A  E20A     BC 0xA60
0A4C  0E07     MOVLW 0x7
0A4E  6E14     MOVWF __tmp_0, ACCESS
0A50  0E02     MOVLW 0x2
0A52  CFDB     MOVFF PLUSW2, INDF1
0A54  FFE7     NOP
0A56  5014     MOVF __tmp_0, W, ACCESS
0A58  26E7     ADDWF INDF1, F, ACCESS
0A5A  0E02     MOVLW 0x2
0A5C  CFE7     MOVFF INDF1, PLUSW2
0A5E  FFDB     NOP
280:                       putchar(c2);
0A60  0E02     MOVLW 0x2
0A62  CFDB     MOVFF PLUSW2, POSTINC1
0A64  FFE6     NOP
0A66  EC26     CALL 0x424C, 0
0A68  F021     NOP
0A6A  52E5     MOVF POSTDEC1, F, ACCESS
281:                   }
282:           
283:                   putchar('\n');
0A6E  0E0A     MOVLW 0xA
0A70  6EE6     MOVWF POSTINC1, ACCESS
0A72  EC26     CALL 0x424C, 0
0A74  F021     NOP
0A76  52E5     MOVF POSTDEC1, F, ACCESS
284:                   FrRXout=FrRXin=0;
0A78  0101     MOVLB 0x1
0A7A  6BC6     CLRF 0xC6, BANKED
0A7C  C1C6     MOVFF FrRXin, FrRXout
0A7E  F1C7     NOP
285:                   FraiseStatus.RXFULL=0;
0A80  0101     MOVLB 0x1
0A82  91CB     BCF cdc_In_len, 0, BANKED
286:           }
0A84  0E03     MOVLW 0x3
0A86  5CE1     SUBWF FSR1L, W, ACCESS
0A88  E202     BC 0xA8E
0A8A  6AE1     CLRF FSR1L, ACCESS
0A8C  52E5     MOVF POSTDEC1, F, ACCESS
0A8E  6EE1     MOVWF FSR1L, ACCESS
0A90  52E5     MOVF POSTDEC1, F, ACCESS
0A92  CFE7     MOVFF INDF1, FSR2L
0A94  FFD9     NOP
0A96  0012     RETURN 0
287:           /*-----------------------------------------------------------------------------------*/
288:           /*          Send fraise ISR message to usb.                                          */
289:           /*-----------------------------------------------------------------------------------*/
290:           void FrSendMessagetoUsb(void)
291:           {
292:               /*	fmessNONE
293:           	,fmessFOUND // polled device has been found
294:           	,fmessLOST  // polled device has been lost
295:           	,fmessCHKSUM // checksum error on a packet from polled device
296:           	,fmessNACK  // destination device didn't acknowledge packet (packet error | buffer full)
297:                   ,fmessTOUT  // destination device didn't acknowledge packet (timeout)
298:               */
299:               if(FraiseStatus.OERR) { FraiseStatus.OERR=0;printf((STRING)"OERR !!\n");}
0A98  0101     MOVLB 0x1
0A9A  ABCB     BTFSS cdc_In_len, 5, BANKED
0A9C  D012     BRA 0xAC2
0A9E  0101     MOVLB 0x1
0AA0  9BCB     BCF cdc_In_len, 5, BANKED
0AA2  0EBA     MOVLW 0xBA
0AA4  6E14     MOVWF __tmp_0, ACCESS
0AA6  0E46     MOVLW 0x46
0AA8  6E15     MOVWF digit_cnt, ACCESS
0AAA  6A16     CLRF prefix_cnt, ACCESS
0AAC  C014     MOVFF __tmp_0, POSTINC1
0AAE  FFE6     NOP
0AB0  C015     MOVFF digit_cnt, POSTINC1
0AB2  FFE6     NOP
0AB4  C016     MOVFF prefix_cnt, POSTINC1
0AB6  FFE6     NOP
0AB8  EC63     CALL 0x48C6, 0
0ABA  F024     NOP
0ABC  52E5     MOVF POSTDEC1, F, ACCESS
0ABE  52E5     MOVF POSTDEC1, F, ACCESS
0AC0  52E5     MOVF POSTDEC1, F, ACCESS
300:               if(FraiseStatus.FERR) { FraiseStatus.FERR=0;printf((STRING)"FERR !!\n");}
0AC2  0101     MOVLB 0x1
0AC4  ADCB     BTFSS cdc_In_len, 6, BANKED
0AC6  D012     BRA 0xAEC
0AC8  0101     MOVLB 0x1
0ACA  9DCB     BCF cdc_In_len, 6, BANKED
0ACC  0EB1     MOVLW 0xB1
0ACE  6E14     MOVWF __tmp_0, ACCESS
0AD0  0E46     MOVLW 0x46
0AD2  6E15     MOVWF digit_cnt, ACCESS
0AD4  6A16     CLRF prefix_cnt, ACCESS
0AD6  C014     MOVFF __tmp_0, POSTINC1
0AD8  FFE6     NOP
0ADA  C015     MOVFF digit_cnt, POSTINC1
0ADC  FFE6     NOP
0ADE  C016     MOVFF prefix_cnt, POSTINC1
0AE0  FFE6     NOP
0AE2  EC63     CALL 0x48C6, 0
0AE4  F024     NOP
0AE6  52E5     MOVF POSTDEC1, F, ACCESS
0AE8  52E5     MOVF POSTDEC1, F, ACCESS
0AEA  52E5     MOVF POSTDEC1, F, ACCESS
301:           
302:               if(FraiseMessage==fmessNONE) return;
0AEC  0101     MOVLB 0x1
0AEE  51D5     MOVF CDC_Inbdp, W, BANKED
0AF0  E101     BNZ 0xAF4
0AF2  D1B4     BRA 0xE5C
303:               switch(FraiseMessage) {
0AF4  0101     MOVLB 0x1
0AF6  51D5     MOVF CDC_Inbdp, W, BANKED
0AF8  0A05     XORLW 0x5
0AFA  E101     BNZ 0xAFE
0AFC  D16E     BRA 0xDDA
0AFE  0A01     XORLW 0x1
0B00  E101     BNZ 0xB04
0B02  D12C     BRA 0xD5C
0B04  0A07     XORLW 0x7
0B06  E101     BNZ 0xB0A
0B08  D0EA     BRA 0xCDE
0B0A  0A01     XORLW 0x1
0B0C  E075     BZ 0xBF8
0B0E  0A03     XORLW 0x3
0B10  E001     BZ 0xB14
0B12  D1A2     BRA 0xE58
304:                   case fmessFOUND : // print "sCdd"
305:                       if(!TST_CHILDOK(AckChild)){
0B14  0E07     MOVLW 0x7
0B16  0101     MOVLB 0x1
0B18  15F9     ANDWF 0xF9, W, BANKED
0B1A  6E15     MOVWF digit_cnt, ACCESS
0B1C  0E01     MOVLW 0x1
0B1E  5215     MOVF digit_cnt, F, ACCESS
0B20  E004     BZ 0xB2A
0B22  46E8     RLNCF WREG, F, ACCESS
0B24  0BFE     ANDLW 0xFE
0B26  0615     DECF digit_cnt, F, ACCESS
0B28  E1FC     BNZ 0xB22
0B2A  6E14     MOVWF __tmp_0, ACCESS
0B2C  0101     MOVLB 0x1
0B2E  51F9     MOVF 0xF9, W, BANKED
0B30  40E8     RRNCF WREG, W, ACCESS
0B32  40E8     RRNCF WREG, W, ACCESS
0B34  40E8     RRNCF WREG, W, ACCESS
0B36  0B1F     ANDLW 0x1F
0B38  6AEA     CLRF FSR0H, ACCESS
0B3A  0FE9     ADDLW 0xE9
0B3C  6EE9     MOVWF FSR0L, ACCESS
0B3E  0E01     MOVLW 0x1
0B40  22EA     ADDWFC FSR0H, F, ACCESS
0B42  50EF     MOVF INDF0, W, ACCESS
0B44  1414     ANDWF __tmp_0, W, ACCESS
0B46  E157     BNZ 0xBF6
306:                           SET_CHILDOK(AckChild);
0B48  0E07     MOVLW 0x7
0B4A  0101     MOVLB 0x1
0B4C  15F9     ANDWF 0xF9, W, BANKED
0B4E  6E15     MOVWF digit_cnt, ACCESS
0B50  0E01     MOVLW 0x1
0B52  5215     MOVF digit_cnt, F, ACCESS
0B54  E004     BZ 0xB5E
0B56  46E8     RLNCF WREG, F, ACCESS
0B58  0BFE     ANDLW 0xFE
0B5A  0615     DECF digit_cnt, F, ACCESS
0B5C  E1FC     BNZ 0xB56
0B5E  6E14     MOVWF __tmp_0, ACCESS
0B60  0101     MOVLB 0x1
0B62  51F9     MOVF 0xF9, W, BANKED
0B64  40E8     RRNCF WREG, W, ACCESS
0B66  40E8     RRNCF WREG, W, ACCESS
0B68  40E8     RRNCF WREG, W, ACCESS
0B6A  0B1F     ANDLW 0x1F
0B6C  6AEA     CLRF FSR0H, ACCESS
0B6E  0FE9     ADDLW 0xE9
0B70  6EE9     MOVWF FSR0L, ACCESS
0B72  0E01     MOVLW 0x1
0B74  22EA     ADDWFC FSR0H, F, ACCESS
0B76  5014     MOVF __tmp_0, W, ACCESS
0B78  12EF     IORWF INDF0, F, ACCESS
307:                           putchar('\n');
0B7A  0E0A     MOVLW 0xA
0B7C  6EE6     MOVWF POSTINC1, ACCESS
0B7E  EC26     CALL 0x424C, 0
0B80  F021     NOP
0B82  52E5     MOVF POSTDEC1, F, ACCESS
308:                           putchar('s');
0B84  0E73     MOVLW 0x73
0B86  6EE6     MOVWF POSTINC1, ACCESS
0B88  EC26     CALL 0x424C, 0
0B8A  F021     NOP
0B8C  52E5     MOVF POSTDEC1, F, ACCESS
309:                           putchar('C');
0B8E  0E43     MOVLW 0x43
0B90  6EE6     MOVWF POSTINC1, ACCESS
0B92  EC26     CALL 0x424C, 0
0B94  F021     NOP
0B96  52E5     MOVF POSTDEC1, F, ACCESS
310:                           putchar(HI_CHAR(AckChild));
0B98  0101     MOVLB 0x1
0B9A  39F9     SWAPF 0xF9, W, BANKED
0B9C  0B0F     ANDLW 0xF
0B9E  6E14     MOVWF __tmp_0, ACCESS
0BA0  0E0A     MOVLW 0xA
0BA2  5C14     SUBWF __tmp_0, W, ACCESS
0BA4  E205     BC 0xBB0
0BA6  0101     MOVLB 0x1
0BA8  39F9     SWAPF 0xF9, W, BANKED
0BAA  0B0F     ANDLW 0xF
0BAC  0F30     ADDLW 0x30
0BAE  D005     BRA 0xBBA
0BB0  0101     MOVLB 0x1
0BB2  39F9     SWAPF 0xF9, W, BANKED
0BB4  0B0F     ANDLW 0xF
0BB6  0FF6     ADDLW 0xF6
0BB8  0F41     ADDLW 0x41
0BBA  6EE6     MOVWF POSTINC1, ACCESS
0BBC  EC26     CALL 0x424C, 0
0BBE  F021     NOP
0BC0  52E5     MOVF POSTDEC1, F, ACCESS
311:                           putchar(LO_CHAR(AckChild));
0BC2  0E0F     MOVLW 0xF
0BC4  0101     MOVLB 0x1
0BC6  15F9     ANDWF 0xF9, W, BANKED
0BC8  6E14     MOVWF __tmp_0, ACCESS
0BCA  0E0A     MOVLW 0xA
0BCC  5C14     SUBWF __tmp_0, W, ACCESS
0BCE  E205     BC 0xBDA
0BD0  0E0F     MOVLW 0xF
0BD2  0101     MOVLB 0x1
0BD4  15F9     ANDWF 0xF9, W, BANKED
0BD6  0F30     ADDLW 0x30
0BD8  D005     BRA 0xBE4
0BDA  0E0F     MOVLW 0xF
0BDC  0101     MOVLB 0x1
0BDE  15F9     ANDWF 0xF9, W, BANKED
0BE0  0FF6     ADDLW 0xF6
0BE2  0F41     ADDLW 0x41
0BE4  6EE6     MOVWF POSTINC1, ACCESS
0BE6  EC26     CALL 0x424C, 0
0BE8  F021     NOP
0BEA  52E5     MOVF POSTDEC1, F, ACCESS
312:                           putchar('\n');
0BEC  0E0A     MOVLW 0xA
0BEE  6EE6     MOVWF POSTINC1, ACCESS
0BF0  EC26     CALL 0x424C, 0
0BF2  F021     NOP
0BF4  52E5     MOVF POSTDEC1, F, ACCESS
313:                       }
314:                       break;
0BF6  D130     BRA 0xE58
315:                   case fmessLOST : // print "scdd"
316:                       if(TST_CHILDOK(AckChild)){
0BF8  0E07     MOVLW 0x7
0BFA  0101     MOVLB 0x1
0BFC  15F9     ANDWF 0xF9, W, BANKED
0BFE  6E15     MOVWF digit_cnt, ACCESS
0C00  0E01     MOVLW 0x1
0C02  5215     MOVF digit_cnt, F, ACCESS
0C04  E004     BZ 0xC0E
0C06  46E8     RLNCF WREG, F, ACCESS
0C08  0BFE     ANDLW 0xFE
0C0A  0615     DECF digit_cnt, F, ACCESS
0C0C  E1FC     BNZ 0xC06
0C0E  6E14     MOVWF __tmp_0, ACCESS
0C10  0101     MOVLB 0x1
0C12  51F9     MOVF 0xF9, W, BANKED
0C14  40E8     RRNCF WREG, W, ACCESS
0C16  40E8     RRNCF WREG, W, ACCESS
0C18  40E8     RRNCF WREG, W, ACCESS
0C1A  0B1F     ANDLW 0x1F
0C1C  6AEA     CLRF FSR0H, ACCESS
0C1E  0FE9     ADDLW 0xE9
0C20  6EE9     MOVWF FSR0L, ACCESS
0C22  0E01     MOVLW 0x1
0C24  22EA     ADDWFC FSR0H, F, ACCESS
0C26  50EF     MOVF INDF0, W, ACCESS
0C28  1414     ANDWF __tmp_0, W, ACCESS
0C2A  E058     BZ 0xCDC
317:                           CLR_CHILDOK(AckChild);
0C2C  0E07     MOVLW 0x7
0C2E  0101     MOVLB 0x1
0C30  15F9     ANDWF 0xF9, W, BANKED
0C32  6E15     MOVWF digit_cnt, ACCESS
0C34  0E01     MOVLW 0x1
0C36  5215     MOVF digit_cnt, F, ACCESS
0C38  E004     BZ 0xC42
0C3A  46E8     RLNCF WREG, F, ACCESS
0C3C  0BFE     ANDLW 0xFE
0C3E  0615     DECF digit_cnt, F, ACCESS
0C40  E1FC     BNZ 0xC3A
0C42  1CE8     COMF WREG, W, ACCESS
0C44  6E14     MOVWF __tmp_0, ACCESS
0C46  0101     MOVLB 0x1
0C48  51F9     MOVF 0xF9, W, BANKED
0C4A  40E8     RRNCF WREG, W, ACCESS
0C4C  40E8     RRNCF WREG, W, ACCESS
0C4E  40E8     RRNCF WREG, W, ACCESS
0C50  0B1F     ANDLW 0x1F
0C52  6AEA     CLRF FSR0H, ACCESS
0C54  0FE9     ADDLW 0xE9
0C56  6EE9     MOVWF FSR0L, ACCESS
0C58  0E01     MOVLW 0x1
0C5A  22EA     ADDWFC FSR0H, F, ACCESS
0C5C  5014     MOVF __tmp_0, W, ACCESS
0C5E  16EF     ANDWF INDF0, F, ACCESS
318:                           putchar('\n');
0C60  0E0A     MOVLW 0xA
0C62  6EE6     MOVWF POSTINC1, ACCESS
0C64  EC26     CALL 0x424C, 0
0C66  F021     NOP
0C68  52E5     MOVF POSTDEC1, F, ACCESS
319:                           putchar('s');
0C6A  0E73     MOVLW 0x73
0C6C  6EE6     MOVWF POSTINC1, ACCESS
0C6E  EC26     CALL 0x424C, 0
0C70  F021     NOP
0C72  52E5     MOVF POSTDEC1, F, ACCESS
320:                           putchar('c');
0C74  0E63     MOVLW 0x63
0C76  6EE6     MOVWF POSTINC1, ACCESS
0C78  EC26     CALL 0x424C, 0
0C7A  F021     NOP
0C7C  52E5     MOVF POSTDEC1, F, ACCESS
321:                           putchar(HI_CHAR(AckChild));
0C7E  0101     MOVLB 0x1
0C80  39F9     SWAPF 0xF9, W, BANKED
0C82  0B0F     ANDLW 0xF
0C84  6E14     MOVWF __tmp_0, ACCESS
0C86  0E0A     MOVLW 0xA
0C88  5C14     SUBWF __tmp_0, W, ACCESS
0C8A  E205     BC 0xC96
0C8C  0101     MOVLB 0x1
0C8E  39F9     SWAPF 0xF9, W, BANKED
0C90  0B0F     ANDLW 0xF
0C92  0F30     ADDLW 0x30
0C94  D005     BRA 0xCA0
0C96  0101     MOVLB 0x1
0C98  39F9     SWAPF 0xF9, W, BANKED
0C9A  0B0F     ANDLW 0xF
0C9C  0FF6     ADDLW 0xF6
0C9E  0F41     ADDLW 0x41
0CA0  6EE6     MOVWF POSTINC1, ACCESS
0CA2  EC26     CALL 0x424C, 0
0CA4  F021     NOP
0CA6  52E5     MOVF POSTDEC1, F, ACCESS
322:                           putchar(LO_CHAR(AckChild));
0CA8  0E0F     MOVLW 0xF
0CAA  0101     MOVLB 0x1
0CAC  15F9     ANDWF 0xF9, W, BANKED
0CAE  6E14     MOVWF __tmp_0, ACCESS
0CB0  0E0A     MOVLW 0xA
0CB2  5C14     SUBWF __tmp_0, W, ACCESS
0CB4  E205     BC 0xCC0
0CB6  0E0F     MOVLW 0xF
0CB8  0101     MOVLB 0x1
0CBA  15F9     ANDWF 0xF9, W, BANKED
0CBC  0F30     ADDLW 0x30
0CBE  D005     BRA 0xCCA
0CC0  0E0F     MOVLW 0xF
0CC2  0101     MOVLB 0x1
0CC4  15F9     ANDWF 0xF9, W, BANKED
0CC6  0FF6     ADDLW 0xF6
0CC8  0F41     ADDLW 0x41
0CCA  6EE6     MOVWF POSTINC1, ACCESS
0CCC  EC26     CALL 0x424C, 0
0CCE  F021     NOP
0CD0  52E5     MOVF POSTDEC1, F, ACCESS
323:                           putchar('\n');
0CD2  0E0A     MOVLW 0xA
0CD4  6EE6     MOVWF POSTINC1, ACCESS
0CD6  EC26     CALL 0x424C, 0
0CD8  F021     NOP
0CDA  52E5     MOVF POSTDEC1, F, ACCESS
324:                       }
325:                       break;
0CDC  D0BD     BRA 0xE58
326:                   case fmessCHKSUM : // print "sxdd"
327:                       putchar('\n');
0CDE  0E0A     MOVLW 0xA
0CE0  6EE6     MOVWF POSTINC1, ACCESS
0CE2  EC26     CALL 0x424C, 0
0CE4  F021     NOP
0CE6  52E5     MOVF POSTDEC1, F, ACCESS
328:                       putchar('s');
0CE8  0E73     MOVLW 0x73
0CEA  6EE6     MOVWF POSTINC1, ACCESS
0CEC  EC26     CALL 0x424C, 0
0CEE  F021     NOP
0CF0  52E5     MOVF POSTDEC1, F, ACCESS
329:                       putchar('x');
0CF2  0E78     MOVLW 0x78
0CF4  6EE6     MOVWF POSTINC1, ACCESS
0CF6  EC26     CALL 0x424C, 0
0CF8  F021     NOP
0CFA  52E5     MOVF POSTDEC1, F, ACCESS
330:                       putchar(HI_CHAR(AckChild));
0CFC  0101     MOVLB 0x1
0CFE  39F9     SWAPF 0xF9, W, BANKED
0D00  0B0F     ANDLW 0xF
0D02  6E14     MOVWF __tmp_0, ACCESS
0D04  0E0A     MOVLW 0xA
0D06  5C14     SUBWF __tmp_0, W, ACCESS
0D08  E205     BC 0xD14
0D0A  0101     MOVLB 0x1
0D0C  39F9     SWAPF 0xF9, W, BANKED
0D0E  0B0F     ANDLW 0xF
0D10  0F30     ADDLW 0x30
0D12  D005     BRA 0xD1E
0D14  0101     MOVLB 0x1
0D16  39F9     SWAPF 0xF9, W, BANKED
0D18  0B0F     ANDLW 0xF
0D1A  0FF6     ADDLW 0xF6
0D1C  0F41     ADDLW 0x41
0D1E  6EE6     MOVWF POSTINC1, ACCESS
0D20  EC26     CALL 0x424C, 0
0D22  F021     NOP
0D24  52E5     MOVF POSTDEC1, F, ACCESS
331:                       putchar(LO_CHAR(AckChild));
0D26  0E0F     MOVLW 0xF
0D28  0101     MOVLB 0x1
0D2A  15F9     ANDWF 0xF9, W, BANKED
0D2C  6E14     MOVWF __tmp_0, ACCESS
0D2E  0E0A     MOVLW 0xA
0D30  5C14     SUBWF __tmp_0, W, ACCESS
0D32  E205     BC 0xD3E
0D34  0E0F     MOVLW 0xF
0D36  0101     MOVLB 0x1
0D38  15F9     ANDWF 0xF9, W, BANKED
0D3A  0F30     ADDLW 0x30
0D3C  D005     BRA 0xD48
0D3E  0E0F     MOVLW 0xF
0D40  0101     MOVLB 0x1
0D42  15F9     ANDWF 0xF9, W, BANKED
0D44  0FF6     ADDLW 0xF6
0D46  0F41     ADDLW 0x41
0D48  6EE6     MOVWF POSTINC1, ACCESS
0D4A  EC26     CALL 0x424C, 0
0D4C  F021     NOP
0D4E  52E5     MOVF POSTDEC1, F, ACCESS
332:                       putchar('\n');
0D50  0E0A     MOVLW 0xA
0D52  6EE6     MOVWF POSTINC1, ACCESS
0D54  EC26     CALL 0x424C, 0
0D56  F021     NOP
0D58  52E5     MOVF POSTDEC1, F, ACCESS
333:                       break;
0D5A  D07E     BRA 0xE58
334:                    case fmessNACK :// print "sndd"
335:                       putchar('\n');
0D5C  0E0A     MOVLW 0xA
0D5E  6EE6     MOVWF POSTINC1, ACCESS
0D60  EC26     CALL 0x424C, 0
0D62  F021     NOP
0D64  52E5     MOVF POSTDEC1, F, ACCESS
336:                       putchar('s');
0D66  0E73     MOVLW 0x73
0D68  6EE6     MOVWF POSTINC1, ACCESS
0D6A  EC26     CALL 0x424C, 0
0D6C  F021     NOP
0D6E  52E5     MOVF POSTDEC1, F, ACCESS
337:                       putchar('a');
0D70  0E61     MOVLW 0x61
0D72  6EE6     MOVWF POSTINC1, ACCESS
0D74  EC26     CALL 0x424C, 0
0D76  F021     NOP
0D78  52E5     MOVF POSTDEC1, F, ACCESS
338:                       putchar(HI_CHAR(AckChild));
0D7A  0101     MOVLB 0x1
0D7C  39F9     SWAPF 0xF9, W, BANKED
0D7E  0B0F     ANDLW 0xF
0D80  6E14     MOVWF __tmp_0, ACCESS
0D82  0E0A     MOVLW 0xA
0D84  5C14     SUBWF __tmp_0, W, ACCESS
0D86  E205     BC 0xD92
0D88  0101     MOVLB 0x1
0D8A  39F9     SWAPF 0xF9, W, BANKED
0D8C  0B0F     ANDLW 0xF
0D8E  0F30     ADDLW 0x30
0D90  D005     BRA 0xD9C
0D92  0101     MOVLB 0x1
0D94  39F9     SWAPF 0xF9, W, BANKED
0D96  0B0F     ANDLW 0xF
0D98  0FF6     ADDLW 0xF6
0D9A  0F41     ADDLW 0x41
0D9C  6EE6     MOVWF POSTINC1, ACCESS
0D9E  EC26     CALL 0x424C, 0
0DA0  F021     NOP
0DA2  52E5     MOVF POSTDEC1, F, ACCESS
339:                       putchar(LO_CHAR(AckChild));
0DA4  0E0F     MOVLW 0xF
0DA6  0101     MOVLB 0x1
0DA8  15F9     ANDWF 0xF9, W, BANKED
0DAA  6E14     MOVWF __tmp_0, ACCESS
0DAC  0E0A     MOVLW 0xA
0DAE  5C14     SUBWF __tmp_0, W, ACCESS
0DB0  E205     BC 0xDBC
0DB2  0E0F     MOVLW 0xF
0DB4  0101     MOVLB 0x1
0DB6  15F9     ANDWF 0xF9, W, BANKED
0DB8  0F30     ADDLW 0x30
0DBA  D005     BRA 0xDC6
0DBC  0E0F     MOVLW 0xF
0DBE  0101     MOVLB 0x1
0DC0  15F9     ANDWF 0xF9, W, BANKED
0DC2  0FF6     ADDLW 0xF6
0DC4  0F41     ADDLW 0x41
0DC6  6EE6     MOVWF POSTINC1, ACCESS
0DC8  EC26     CALL 0x424C, 0
0DCA  F021     NOP
0DCC  52E5     MOVF POSTDEC1, F, ACCESS
340:                       putchar('\n');
0DCE  0E0A     MOVLW 0xA
0DD0  6EE6     MOVWF POSTINC1, ACCESS
0DD2  EC26     CALL 0x424C, 0
0DD4  F021     NOP
0DD6  52E5     MOVF POSTDEC1, F, ACCESS
341:                       break;
0DD8  D03F     BRA 0xE58
342:                    case fmessTOUT :// print "sTdd"
343:                       putchar('\n');
0DDA  0E0A     MOVLW 0xA
0DDC  6EE6     MOVWF POSTINC1, ACCESS
0DDE  EC26     CALL 0x424C, 0
0DE0  F021     NOP
0DE2  52E5     MOVF POSTDEC1, F, ACCESS
344:                       putchar('s');
0DE4  0E73     MOVLW 0x73
0DE6  6EE6     MOVWF POSTINC1, ACCESS
0DE8  EC26     CALL 0x424C, 0
0DEA  F021     NOP
0DEC  52E5     MOVF POSTDEC1, F, ACCESS
345:                       putchar('T');
0DEE  0E54     MOVLW 0x54
0DF0  6EE6     MOVWF POSTINC1, ACCESS
0DF2  EC26     CALL 0x424C, 0
0DF4  F021     NOP
0DF6  52E5     MOVF POSTDEC1, F, ACCESS
346:                       putchar(HI_CHAR(AckChild));
0DF8  0101     MOVLB 0x1
0DFA  39F9     SWAPF 0xF9, W, BANKED
0DFC  0B0F     ANDLW 0xF
0DFE  6E14     MOVWF __tmp_0, ACCESS
0E00  0E0A     MOVLW 0xA
0E02  5C14     SUBWF __tmp_0, W, ACCESS
0E04  E205     BC 0xE10
0E06  0101     MOVLB 0x1
0E08  39F9     SWAPF 0xF9, W, BANKED
0E0A  0B0F     ANDLW 0xF
0E0C  0F30     ADDLW 0x30
0E0E  D005     BRA 0xE1A
0E10  0101     MOVLB 0x1
0E12  39F9     SWAPF 0xF9, W, BANKED
0E14  0B0F     ANDLW 0xF
0E16  0FF6     ADDLW 0xF6
0E18  0F41     ADDLW 0x41
0E1A  6EE6     MOVWF POSTINC1, ACCESS
0E1C  EC26     CALL 0x424C, 0
0E1E  F021     NOP
0E20  52E5     MOVF POSTDEC1, F, ACCESS
347:                       putchar(LO_CHAR(AckChild));
0E22  0E0F     MOVLW 0xF
0E24  0101     MOVLB 0x1
0E26  15F9     ANDWF 0xF9, W, BANKED
0E28  6E14     MOVWF __tmp_0, ACCESS
0E2A  0E0A     MOVLW 0xA
0E2C  5C14     SUBWF __tmp_0, W, ACCESS
0E2E  E205     BC 0xE3A
0E30  0E0F     MOVLW 0xF
0E32  0101     MOVLB 0x1
0E34  15F9     ANDWF 0xF9, W, BANKED
0E36  0F30     ADDLW 0x30
0E38  D005     BRA 0xE44
0E3A  0E0F     MOVLW 0xF
0E3C  0101     MOVLB 0x1
0E3E  15F9     ANDWF 0xF9, W, BANKED
0E40  0FF6     ADDLW 0xF6
0E42  0F41     ADDLW 0x41
0E44  6EE6     MOVWF POSTINC1, ACCESS
0E46  EC26     CALL 0x424C, 0
0E48  F021     NOP
0E4A  52E5     MOVF POSTDEC1, F, ACCESS
348:                       putchar('\n');
0E4C  0E0A     MOVLW 0xA
0E4E  6EE6     MOVWF POSTINC1, ACCESS
0E50  EC26     CALL 0x424C, 0
0E52  F021     NOP
0E54  52E5     MOVF POSTDEC1, F, ACCESS
349:                       break;
0E56  D000     BRA 0xE58
350:               }
351:               FraiseMessage=fmessNONE;
0E58  0101     MOVLB 0x1
0E5A  6BD5     CLRF CDC_Inbdp, BANKED
352:           }
0E5C  0012     RETURN 0
353:           
354:           /*-----------------------------------------------------------------------------------*/
355:           /*          Analyse packet from usb, build a packet to send to fraise if applicable. */
356:           /*-----------------------------------------------------------------------------------*/
357:           
358:           #define FrTXPacketInit(b) { FrTXpacket_i=1 ; FrTXchksum=FrTXpacket[0]=(b);}
359:           #define FrTXPacketData(b) { FrTXchksum+=FrTXpacket[FrTXpacket_i]=(b);FrTXpacket_i++;}
360:           #define FrTXPacketClose() { FrTXpacket[FrTXpacket_i]=-(char)FrTXchksum; FrTXpacket_len=FrTXpacket_i+1; }
361:           
362:           #define FrTXPacketLaunch() \
363:           {		\
364:           	Serial_Init_Driver(); \
365:                   TXSTAbits.TX9D=1;		\
366:           	TXREG=AckChild=FrTXpacket[0]; 		\
367:           	TXSTAbits.TX9D=0;		\
368:           	FrTXpacket_i=1;		\
369:           	FraiseState=fOUT;		\
370:           	PIE1bits.TXIE=1;		\
371:           }
372:           
373:           #define FrTXPacketLaunchBl() \
374:           {		\
375:           	Serial_Init_Driver(); \
376:           	TXREG=FrTXpacket[0]; 		\
377:           	FrTXpacket_i=1;		\
378:           	FraiseState=fBLOUT;		\
379:           	PIE1bits.TXIE=1;		\
380:           }
381:           
382:           
383:           void FrGetLineFromUsb(void)
0E5E  CFD9     MOVFF FSR2L, POSTINC1
0E60  FFE6     NOP
0E62  CFE1     MOVFF FSR1L, FSR2L
0E64  FFD9     NOP
0E66  0E05     MOVLW 0x5
0E68  26E1     ADDWF FSR1L, F, ACCESS
384:           {
385:           #define GETNEXTCHAR() LineFromUsb[i++]
386:           #define PEEKNEXTCHAR() LineFromUsb[i]
387:           #define SKIPNEXTCHAR() i++
388:           #define LINE_HAS_CHAR() (i<LineFromUsbLen)
389:           
390:           	unsigned char len,c,c2,n;//,txout_end;
391:           	unsigned char i;
392:           
393:                   if(!FrGotLineFromUsb) goto discard;
0E6A  0101     MOVLB 0x1
0E6C  5141     MOVF 0x41, W, BANKED
0E6E  E102     BNZ 0xE74
0E70  EF64     GOTO 0x18C8
0E72  F00C     NOP
394:                   
395:                   //printf((const far rom char*)"FrGetLineFromUsb()\n");
396:                   //while(TXSTAbits.TRMT==0); //wait end of serial transmit
397:           
398:           	FraiseStatus.TX_NEEDACK=0;
0E74  0101     MOVLB 0x1
0E76  97CB     BCF cdc_In_len, 3, BANKED
399:           	FraiseStatus.TXCHAR=0;
0E78  0101     MOVLB 0x1
0E7A  95CB     BCF cdc_In_len, 2, BANKED
400:           
401:           	len=LineFromUsbLen;
0E7C  C140     MOVFF LineFromUsbLen, INDF2
0E7E  FFDF     NOP
402:                   i=0;
0E80  0E04     MOVLW 0x4
0E82  6ADB     CLRF PLUSW2, ACCESS
403:                   
404:           	c=GETNEXTCHAR(); //1st byte = command (or hi nibble of address)
0E84  0E04     MOVLW 0x4
0E86  CFDB     MOVFF PLUSW2, PRODL
0E88  FFF3     NOP
0E8A  2ADB     INCF PLUSW2, F, ACCESS
0E8C  50F3     MOVF PRODL, W, ACCESS
0E8E  6AEA     CLRF FSR0H, ACCESS
0E90  0F00     ADDLW 0x0
0E92  6EE9     MOVWF FSR0L, ACCESS
0E94  0E01     MOVLW 0x1
0E96  22EA     ADDWFC FSR0H, F, ACCESS
0E98  0E01     MOVLW 0x1
0E9A  CFEF     MOVFF INDF0, PLUSW2
0E9C  FFDB     NOP
405:           	
406:           	//printf((const far rom char*)"parsing ; 1st char : %c\n",c);
407:                   if(c=='#') {
0E9E  0E01     MOVLW 0x1
0EA0  50DB     MOVF PLUSW2, W, ACCESS
0EA2  0823     SUBLW 0x23
0EA4  E001     BZ 0xEA8
0EA6  D303     BRA 0x14AE
408:                           //printf((const far rom char*)"system command...\n");
409:           		//****************** system command , begining by '#':   **********************
410:           		if(len<2) goto discard;
0EA8  0E02     MOVLW 0x2
0EAA  5CDF     SUBWF INDF2, W, ACCESS
0EAC  E202     BC 0xEB2
0EAE  EF64     GOTO 0x18C8
0EB0  F00C     NOP
411:           		c=GETNEXTCHAR(); //what is the command ?
0EB2  0E04     MOVLW 0x4
0EB4  CFDB     MOVFF PLUSW2, PRODL
0EB6  FFF3     NOP
0EB8  2ADB     INCF PLUSW2, F, ACCESS
0EBA  50F3     MOVF PRODL, W, ACCESS
0EBC  6AEA     CLRF FSR0H, ACCESS
0EBE  0F00     ADDLW 0x0
0EC0  6EE9     MOVWF FSR0L, ACCESS
0EC2  0E01     MOVLW 0x1
0EC4  22EA     ADDWFC FSR0H, F, ACCESS
0EC6  0E01     MOVLW 0x1
0EC8  CFEF     MOVFF INDF0, PLUSW2
0ECA  FFDB     NOP
412:                           //printf((const far rom char*)"2nd char : %c\n",c);
413:           		if(c=='S'){ // start device pulling
0ECC  0E01     MOVLW 0x1
0ECE  50DB     MOVF PLUSW2, W, ACCESS
0ED0  0853     SUBLW 0x53
0ED2  E001     BZ 0xED6
0ED4  D0B1     BRA 0x1038
414:           			if(len!=4) goto discard; //incorrect  packet...
0ED6  0E04     MOVLW 0x4
0ED8  5CDF     SUBWF INDF2, W, ACCESS
0EDA  E002     BZ 0xEE0
0EDC  EF64     GOTO 0x18C8
0EDE  F00C     NOP
415:           			c=GETNEXTCHAR();
0EE0  0E04     MOVLW 0x4
0EE2  CFDB     MOVFF PLUSW2, PRODL
0EE4  FFF3     NOP
0EE6  2ADB     INCF PLUSW2, F, ACCESS
0EE8  50F3     MOVF PRODL, W, ACCESS
0EEA  6AEA     CLRF FSR0H, ACCESS
0EEC  0F00     ADDLW 0x0
0EEE  6EE9     MOVWF FSR0L, ACCESS
0EF0  0E01     MOVLW 0x1
0EF2  22EA     ADDWFC FSR0H, F, ACCESS
0EF4  0E01     MOVLW 0x1
0EF6  CFEF     MOVFF INDF0, PLUSW2
0EF8  FFDB     NOP
416:           			c-='0';if (c>9) c-='A'-'9'-1;
0EFA  0E30     MOVLW 0x30
0EFC  6E14     MOVWF __tmp_0, ACCESS
0EFE  0E01     MOVLW 0x1
0F00  CFDB     MOVFF PLUSW2, INDF1
0F02  FFE7     NOP
0F04  5014     MOVF __tmp_0, W, ACCESS
0F06  5EE7     SUBWF INDF1, F, ACCESS
0F08  0E01     MOVLW 0x1
0F0A  CFE7     MOVFF INDF1, PLUSW2
0F0C  FFDB     NOP
0F0E  0E01     MOVLW 0x1
0F10  50DB     MOVF PLUSW2, W, ACCESS
0F12  0809     SUBLW 0x9
0F14  E20A     BC 0xF2A
0F16  0E07     MOVLW 0x7
0F18  6E14     MOVWF __tmp_0, ACCESS
0F1A  0E01     MOVLW 0x1
0F1C  CFDB     MOVFF PLUSW2, INDF1
0F1E  FFE7     NOP
0F20  5014     MOVF __tmp_0, W, ACCESS
0F22  5EE7     SUBWF INDF1, F, ACCESS
0F24  0E01     MOVLW 0x1
0F26  CFE7     MOVFF INDF1, PLUSW2
0F28  FFDB     NOP
417:           			c2=GETNEXTCHAR();
0F2A  0E04     MOVLW 0x4
0F2C  CFDB     MOVFF PLUSW2, PRODL
0F2E  FFF3     NOP
0F30  2ADB     INCF PLUSW2, F, ACCESS
0F32  50F3     MOVF PRODL, W, ACCESS
0F34  6AEA     CLRF FSR0H, ACCESS
0F36  0F00     ADDLW 0x0
0F38  6EE9     MOVWF FSR0L, ACCESS
0F3A  0E01     MOVLW 0x1
0F3C  22EA     ADDWFC FSR0H, F, ACCESS
0F3E  0E02     MOVLW 0x2
0F40  CFEF     MOVFF INDF0, PLUSW2
0F42  FFDB     NOP
418:           			c2-='0';if (c2>9) c2-='A'-'9'-1;
0F44  0E30     MOVLW 0x30
0F46  6E14     MOVWF __tmp_0, ACCESS
0F48  0E02     MOVLW 0x2
0F4A  CFDB     MOVFF PLUSW2, INDF1
0F4C  FFE7     NOP
0F4E  5014     MOVF __tmp_0, W, ACCESS
0F50  5EE7     SUBWF INDF1, F, ACCESS
0F52  0E02     MOVLW 0x2
0F54  CFE7     MOVFF INDF1, PLUSW2
0F56  FFDB     NOP
0F58  0E02     MOVLW 0x2
0F5A  50DB     MOVF PLUSW2, W, ACCESS
0F5C  0809     SUBLW 0x9
0F5E  E20A     BC 0xF74
0F60  0E07     MOVLW 0x7
0F62  6E14     MOVWF __tmp_0, ACCESS
0F64  0E02     MOVLW 0x2
0F66  CFDB     MOVFF PLUSW2, INDF1
0F68  FFE7     NOP
0F6A  5014     MOVF __tmp_0, W, ACCESS
0F6C  5EE7     SUBWF INDF1, F, ACCESS
0F6E  0E02     MOVLW 0x2
0F70  CFE7     MOVFF INDF1, PLUSW2
0F72  FFDB     NOP
419:           			if((c>15)||(c2>15)) goto discard; //invalid packet
0F74  0E01     MOVLW 0x1
0F76  50DB     MOVF PLUSW2, W, ACCESS
0F78  080F     SUBLW 0xF
0F7A  E304     BNC 0xF84
0F7C  0E02     MOVLW 0x2
0F7E  50DB     MOVF PLUSW2, W, ACCESS
0F80  080F     SUBLW 0xF
0F82  E202     BC 0xF88
0F84  EF64     GOTO 0x18C8
0F86  F00C     NOP
420:           			n=c2+(c<<4);
0F88  0E02     MOVLW 0x2
0F8A  CFDB     MOVFF PLUSW2, POSTINC1
0F8C  FFE6     NOP
0F8E  0E01     MOVLW 0x1
0F90  38DB     SWAPF PLUSW2, W, ACCESS
0F92  0BF0     ANDLW 0xF0
0F94  52E5     MOVF POSTDEC1, F, ACCESS
0F96  24E7     ADDWF INDF1, W, ACCESS
0F98  6EE7     MOVWF INDF1, ACCESS
0F9A  0E03     MOVLW 0x3
0F9C  CFE7     MOVFF INDF1, PLUSW2
0F9E  FFDB     NOP
421:           			if((n>0)&&(n<128)) {
0FA0  0E03     MOVLW 0x3
0FA2  50DB     MOVF PLUSW2, W, ACCESS
0FA4  0800     SUBLW 0x0
0FA6  E245     BC 0x1032
0FA8  0E03     MOVLW 0x3
0FAA  50DB     MOVF PLUSW2, W, ACCESS
0FAC  6E14     MOVWF __tmp_0, ACCESS
0FAE  6A15     CLRF digit_cnt, ACCESS
0FB0  90D8     BCF STATUS, 0, ACCESS
0FB2  5015     MOVF digit_cnt, W, ACCESS
0FB4  E604     BN 0xFBE
0FB6  0E80     MOVLW 0x80
0FB8  5C14     SUBWF __tmp_0, W, ACCESS
0FBA  0E00     MOVLW 0x0
0FBC  5815     SUBWFB digit_cnt, W, ACCESS
0FBE  E239     BC 0x1032
422:           				SET_CHILD(n);
0FC0  0E03     MOVLW 0x3
0FC2  50DB     MOVF PLUSW2, W, ACCESS
0FC4  0B07     ANDLW 0x7
0FC6  6E15     MOVWF digit_cnt, ACCESS
0FC8  0E01     MOVLW 0x1
0FCA  5215     MOVF digit_cnt, F, ACCESS
0FCC  E004     BZ 0xFD6
0FCE  46E8     RLNCF WREG, F, ACCESS
0FD0  0BFE     ANDLW 0xFE
0FD2  0615     DECF digit_cnt, F, ACCESS
0FD4  E1FC     BNZ 0xFCE
0FD6  6E14     MOVWF __tmp_0, ACCESS
0FD8  0E03     MOVLW 0x3
0FDA  40DB     RRNCF PLUSW2, W, ACCESS
0FDC  40E8     RRNCF WREG, W, ACCESS
0FDE  40E8     RRNCF WREG, W, ACCESS
0FE0  0B1F     ANDLW 0x1F
0FE2  6AEA     CLRF FSR0H, ACCESS
0FE4  0FD9     ADDLW 0xD9
0FE6  6EE9     MOVWF FSR0L, ACCESS
0FE8  0E01     MOVLW 0x1
0FEA  22EA     ADDWFC FSR0H, F, ACCESS
0FEC  5014     MOVF __tmp_0, W, ACCESS
0FEE  12EF     IORWF INDF0, F, ACCESS
423:           				CLR_CHILDOK(n);
0FF0  0E03     MOVLW 0x3
0FF2  50DB     MOVF PLUSW2, W, ACCESS
0FF4  0B07     ANDLW 0x7
0FF6  6E15     MOVWF digit_cnt, ACCESS
0FF8  0E01     MOVLW 0x1
0FFA  5215     MOVF digit_cnt, F, ACCESS
0FFC  E004     BZ 0x1006
0FFE  46E8     RLNCF WREG, F, ACCESS
1000  0BFE     ANDLW 0xFE
1002  0615     DECF digit_cnt, F, ACCESS
1004  E1FC     BNZ 0xFFE
1006  1CE8     COMF WREG, W, ACCESS
1008  6E14     MOVWF __tmp_0, ACCESS
100A  0E03     MOVLW 0x3
100C  40DB     RRNCF PLUSW2, W, ACCESS
100E  40E8     RRNCF WREG, W, ACCESS
1010  40E8     RRNCF WREG, W, ACCESS
1012  0B1F     ANDLW 0x1F
1014  6AEA     CLRF FSR0H, ACCESS
1016  0FE9     ADDLW 0xE9
1018  6EE9     MOVWF FSR0L, ACCESS
101A  0E01     MOVLW 0x1
101C  22EA     ADDWFC FSR0H, F, ACCESS
101E  5014     MOVF __tmp_0, W, ACCESS
1020  16EF     ANDWF INDF0, F, ACCESS
424:           				if(MaxPolledChild<n) MaxPolledChild=n;
1022  0E03     MOVLW 0x3
1024  50DB     MOVF PLUSW2, W, ACCESS
1026  0101     MOVLB 0x1
1028  5DD8     SUBWF cdc_trf_state, W, BANKED
102A  E203     BC 0x1032
102C  0E03     MOVLW 0x3
102E  CFDB     MOVFF PLUSW2, MaxPolledChild
1030  F1D8     NOP
425:           			}
426:           			goto discard;
1032  EF64     GOTO 0x18C8
1034  F00C     NOP
427:           		}	
428:           		else if(c=='C'){ // stop device pulling
1036  D239     BRA 0x14AA
1038  0E01     MOVLW 0x1
103A  50DB     MOVF PLUSW2, W, ACCESS
103C  0843     SUBLW 0x43
103E  E001     BZ 0x1042
1040  D0A8     BRA 0x1192
429:           			if(len!=4) goto discard; //incorrect  packet...
1042  0E04     MOVLW 0x4
1044  5CDF     SUBWF INDF2, W, ACCESS
1046  E002     BZ 0x104C
1048  EF64     GOTO 0x18C8
104A  F00C     NOP
430:           			c=GETNEXTCHAR();
104C  0E04     MOVLW 0x4
104E  CFDB     MOVFF PLUSW2, PRODL
1050  FFF3     NOP
1052  2ADB     INCF PLUSW2, F, ACCESS
1054  50F3     MOVF PRODL, W, ACCESS
1056  6AEA     CLRF FSR0H, ACCESS
1058  0F00     ADDLW 0x0
105A  6EE9     MOVWF FSR0L, ACCESS
105C  0E01     MOVLW 0x1
105E  22EA     ADDWFC FSR0H, F, ACCESS
1060  0E01     MOVLW 0x1
1062  CFEF     MOVFF INDF0, PLUSW2
1064  FFDB     NOP
431:           			c-='0';if (c>9) c-='A'-'9'-1;
1066  0E30     MOVLW 0x30
1068  6E14     MOVWF __tmp_0, ACCESS
106A  0E01     MOVLW 0x1
106C  CFDB     MOVFF PLUSW2, INDF1
106E  FFE7     NOP
1070  5014     MOVF __tmp_0, W, ACCESS
1072  5EE7     SUBWF INDF1, F, ACCESS
1074  0E01     MOVLW 0x1
1076  CFE7     MOVFF INDF1, PLUSW2
1078  FFDB     NOP
107A  0E01     MOVLW 0x1
107C  50DB     MOVF PLUSW2, W, ACCESS
107E  0809     SUBLW 0x9
1080  E20A     BC 0x1096
1082  0E07     MOVLW 0x7
1084  6E14     MOVWF __tmp_0, ACCESS
1086  0E01     MOVLW 0x1
1088  CFDB     MOVFF PLUSW2, INDF1
108A  FFE7     NOP
108C  5014     MOVF __tmp_0, W, ACCESS
108E  5EE7     SUBWF INDF1, F, ACCESS
1090  0E01     MOVLW 0x1
1092  CFE7     MOVFF INDF1, PLUSW2
1094  FFDB     NOP
432:           			c2=GETNEXTCHAR();
1096  0E04     MOVLW 0x4
1098  CFDB     MOVFF PLUSW2, PRODL
109A  FFF3     NOP
109C  2ADB     INCF PLUSW2, F, ACCESS
109E  50F3     MOVF PRODL, W, ACCESS
10A0  6AEA     CLRF FSR0H, ACCESS
10A2  0F00     ADDLW 0x0
10A4  6EE9     MOVWF FSR0L, ACCESS
10A6  0E01     MOVLW 0x1
10A8  22EA     ADDWFC FSR0H, F, ACCESS
10AA  0E02     MOVLW 0x2
10AC  CFEF     MOVFF INDF0, PLUSW2
10AE  FFDB     NOP
433:           			c2-='0';if (c2>9) c2-='A'-'9'-1;
10B0  0E30     MOVLW 0x30
10B2  6E14     MOVWF __tmp_0, ACCESS
10B4  0E02     MOVLW 0x2
10B6  CFDB     MOVFF PLUSW2, INDF1
10B8  FFE7     NOP
10BA  5014     MOVF __tmp_0, W, ACCESS
10BC  5EE7     SUBWF INDF1, F, ACCESS
10BE  0E02     MOVLW 0x2
10C0  CFE7     MOVFF INDF1, PLUSW2
10C2  FFDB     NOP
10C4  0E02     MOVLW 0x2
10C6  50DB     MOVF PLUSW2, W, ACCESS
10C8  0809     SUBLW 0x9
10CA  E20A     BC 0x10E0
10CC  0E07     MOVLW 0x7
10CE  6E14     MOVWF __tmp_0, ACCESS
10D0  0E02     MOVLW 0x2
10D2  CFDB     MOVFF PLUSW2, INDF1
10D4  FFE7     NOP
10D6  5014     MOVF __tmp_0, W, ACCESS
10D8  5EE7     SUBWF INDF1, F, ACCESS
10DA  0E02     MOVLW 0x2
10DC  CFE7     MOVFF INDF1, PLUSW2
10DE  FFDB     NOP
434:           			if((c>15)||(c2>15)) goto discard; //invalid packet
10E0  0E01     MOVLW 0x1
10E2  50DB     MOVF PLUSW2, W, ACCESS
10E4  080F     SUBLW 0xF
10E6  E304     BNC 0x10F0
10E8  0E02     MOVLW 0x2
10EA  50DB     MOVF PLUSW2, W, ACCESS
10EC  080F     SUBLW 0xF
10EE  E201     BC 0x10F2
10F0  D3EB     BRA 0x18C8
435:           			n=c2+(c<<4);
10F2  0E02     MOVLW 0x2
10F4  CFDB     MOVFF PLUSW2, POSTINC1
10F6  FFE6     NOP
10F8  0E01     MOVLW 0x1
10FA  38DB     SWAPF PLUSW2, W, ACCESS
10FC  0BF0     ANDLW 0xF0
10FE  52E5     MOVF POSTDEC1, F, ACCESS
1100  24E7     ADDWF INDF1, W, ACCESS
1102  6EE7     MOVWF INDF1, ACCESS
1104  0E03     MOVLW 0x3
1106  CFE7     MOVFF INDF1, PLUSW2
1108  FFDB     NOP
436:           			if((n>0)&&(n<128)) {
110A  0E03     MOVLW 0x3
110C  50DB     MOVF PLUSW2, W, ACCESS
110E  0800     SUBLW 0x0
1110  E23E     BC 0x118E
1112  0E03     MOVLW 0x3
1114  50DB     MOVF PLUSW2, W, ACCESS
1116  6E14     MOVWF __tmp_0, ACCESS
1118  6A15     CLRF digit_cnt, ACCESS
111A  90D8     BCF STATUS, 0, ACCESS
111C  5015     MOVF digit_cnt, W, ACCESS
111E  E604     BN 0x1128
1120  0E80     MOVLW 0x80
1122  5C14     SUBWF __tmp_0, W, ACCESS
1124  0E00     MOVLW 0x0
1126  5815     SUBWFB digit_cnt, W, ACCESS
1128  E232     BC 0x118E
437:           				CLR_CHILDOK(n);
112A  0E03     MOVLW 0x3
112C  50DB     MOVF PLUSW2, W, ACCESS
112E  0B07     ANDLW 0x7
1130  6E15     MOVWF digit_cnt, ACCESS
1132  0E01     MOVLW 0x1
1134  5215     MOVF digit_cnt, F, ACCESS
1136  E004     BZ 0x1140
1138  46E8     RLNCF WREG, F, ACCESS
113A  0BFE     ANDLW 0xFE
113C  0615     DECF digit_cnt, F, ACCESS
113E  E1FC     BNZ 0x1138
1140  1CE8     COMF WREG, W, ACCESS
1142  6E14     MOVWF __tmp_0, ACCESS
1144  0E03     MOVLW 0x3
1146  40DB     RRNCF PLUSW2, W, ACCESS
1148  40E8     RRNCF WREG, W, ACCESS
114A  40E8     RRNCF WREG, W, ACCESS
114C  0B1F     ANDLW 0x1F
114E  6AEA     CLRF FSR0H, ACCESS
1150  0FE9     ADDLW 0xE9
1152  6EE9     MOVWF FSR0L, ACCESS
1154  0E01     MOVLW 0x1
1156  22EA     ADDWFC FSR0H, F, ACCESS
1158  5014     MOVF __tmp_0, W, ACCESS
115A  16EF     ANDWF INDF0, F, ACCESS
438:           				CLR_CHILD(n);
115C  0E03     MOVLW 0x3
115E  50DB     MOVF PLUSW2, W, ACCESS
1160  0B07     ANDLW 0x7
1162  6E15     MOVWF digit_cnt, ACCESS
1164  0E01     MOVLW 0x1
1166  5215     MOVF digit_cnt, F, ACCESS
1168  E004     BZ 0x1172
116A  46E8     RLNCF WREG, F, ACCESS
116C  0BFE     ANDLW 0xFE
116E  0615     DECF digit_cnt, F, ACCESS
1170  E1FC     BNZ 0x116A
1172  1CE8     COMF WREG, W, ACCESS
1174  6E14     MOVWF __tmp_0, ACCESS
1176  0E03     MOVLW 0x3
1178  40DB     RRNCF PLUSW2, W, ACCESS
117A  40E8     RRNCF WREG, W, ACCESS
117C  40E8     RRNCF WREG, W, ACCESS
117E  0B1F     ANDLW 0x1F
1180  6AEA     CLRF FSR0H, ACCESS
1182  0FD9     ADDLW 0xD9
1184  6EE9     MOVWF FSR0L, ACCESS
1186  0E01     MOVLW 0x1
1188  22EA     ADDWFC FSR0H, F, ACCESS
118A  5014     MOVF __tmp_0, W, ACCESS
118C  16EF     ANDWF INDF0, F, ACCESS
439:           			}
440:           			goto discard;
118E  D39C     BRA 0x18C8
441:           		}		
442:           		else if(c=='i'){
1190  D18C     BRA 0x14AA
1192  0E01     MOVLW 0x1
1194  50DB     MOVF PLUSW2, W, ACCESS
1196  0869     SUBLW 0x69
1198  E114     BNZ 0x11C2
443:           			printf((STRING)"s fraise init...\n");
119A  0E9F     MOVLW 0x9F
119C  6E14     MOVWF __tmp_0, ACCESS
119E  0E46     MOVLW 0x46
11A0  6E15     MOVWF digit_cnt, ACCESS
11A2  6A16     CLRF prefix_cnt, ACCESS
11A4  C014     MOVFF __tmp_0, POSTINC1
11A6  FFE6     NOP
11A8  C015     MOVFF digit_cnt, POSTINC1
11AA  FFE6     NOP
11AC  C016     MOVFF prefix_cnt, POSTINC1
11AE  FFE6     NOP
11B0  EC63     CALL 0x48C6, 0
11B2  F024     NOP
11B4  52E5     MOVF POSTDEC1, F, ACCESS
11B6  52E5     MOVF POSTDEC1, F, ACCESS
11B8  52E5     MOVF POSTDEC1, F, ACCESS
444:           			FraiseInit();
11BA  EC34     CALL 0x868, 0
11BC  F004     NOP
445:           			goto discard;
11BE  D384     BRA 0x18C8
446:           		}
447:           		else if(c=='L'){ //get log
11C0  D174     BRA 0x14AA
11C2  0E01     MOVLW 0x1
11C4  50DB     MOVF PLUSW2, W, ACCESS
11C6  084C     SUBLW 0x4C
11C8  E001     BZ 0x11CC
11CA  D0A2     BRA 0x1310
448:           			printf((STRING)"\ns fraise log :\n");
11CC  0E8E     MOVLW 0x8E
11CE  6E14     MOVWF __tmp_0, ACCESS
11D0  0E46     MOVLW 0x46
11D2  6E15     MOVWF digit_cnt, ACCESS
11D4  6A16     CLRF prefix_cnt, ACCESS
11D6  C014     MOVFF __tmp_0, POSTINC1
11D8  FFE6     NOP
11DA  C015     MOVFF digit_cnt, POSTINC1
11DC  FFE6     NOP
11DE  C016     MOVFF prefix_cnt, POSTINC1
11E0  FFE6     NOP
11E2  EC63     CALL 0x48C6, 0
11E4  F024     NOP
11E6  52E5     MOVF POSTDEC1, F, ACCESS
11E8  52E5     MOVF POSTDEC1, F, ACCESS
11EA  52E5     MOVF POSTDEC1, F, ACCESS
449:           			c2=0;
11EC  0E02     MOVLW 0x2
11EE  6ADB     CLRF PLUSW2, ACCESS
450:                                   printf((STRING)"FraiseState : %d ; FraiseStatus: %d\n",FraiseState,FraiseStatus);
11F0  C1CB     MOVFF FraiseStatus, POSTINC1
11F2  FFE6     NOP
11F4  C1D4     MOVFF FraiseState, __tmp_0
11F6  F014     NOP
11F8  6A15     CLRF digit_cnt, ACCESS
11FA  BE14     BTFSC __tmp_0, 7, ACCESS
11FC  6815     SETF digit_cnt, ACCESS
11FE  C014     MOVFF __tmp_0, POSTINC1
1200  FFE6     NOP
1202  C015     MOVFF digit_cnt, POSTINC1
1204  FFE6     NOP
1206  0E69     MOVLW 0x69
1208  6E16     MOVWF prefix_cnt, ACCESS
120A  0E46     MOVLW 0x46
120C  6E17     MOVWF sign_char, ACCESS
120E  6A18     CLRF buf, ACCESS
1210  C016     MOVFF prefix_cnt, POSTINC1
1212  FFE6     NOP
1214  C017     MOVFF sign_char, POSTINC1
1216  FFE6     NOP
1218  C018     MOVFF buf, POSTINC1
121A  FFE6     NOP
121C  EC63     CALL 0x48C6, 0
121E  F024     NOP
1220  6E19     MOVWF 0x19, ACCESS
1222  0E06     MOVLW 0x6
1224  5EE1     SUBWF FSR1L, F, ACCESS
1226  5019     MOVF 0x19, W, ACCESS
451:           			for(n=1;n<=MaxPolledChild;n++){
1228  0E01     MOVLW 0x1
122A  6EF3     MOVWF PRODL, ACCESS
122C  0E03     MOVLW 0x3
122E  CFF3     MOVFF PRODL, PLUSW2
1230  FFDB     NOP
1232  0E03     MOVLW 0x3
1234  CFDB     MOVFF PLUSW2, __tmp_0
1236  F014     NOP
1238  0101     MOVLB 0x1
123A  51D8     MOVF cdc_trf_state, W, BANKED
123C  80D8     BSF STATUS, 0, ACCESS
123E  5414     SUBFWB __tmp_0, W, ACCESS
1240  E360     BNC 0x1302
12FC  0E03     MOVLW 0x3
12FE  2ADB     INCF PLUSW2, F, ACCESS
1300  D798     BRA 0x1232
452:           				if (TST_CHILD(n)){
1242  0E03     MOVLW 0x3
1244  50DB     MOVF PLUSW2, W, ACCESS
1246  0B07     ANDLW 0x7
1248  6E15     MOVWF digit_cnt, ACCESS
124A  0E01     MOVLW 0x1
124C  5215     MOVF digit_cnt, F, ACCESS
124E  E004     BZ 0x1258
1250  46E8     RLNCF WREG, F, ACCESS
1252  0BFE     ANDLW 0xFE
1254  0615     DECF digit_cnt, F, ACCESS
1256  E1FC     BNZ 0x1250
1258  6E14     MOVWF __tmp_0, ACCESS
125A  0E03     MOVLW 0x3
125C  40DB     RRNCF PLUSW2, W, ACCESS
125E  40E8     RRNCF WREG, W, ACCESS
1260  40E8     RRNCF WREG, W, ACCESS
1262  0B1F     ANDLW 0x1F
1264  6AEA     CLRF FSR0H, ACCESS
1266  0FD9     ADDLW 0xD9
1268  6EE9     MOVWF FSR0L, ACCESS
126A  0E01     MOVLW 0x1
126C  22EA     ADDWFC FSR0H, F, ACCESS
126E  50EF     MOVF INDF0, W, ACCESS
1270  1414     ANDWF __tmp_0, W, ACCESS
1272  E044     BZ 0x12FC
453:           					printf((STRING)"%d:%d ",n,TST_CHILDOK(n)!=0);
1274  0E03     MOVLW 0x3
1276  50DB     MOVF PLUSW2, W, ACCESS
1278  0B07     ANDLW 0x7
127A  6E17     MOVWF sign_char, ACCESS
127C  0E01     MOVLW 0x1
127E  5217     MOVF sign_char, F, ACCESS
1280  E004     BZ 0x128A
1282  46E8     RLNCF WREG, F, ACCESS
1284  0BFE     ANDLW 0xFE
1286  0617     DECF sign_char, F, ACCESS
1288  E1FC     BNZ 0x1282
128A  6E16     MOVWF prefix_cnt, ACCESS
128C  0E03     MOVLW 0x3
128E  40DB     RRNCF PLUSW2, W, ACCESS
1290  40E8     RRNCF WREG, W, ACCESS
1292  40E8     RRNCF WREG, W, ACCESS
1294  0B1F     ANDLW 0x1F
1296  6AEA     CLRF FSR0H, ACCESS
1298  0FE9     ADDLW 0xE9
129A  6EE9     MOVWF FSR0L, ACCESS
129C  0E01     MOVLW 0x1
129E  22EA     ADDWFC FSR0H, F, ACCESS
12A0  50EF     MOVF INDF0, W, ACCESS
12A2  1416     ANDWF prefix_cnt, W, ACCESS
12A4  E102     BNZ 0x12AA
12A6  0E00     MOVLW 0x0
12A8  D001     BRA 0x12AC
12AA  0E01     MOVLW 0x1
12AC  6E14     MOVWF __tmp_0, ACCESS
12AE  6A15     CLRF digit_cnt, ACCESS
12B0  BE14     BTFSC __tmp_0, 7, ACCESS
12B2  6815     SETF digit_cnt, ACCESS
12B4  C014     MOVFF __tmp_0, POSTINC1
12B6  FFE6     NOP
12B8  C015     MOVFF digit_cnt, POSTINC1
12BA  FFE6     NOP
12BC  0E03     MOVLW 0x3
12BE  CFDB     MOVFF PLUSW2, POSTINC1
12C0  FFE6     NOP
12C2  6AE6     CLRF POSTINC1, ACCESS
12C4  0E62     MOVLW 0x62
12C6  6E18     MOVWF buf, ACCESS
12C8  0E46     MOVLW 0x46
12CA  6E19     MOVWF 0x19, ACCESS
12CC  6A1A     CLRF 0x1A, ACCESS
12CE  C018     MOVFF buf, POSTINC1
12D0  FFE6     NOP
12D2  C019     MOVFF 0x19, POSTINC1
12D4  FFE6     NOP
12D6  C01A     MOVFF 0x1A, POSTINC1
12D8  FFE6     NOP
12DA  EC63     CALL 0x48C6, 0
12DC  F024     NOP
12DE  6E1B     MOVWF 0x1B, ACCESS
12E0  0E07     MOVLW 0x7
12E2  5EE1     SUBWF FSR1L, F, ACCESS
12E4  501B     MOVF 0x1B, W, ACCESS
454:           					if((++c2)%16==0) putchar('\n');
12E6  0E02     MOVLW 0x2
12E8  2ADB     INCF PLUSW2, F, ACCESS
12EA  0E02     MOVLW 0x2
12EC  50DB     MOVF PLUSW2, W, ACCESS
12EE  0B0F     ANDLW 0xF
12F0  E105     BNZ 0x12FC
12F2  0E0A     MOVLW 0xA
12F4  6EE6     MOVWF POSTINC1, ACCESS
12F6  EC26     CALL 0x424C, 0
12F8  F021     NOP
12FA  52E5     MOVF POSTDEC1, F, ACCESS
455:           				}
456:           			}
457:           			putchar('\n');
1302  0E0A     MOVLW 0xA
1304  6EE6     MOVWF POSTINC1, ACCESS
1306  EC26     CALL 0x424C, 0
1308  F021     NOP
130A  52E5     MOVF POSTDEC1, F, ACCESS
458:           			goto discard; //return;
130C  D2DD     BRA 0x18C8
459:           		}
460:           		else if(c=='F'){ //quit bootloader mode
130E  D0CD     BRA 0x14AA
1310  0E01     MOVLW 0x1
1312  50DB     MOVF PLUSW2, W, ACCESS
1314  0846     SUBLW 0x46
1316  E118     BNZ 0x1348
461:           			//INTCONbits.GIEL = 0;
462:           			FraiseStatus.FBLDON=0;
1318  0101     MOVLB 0x1
131A  99CB     BCF cdc_In_len, 4, BANKED
463:           			FraiseState=fIDLE;
131C  0101     MOVLB 0x1
131E  6BD4     CLRF 0xD4, BANKED
464:           			Serial_Init_Driver();
1320  908B     BCF LATC, 0, ACCESS
1322  9A9D     BCF PIE1, 5, ACCESS
465:           			printf((STRING)"Quit bootloader mode.\n");
1324  0E4B     MOVLW 0x4B
1326  6E14     MOVWF __tmp_0, ACCESS
1328  0E46     MOVLW 0x46
132A  6E15     MOVWF digit_cnt, ACCESS
132C  6A16     CLRF prefix_cnt, ACCESS
132E  C014     MOVFF __tmp_0, POSTINC1
1330  FFE6     NOP
1332  C015     MOVFF digit_cnt, POSTINC1
1334  FFE6     NOP
1336  C016     MOVFF prefix_cnt, POSTINC1
1338  FFE6     NOP
133A  EC63     CALL 0x48C6, 0
133C  F024     NOP
133E  52E5     MOVF POSTDEC1, F, ACCESS
1340  52E5     MOVF POSTDEC1, F, ACCESS
1342  52E5     MOVF POSTDEC1, F, ACCESS
466:           			goto discard; //return;
1344  D2C1     BRA 0x18C8
467:           		}
468:                           else if(c=='V'){ //get version string
1346  D0B1     BRA 0x14AA
1348  0E01     MOVLW 0x1
134A  50DB     MOVF PLUSW2, W, ACCESS
134C  0856     SUBLW 0x56
134E  E112     BNZ 0x1374
469:                               printf(VERSION_STRING);
1350  0E18     MOVLW 0x18
1352  6E14     MOVWF __tmp_0, ACCESS
1354  0E46     MOVLW 0x46
1356  6E15     MOVWF digit_cnt, ACCESS
1358  6A16     CLRF prefix_cnt, ACCESS
135A  C014     MOVFF __tmp_0, POSTINC1
135C  FFE6     NOP
135E  C015     MOVFF digit_cnt, POSTINC1
1360  FFE6     NOP
1362  C016     MOVFF prefix_cnt, POSTINC1
1364  FFE6     NOP
1366  EC63     CALL 0x48C6, 0
1368  F024     NOP
136A  52E5     MOVF POSTDEC1, F, ACCESS
136C  52E5     MOVF POSTDEC1, F, ACCESS
136E  52E5     MOVF POSTDEC1, F, ACCESS
470:                               goto discard; //return;
1370  D2AB     BRA 0x18C8
471:                           }
472:                           else if(c=='R') { //read id
1372  D09B     BRA 0x14AA
1374  0E01     MOVLW 0x1
1376  50DB     MOVF PLUSW2, W, ACCESS
1378  0852     SUBLW 0x52
137A  E101     BNZ 0x137E
473:                           }
474:                           else if(c=='W') { //write id
137C  D096     BRA 0x14AA
137E  0E01     MOVLW 0x1
1380  50DB     MOVF PLUSW2, W, ACCESS
1382  0857     SUBLW 0x57
1384  E101     BNZ 0x1388
475:                           }
476:                           else if(c=='E') { //echo
1386  D091     BRA 0x14AA
1388  0E01     MOVLW 0x1
138A  50DB     MOVF PLUSW2, W, ACCESS
138C  0845     SUBLW 0x45
138E  E123     BNZ 0x13D6
477:                               while(LINE_HAS_CHAR()) {
1390  0101     MOVLB 0x1
1392  5140     MOVF 0x40, W, BANKED
1394  6EF3     MOVWF PRODL, ACCESS
1396  0E04     MOVLW 0x4
1398  CFDB     MOVFF PLUSW2, PRODH
139A  FFF4     NOP
139C  50F3     MOVF PRODL, W, ACCESS
139E  5CF4     SUBWF PRODH, W, ACCESS
13A0  E214     BC 0x13CA
13C8  D7E3     BRA 0x1390
478:                                   c=GETNEXTCHAR();
13A2  0E04     MOVLW 0x4
13A4  CFDB     MOVFF PLUSW2, PRODL
13A6  FFF3     NOP
13A8  2ADB     INCF PLUSW2, F, ACCESS
13AA  50F3     MOVF PRODL, W, ACCESS
13AC  6AEA     CLRF FSR0H, ACCESS
13AE  0F00     ADDLW 0x0
13B0  6EE9     MOVWF FSR0L, ACCESS
13B2  0E01     MOVLW 0x1
13B4  22EA     ADDWFC FSR0H, F, ACCESS
13B6  0E01     MOVLW 0x1
13B8  CFEF     MOVFF INDF0, PLUSW2
13BA  FFDB     NOP
479:                                   putchar(c);
13BC  0E01     MOVLW 0x1
13BE  CFDB     MOVFF PLUSW2, POSTINC1
13C0  FFE6     NOP
13C2  EC26     CALL 0x424C, 0
13C4  F021     NOP
13C6  52E5     MOVF POSTDEC1, F, ACCESS
480:                               }
481:                               putchar('\n');
13CA  0E0A     MOVLW 0xA
13CC  6EE6     MOVWF POSTINC1, ACCESS
13CE  EC26     CALL 0x424C, 0
13D0  F021     NOP
13D2  52E5     MOVF POSTDEC1, F, ACCESS
482:                           }
483:                           else if(c=='D') { //delay between each device polling (ms)
13D4  D06A     BRA 0x14AA
13D6  0E01     MOVLW 0x1
13D8  50DB     MOVF PLUSW2, W, ACCESS
13DA  0844     SUBLW 0x44
13DC  E166     BNZ 0x14AA
484:                               if(len!=4) goto discard; //incorrect  packet...
13DE  0E04     MOVLW 0x4
13E0  5CDF     SUBWF INDF2, W, ACCESS
13E2  E001     BZ 0x13E6
13E4  D271     BRA 0x18C8
485:                               c=GETNEXTCHAR();
13E6  0E04     MOVLW 0x4
13E8  CFDB     MOVFF PLUSW2, PRODL
13EA  FFF3     NOP
13EC  2ADB     INCF PLUSW2, F, ACCESS
13EE  50F3     MOVF PRODL, W, ACCESS
13F0  6AEA     CLRF FSR0H, ACCESS
13F2  0F00     ADDLW 0x0
13F4  6EE9     MOVWF FSR0L, ACCESS
13F6  0E01     MOVLW 0x1
13F8  22EA     ADDWFC FSR0H, F, ACCESS
13FA  0E01     MOVLW 0x1
13FC  CFEF     MOVFF INDF0, PLUSW2
13FE  FFDB     NOP
486:                               c-='0';if (c>9) c-='A'-'9'-1;
1400  0E30     MOVLW 0x30
1402  6E14     MOVWF __tmp_0, ACCESS
1404  0E01     MOVLW 0x1
1406  CFDB     MOVFF PLUSW2, INDF1
1408  FFE7     NOP
140A  5014     MOVF __tmp_0, W, ACCESS
140C  5EE7     SUBWF INDF1, F, ACCESS
140E  0E01     MOVLW 0x1
1410  CFE7     MOVFF INDF1, PLUSW2
1412  FFDB     NOP
1414  0E01     MOVLW 0x1
1416  50DB     MOVF PLUSW2, W, ACCESS
1418  0809     SUBLW 0x9
141A  E20A     BC 0x1430
141C  0E07     MOVLW 0x7
141E  6E14     MOVWF __tmp_0, ACCESS
1420  0E01     MOVLW 0x1
1422  CFDB     MOVFF PLUSW2, INDF1
1424  FFE7     NOP
1426  5014     MOVF __tmp_0, W, ACCESS
1428  5EE7     SUBWF INDF1, F, ACCESS
142A  0E01     MOVLW 0x1
142C  CFE7     MOVFF INDF1, PLUSW2
142E  FFDB     NOP
487:                               c2=GETNEXTCHAR();
1430  0E04     MOVLW 0x4
1432  CFDB     MOVFF PLUSW2, PRODL
1434  FFF3     NOP
1436  2ADB     INCF PLUSW2, F, ACCESS
1438  50F3     MOVF PRODL, W, ACCESS
143A  6AEA     CLRF FSR0H, ACCESS
143C  0F00     ADDLW 0x0
143E  6EE9     MOVWF FSR0L, ACCESS
1440  0E01     MOVLW 0x1
1442  22EA     ADDWFC FSR0H, F, ACCESS
1444  0E02     MOVLW 0x2
1446  CFEF     MOVFF INDF0, PLUSW2
1448  FFDB     NOP
488:                               c2-='0';if (c2>9) c2-='A'-'9'-1;
144A  0E30     MOVLW 0x30
144C  6E14     MOVWF __tmp_0, ACCESS
144E  0E02     MOVLW 0x2
1450  CFDB     MOVFF PLUSW2, INDF1
1452  FFE7     NOP
1454  5014     MOVF __tmp_0, W, ACCESS
1456  5EE7     SUBWF INDF1, F, ACCESS
1458  0E02     MOVLW 0x2
145A  CFE7     MOVFF INDF1, PLUSW2
145C  FFDB     NOP
145E  0E02     MOVLW 0x2
1460  50DB     MOVF PLUSW2, W, ACCESS
1462  0809     SUBLW 0x9
1464  E20A     BC 0x147A
1466  0E07     MOVLW 0x7
1468  6E14     MOVWF __tmp_0, ACCESS
146A  0E02     MOVLW 0x2
146C  CFDB     MOVFF PLUSW2, INDF1
146E  FFE7     NOP
1470  5014     MOVF __tmp_0, W, ACCESS
1472  5EE7     SUBWF INDF1, F, ACCESS
1474  0E02     MOVLW 0x2
1476  CFE7     MOVFF INDF1, PLUSW2
1478  FFDB     NOP
489:                               if((c>15)||(c2>15)) goto discard; //invalid packet
147A  0E01     MOVLW 0x1
147C  50DB     MOVF PLUSW2, W, ACCESS
147E  080F     SUBLW 0xF
1480  E304     BNC 0x148A
1482  0E02     MOVLW 0x2
1484  50DB     MOVF PLUSW2, W, ACCESS
1486  080F     SUBLW 0xF
1488  E201     BC 0x148C
148A  D21E     BRA 0x18C8
490:                               n=c2+(c<<4);
148C  0E02     MOVLW 0x2
148E  CFDB     MOVFF PLUSW2, POSTINC1
1490  FFE6     NOP
1492  0E01     MOVLW 0x1
1494  38DB     SWAPF PLUSW2, W, ACCESS
1496  0BF0     ANDLW 0xF0
1498  52E5     MOVF POSTDEC1, F, ACCESS
149A  24E7     ADDWF INDF1, W, ACCESS
149C  6EE7     MOVWF INDF1, ACCESS
149E  0E03     MOVLW 0x3
14A0  CFE7     MOVFF INDF1, PLUSW2
14A2  FFDB     NOP
491:                               PollDelay=n;
14A4  0E03     MOVLW 0x3
14A6  CFDB     MOVFF PLUSW2, PollDelay
14A8  F1C9     NOP
492:                           }
493:           		goto discard; //unknown system command ; discard packet.
14AA  D20E     BRA 0x18C8
494:           	}	
495:           	else if(c=='!') {						
14AC  D057     BRA 0x155C
14AE  0E01     MOVLW 0x1
14B0  50DB     MOVF PLUSW2, W, ACCESS
14B2  0821     SUBLW 0x21
14B4  E153     BNZ 0x155C
496:           		//****************** broadcast tx , begining by '!':  *****************
497:           		len-=1; // discard '!' byte
14B6  06DF     DECF INDF2, F, ACCESS
498:           		if(len<1) goto discard;
14B8  0E01     MOVLW 0x1
14BA  5CDF     SUBWF INDF2, W, ACCESS
14BC  E201     BC 0x14C0
14BE  D204     BRA 0x18C8
499:           		FrTXPacketInit(0);
14C0  0101     MOVLB 0x1
14C2  0E01     MOVLW 0x1
14C4  6F82     MOVWF 0x82, BANKED
14C6  0101     MOVLB 0x1
14C8  6B42     CLRF 0x42, BANKED
14CA  C142     MOVFF FrTXpacket, FrTXchksum
14CC  F184     NOP
500:           		
501:           		c=PEEKNEXTCHAR(); //what is the command ?
14CE  0E04     MOVLW 0x4
14D0  50DB     MOVF PLUSW2, W, ACCESS
14D2  6AEA     CLRF FSR0H, ACCESS
14D4  0F00     ADDLW 0x0
14D6  6EE9     MOVWF FSR0L, ACCESS
14D8  0E01     MOVLW 0x1
14DA  22EA     ADDWFC FSR0H, F, ACCESS
14DC  0E01     MOVLW 0x1
14DE  CFEF     MOVFF INDF0, PLUSW2
14E0  FFDB     NOP
502:           		
503:           		if(c=='B'||c=='I'||c=='N'||c=='R'||c=='P'||c=='F'){
14E2  0E01     MOVLW 0x1
14E4  50DB     MOVF PLUSW2, W, ACCESS
14E6  0842     SUBLW 0x42
14E8  E014     BZ 0x1512
14EA  0E01     MOVLW 0x1
14EC  50DB     MOVF PLUSW2, W, ACCESS
14EE  0849     SUBLW 0x49
14F0  E010     BZ 0x1512
14F2  0E01     MOVLW 0x1
14F4  50DB     MOVF PLUSW2, W, ACCESS
14F6  084E     SUBLW 0x4E
14F8  E00C     BZ 0x1512
14FA  0E01     MOVLW 0x1
14FC  50DB     MOVF PLUSW2, W, ACCESS
14FE  0852     SUBLW 0x52
1500  E008     BZ 0x1512
1502  0E01     MOVLW 0x1
1504  50DB     MOVF PLUSW2, W, ACCESS
1506  0850     SUBLW 0x50
1508  E004     BZ 0x1512
150A  0E01     MOVLW 0x1
150C  50DB     MOVF PLUSW2, W, ACCESS
150E  0846     SUBLW 0x46
1510  E11C     BNZ 0x154A
504:           			FraiseStatus.TXCHAR=1;
1512  0101     MOVLB 0x1
1514  85CB     BSF cdc_In_len, 2, BANKED
505:           			
506:           			if(c=='F') {
1516  0E01     MOVLW 0x1
1518  50DB     MOVF PLUSW2, W, ACCESS
151A  0846     SUBLW 0x46
151C  E113     BNZ 0x1544
507:           				FraiseStatus.FBLDON=1;
151E  0101     MOVLB 0x1
1520  89CB     BSF cdc_In_len, 4, BANKED
508:           				printf((STRING)"Enter bootloader mode.\n");
1522  0E00     MOVLW 0x0
1524  6E14     MOVWF __tmp_0, ACCESS
1526  0E46     MOVLW 0x46
1528  6E15     MOVWF digit_cnt, ACCESS
152A  6A16     CLRF prefix_cnt, ACCESS
152C  C014     MOVFF __tmp_0, POSTINC1
152E  FFE6     NOP
1530  C015     MOVFF digit_cnt, POSTINC1
1532  FFE6     NOP
1534  C016     MOVFF prefix_cnt, POSTINC1
1536  FFE6     NOP
1538  EC63     CALL 0x48C6, 0
153A  F024     NOP
153C  52E5     MOVF POSTDEC1, F, ACCESS
153E  52E5     MOVF POSTDEC1, F, ACCESS
1540  52E5     MOVF POSTDEC1, F, ACCESS
509:           			}
510:           			else FraiseStatus.FBLDON=0;
1542  D002     BRA 0x1548
1544  0101     MOVLB 0x1
1546  99CB     BCF cdc_In_len, 4, BANKED
511:           			
512:           			goto fill_packet;
1548  D0DC     BRA 0x1702
513:           		}
514:           		if(c=='b'){
154A  0E01     MOVLW 0x1
154C  50DB     MOVF PLUSW2, W, ACCESS
154E  0862     SUBLW 0x62
1550  E104     BNZ 0x155A
515:           			SKIPNEXTCHAR(); len-=1; // discard 'b' byte
1552  0E04     MOVLW 0x4
1554  2ADB     INCF PLUSW2, F, ACCESS
1556  06DF     DECF INDF2, F, ACCESS
516:           			goto fill_packet;
1558  D0D4     BRA 0x1702
517:           		}
518:           
519:           		goto discard;
155A  D1B6     BRA 0x18C8
520:           	}
521:           
522:           	if(FraiseStatus.FBLDON) {
155C  0101     MOVLB 0x1
155E  A9CB     BTFSS cdc_In_len, 4, BANKED
1560  D05C     BRA 0x161A
523:           		//putchar('\n');
524:                       //printf((STRING)"bl tx\n");
525:           		FrTXPacketInit(len+1);
1562  0101     MOVLB 0x1
1564  0E01     MOVLW 0x1
1566  6F82     MOVWF 0x82, BANKED
1568  28DF     INCF INDF2, W, ACCESS
156A  0101     MOVLB 0x1
156C  6F42     MOVWF 0x42, BANKED
156E  0101     MOVLB 0x1
1570  6F84     MOVWF 0x84, BANKED
526:           		FrTXPacketData(c);
1572  0101     MOVLB 0x1
1574  5182     MOVF 0x82, W, BANKED
1576  6AEA     CLRF FSR0H, ACCESS
1578  0F42     ADDLW 0x42
157A  6EE9     MOVWF FSR0L, ACCESS
157C  0E01     MOVLW 0x1
157E  22EA     ADDWFC FSR0H, F, ACCESS
1580  0E01     MOVLW 0x1
1582  CFDB     MOVFF PLUSW2, INDF0
1584  FFEF     NOP
1586  50EF     MOVF INDF0, W, ACCESS
1588  0101     MOVLB 0x1
158A  2784     ADDWF 0x84, F, BANKED
158C  0101     MOVLB 0x1
158E  2B82     INCF 0x82, F, BANKED
527:           		
528:           		while(LINE_HAS_CHAR()) FrTXPacketData(GETNEXTCHAR());
1590  0101     MOVLB 0x1
1592  5140     MOVF 0x40, W, BANKED
1594  6EF3     MOVWF PRODL, ACCESS
1596  0E04     MOVLW 0x4
1598  CFDB     MOVFF PLUSW2, PRODH
159A  FFF4     NOP
159C  50F3     MOVF PRODL, W, ACCESS
159E  5CF4     SUBWF PRODH, W, ACCESS
15A0  E21B     BC 0x15D8
15A2  0E04     MOVLW 0x4
15A4  CFDB     MOVFF PLUSW2, PRODL
15A6  FFF3     NOP
15A8  2ADB     INCF PLUSW2, F, ACCESS
15AA  50F3     MOVF PRODL, W, ACCESS
15AC  6AEA     CLRF FSR0H, ACCESS
15AE  0F00     ADDLW 0x0
15B0  6EE9     MOVWF FSR0L, ACCESS
15B2  0E01     MOVLW 0x1
15B4  22EA     ADDWFC FSR0H, F, ACCESS
15B6  50EF     MOVF INDF0, W, ACCESS
15B8  6EE6     MOVWF POSTINC1, ACCESS
15BA  0101     MOVLB 0x1
15BC  5182     MOVF 0x82, W, BANKED
15BE  6AEA     CLRF FSR0H, ACCESS
15C0  0F42     ADDLW 0x42
15C2  6EE9     MOVWF FSR0L, ACCESS
15C4  0E01     MOVLW 0x1
15C6  22EA     ADDWFC FSR0H, F, ACCESS
15C8  52E5     MOVF POSTDEC1, F, ACCESS
15CA  50E7     MOVF INDF1, W, ACCESS
15CC  6EEF     MOVWF INDF0, ACCESS
15CE  0101     MOVLB 0x1
15D0  2784     ADDWF 0x84, F, BANKED
15D2  0101     MOVLB 0x1
15D4  2B82     INCF 0x82, F, BANKED
15D6  D7DC     BRA 0x1590
529:           		FrTXPacketClose();	
15D8  0EFF     MOVLW 0xFF
15DA  0101     MOVLB 0x1
15DC  0384     MULWF 0x84, BANKED
15DE  50F3     MOVF PRODL, W, ACCESS
15E0  6EE6     MOVWF POSTINC1, ACCESS
15E2  0101     MOVLB 0x1
15E4  5182     MOVF 0x82, W, BANKED
15E6  6AEA     CLRF FSR0H, ACCESS
15E8  0F42     ADDLW 0x42
15EA  6EE9     MOVWF FSR0L, ACCESS
15EC  0E01     MOVLW 0x1
15EE  22EA     ADDWFC FSR0H, F, ACCESS
15F0  52E5     MOVF POSTDEC1, F, ACCESS
15F2  50E7     MOVF INDF1, W, ACCESS
15F4  6EEF     MOVWF INDF0, ACCESS
15F6  0101     MOVLB 0x1
15F8  2982     INCF 0x82, W, BANKED
15FA  0101     MOVLB 0x1
15FC  6F83     MOVWF 0x83, BANKED
530:           		FrTXtries=0;
15FE  0101     MOVLB 0x1
1600  6B85     CLRF 0x85, BANKED
531:           		FrTXPacketLaunchBl();
1602  908B     BCF LATC, 0, ACCESS
1604  9A9D     BCF PIE1, 5, ACCESS
1606  C142     MOVFF FrTXpacket, TXREG
1608  FFAD     NOP
160A  0101     MOVLB 0x1
160C  0E01     MOVLW 0x1
160E  6F82     MOVWF 0x82, BANKED
1610  0101     MOVLB 0x1
1612  0E04     MOVLW 0x4
1614  6FD4     MOVWF 0xD4, BANKED
1616  889D     BSF PIE1, 4, ACCESS
532:           		goto discard;
1618  D157     BRA 0x18C8
533:           	}
534:           	//else
535:           	//****************** normal master to device tx: 
536:           	//the 2 first bytes must be device id + 128 if it is a char packet:
537:           	if(len<3) goto discard;
161A  0E03     MOVLW 0x3
161C  5CDF     SUBWF INDF2, W, ACCESS
161E  E201     BC 0x1622
1620  D153     BRA 0x18C8
538:           	
539:           	//c=GETNEXTCHAR();
540:           	c-='0';if (c>9) c-='A'-'9'-1;
1622  0E30     MOVLW 0x30
1624  6E14     MOVWF __tmp_0, ACCESS
1626  0E01     MOVLW 0x1
1628  CFDB     MOVFF PLUSW2, INDF1
162A  FFE7     NOP
162C  5014     MOVF __tmp_0, W, ACCESS
162E  5EE7     SUBWF INDF1, F, ACCESS
1630  0E01     MOVLW 0x1
1632  CFE7     MOVFF INDF1, PLUSW2
1634  FFDB     NOP
1636  0E01     MOVLW 0x1
1638  50DB     MOVF PLUSW2, W, ACCESS
163A  0809     SUBLW 0x9
163C  E20A     BC 0x1652
163E  0E07     MOVLW 0x7
1640  6E14     MOVWF __tmp_0, ACCESS
1642  0E01     MOVLW 0x1
1644  CFDB     MOVFF PLUSW2, INDF1
1646  FFE7     NOP
1648  5014     MOVF __tmp_0, W, ACCESS
164A  5EE7     SUBWF INDF1, F, ACCESS
164C  0E01     MOVLW 0x1
164E  CFE7     MOVFF INDF1, PLUSW2
1650  FFDB     NOP
541:           
542:           	c2=GETNEXTCHAR();
1652  0E04     MOVLW 0x4
1654  CFDB     MOVFF PLUSW2, PRODL
1656  FFF3     NOP
1658  2ADB     INCF PLUSW2, F, ACCESS
165A  50F3     MOVF PRODL, W, ACCESS
165C  6AEA     CLRF FSR0H, ACCESS
165E  0F00     ADDLW 0x0
1660  6EE9     MOVWF FSR0L, ACCESS
1662  0E01     MOVLW 0x1
1664  22EA     ADDWFC FSR0H, F, ACCESS
1666  0E02     MOVLW 0x2
1668  CFEF     MOVFF INDF0, PLUSW2
166A  FFDB     NOP
543:           	//if (c2=='\n') return; //incomplete packet...
544:           
545:           	c2-='0';if (c2>9) c2-='A'-'9'-1;
166C  0E30     MOVLW 0x30
166E  6E14     MOVWF __tmp_0, ACCESS
1670  0E02     MOVLW 0x2
1672  CFDB     MOVFF PLUSW2, INDF1
1674  FFE7     NOP
1676  5014     MOVF __tmp_0, W, ACCESS
1678  5EE7     SUBWF INDF1, F, ACCESS
167A  0E02     MOVLW 0x2
167C  CFE7     MOVFF INDF1, PLUSW2
167E  FFDB     NOP
1680  0E02     MOVLW 0x2
1682  50DB     MOVF PLUSW2, W, ACCESS
1684  0809     SUBLW 0x9
1686  E20A     BC 0x169C
1688  0E07     MOVLW 0x7
168A  6E14     MOVWF __tmp_0, ACCESS
168C  0E02     MOVLW 0x2
168E  CFDB     MOVFF PLUSW2, INDF1
1690  FFE7     NOP
1692  5014     MOVF __tmp_0, W, ACCESS
1694  5EE7     SUBWF INDF1, F, ACCESS
1696  0E02     MOVLW 0x2
1698  CFE7     MOVFF INDF1, PLUSW2
169A  FFDB     NOP
546:           	if((c>15)||(c2>15)) goto discard; //invalid id
169C  0E01     MOVLW 0x1
169E  50DB     MOVF PLUSW2, W, ACCESS
16A0  080F     SUBLW 0xF
16A2  E304     BNC 0x16AC
16A4  0E02     MOVLW 0x2
16A6  50DB     MOVF PLUSW2, W, ACCESS
16A8  080F     SUBLW 0xF
16AA  E201     BC 0x16AE
16AC  D10D     BRA 0x18C8
547:           	n=c2+(c<<4);
16AE  0E02     MOVLW 0x2
16B0  CFDB     MOVFF PLUSW2, POSTINC1
16B2  FFE6     NOP
16B4  0E01     MOVLW 0x1
16B6  38DB     SWAPF PLUSW2, W, ACCESS
16B8  0BF0     ANDLW 0xF0
16BA  52E5     MOVF POSTDEC1, F, ACCESS
16BC  24E7     ADDWF INDF1, W, ACCESS
16BE  6EE7     MOVWF INDF1, ACCESS
16C0  0E03     MOVLW 0x3
16C2  CFE7     MOVFF INDF1, PLUSW2
16C4  FFDB     NOP
548:           
549:           	if(n&128) FraiseStatus.TXCHAR=1;
16C6  0E03     MOVLW 0x3
16C8  50DB     MOVF PLUSW2, W, ACCESS
16CA  6E14     MOVWF __tmp_0, ACCESS
16CC  6A15     CLRF digit_cnt, ACCESS
16CE  5014     MOVF __tmp_0, W, ACCESS
16D0  0B80     ANDLW 0x80
16D2  E003     BZ 0x16DA
16D4  0101     MOVLB 0x1
16D6  85CB     BSF cdc_In_len, 2, BANKED
550:           	else FraiseStatus.TXCHAR=0;
16D8  D002     BRA 0x16DE
16DA  0101     MOVLB 0x1
16DC  95CB     BCF cdc_In_len, 2, BANKED
551:           
552:           	n&=127;
16DE  0E03     MOVLW 0x3
16E0  9EDB     BCF PLUSW2, 7, ACCESS
553:           	if (n==0) goto discard;
16E2  0E03     MOVLW 0x3
16E4  50DB     MOVF PLUSW2, W, ACCESS
16E6  E101     BNZ 0x16EA
16E8  D0EF     BRA 0x18C8
554:           	FrTXPacketInit(n);
16EA  0101     MOVLB 0x1
16EC  0E01     MOVLW 0x1
16EE  6F82     MOVWF 0x82, BANKED
16F0  0E03     MOVLW 0x3
16F2  CFDB     MOVFF PLUSW2, FrTXpacket
16F4  F142     NOP
16F6  C142     MOVFF FrTXpacket, FrTXchksum
16F8  F184     NOP
555:                   //printf((STRING)"tx to dev %d\n",n);
556:           
557:           	len-=2; //remove the two id bytes
16FA  0E02     MOVLW 0x2
16FC  5EDF     SUBWF INDF2, F, ACCESS
558:           	FraiseStatus.TX_NEEDACK=1;
16FE  0101     MOVLB 0x1
1700  87CB     BSF cdc_In_len, 3, BANKED
559:           	
560:           
561:           fill_packet:
562:                   if(FraiseStatus.TXCHAR) len|=128;
1702  0101     MOVLB 0x1
1704  A5CB     BTFSS cdc_In_len, 2, BANKED
1706  D002     BRA 0x170C
1708  8EDF     BSF INDF2, 7, ACCESS
563:                   else len>>=1; //if not TXCHAR, data len in serial stream will be half than at text input (e.g two text bytes "00" -> one null byte )
170A  D002     BRA 0x1710
170C  90DF     BCF INDF2, 0, ACCESS
170E  42DF     RRNCF INDF2, F, ACCESS
564:                   FrTXPacketData(len);
1710  0101     MOVLB 0x1
1712  5182     MOVF 0x82, W, BANKED
1714  6AEA     CLRF FSR0H, ACCESS
1716  0F42     ADDLW 0x42
1718  6EE9     MOVWF FSR0L, ACCESS
171A  0E01     MOVLW 0x1
171C  22EA     ADDWFC FSR0H, F, ACCESS
171E  CFDF     MOVFF INDF2, INDF0
1720  FFEF     NOP
1722  50EF     MOVF INDF0, W, ACCESS
1724  0101     MOVLB 0x1
1726  2784     ADDWF 0x84, F, BANKED
1728  0101     MOVLB 0x1
172A  2B82     INCF 0x82, F, BANKED
565:           
566:                   if(FraiseStatus.TXCHAR) {
172C  0101     MOVLB 0x1
172E  A5CB     BTFSS cdc_In_len, 2, BANKED
1730  D025     BRA 0x177C
567:                       while(LINE_HAS_CHAR()) FrTXPacketData(GETNEXTCHAR());
1732  0101     MOVLB 0x1
1734  5140     MOVF 0x40, W, BANKED
1736  6EF3     MOVWF PRODL, ACCESS
1738  0E04     MOVLW 0x4
173A  CFDB     MOVFF PLUSW2, PRODH
173C  FFF4     NOP
173E  50F3     MOVF PRODL, W, ACCESS
1740  5CF4     SUBWF PRODH, W, ACCESS
1742  E21B     BC 0x177A
1744  0E04     MOVLW 0x4
1746  CFDB     MOVFF PLUSW2, PRODL
1748  FFF3     NOP
174A  2ADB     INCF PLUSW2, F, ACCESS
174C  50F3     MOVF PRODL, W, ACCESS
174E  6AEA     CLRF FSR0H, ACCESS
1750  0F00     ADDLW 0x0
1752  6EE9     MOVWF FSR0L, ACCESS
1754  0E01     MOVLW 0x1
1756  22EA     ADDWFC FSR0H, F, ACCESS
1758  50EF     MOVF INDF0, W, ACCESS
175A  6EE6     MOVWF POSTINC1, ACCESS
175C  0101     MOVLB 0x1
175E  5182     MOVF 0x82, W, BANKED
1760  6AEA     CLRF FSR0H, ACCESS
1762  0F42     ADDLW 0x42
1764  6EE9     MOVWF FSR0L, ACCESS
1766  0E01     MOVLW 0x1
1768  22EA     ADDWFC FSR0H, F, ACCESS
176A  52E5     MOVF POSTDEC1, F, ACCESS
176C  50E7     MOVF INDF1, W, ACCESS
176E  6EEF     MOVWF INDF0, ACCESS
1770  0101     MOVLB 0x1
1772  2784     ADDWF 0x84, F, BANKED
1774  0101     MOVLB 0x1
1776  2B82     INCF 0x82, F, BANKED
1778  D7DC     BRA 0x1732
568:                   }
569:                   else while(LINE_HAS_CHAR()) {
177A  D082     BRA 0x1880
177C  0101     MOVLB 0x1
177E  5140     MOVF 0x40, W, BANKED
1780  6EF3     MOVWF PRODL, ACCESS
1782  0E04     MOVLW 0x4
1784  CFDB     MOVFF PLUSW2, PRODH
1786  FFF4     NOP
1788  50F3     MOVF PRODL, W, ACCESS
178A  5CF4     SUBWF PRODH, W, ACCESS
178C  E301     BNC 0x1790
178E  D078     BRA 0x1880
187E  D77E     BRA 0x177C
570:                       c=GETNEXTCHAR();
1790  0E04     MOVLW 0x4
1792  CFDB     MOVFF PLUSW2, PRODL
1794  FFF3     NOP
1796  2ADB     INCF PLUSW2, F, ACCESS
1798  50F3     MOVF PRODL, W, ACCESS
179A  6AEA     CLRF FSR0H, ACCESS
179C  0F00     ADDLW 0x0
179E  6EE9     MOVWF FSR0L, ACCESS
17A0  0E01     MOVLW 0x1
17A2  22EA     ADDWFC FSR0H, F, ACCESS
17A4  0E01     MOVLW 0x1
17A6  CFEF     MOVFF INDF0, PLUSW2
17A8  FFDB     NOP
571:                       c-='0';if (c>9) c-='A'-'9'-1;
17AA  0E30     MOVLW 0x30
17AC  6E14     MOVWF __tmp_0, ACCESS
17AE  0E01     MOVLW 0x1
17B0  CFDB     MOVFF PLUSW2, INDF1
17B2  FFE7     NOP
17B4  5014     MOVF __tmp_0, W, ACCESS
17B6  5EE7     SUBWF INDF1, F, ACCESS
17B8  0E01     MOVLW 0x1
17BA  CFE7     MOVFF INDF1, PLUSW2
17BC  FFDB     NOP
17BE  0E01     MOVLW 0x1
17C0  50DB     MOVF PLUSW2, W, ACCESS
17C2  0809     SUBLW 0x9
17C4  E20A     BC 0x17DA
17C6  0E07     MOVLW 0x7
17C8  6E14     MOVWF __tmp_0, ACCESS
17CA  0E01     MOVLW 0x1
17CC  CFDB     MOVFF PLUSW2, INDF1
17CE  FFE7     NOP
17D0  5014     MOVF __tmp_0, W, ACCESS
17D2  5EE7     SUBWF INDF1, F, ACCESS
17D4  0E01     MOVLW 0x1
17D6  CFE7     MOVFF INDF1, PLUSW2
17D8  FFDB     NOP
572:                       if(!LINE_HAS_CHAR()) goto discard; //incomplete...
17DA  0101     MOVLB 0x1
17DC  5140     MOVF 0x40, W, BANKED
17DE  6EF3     MOVWF PRODL, ACCESS
17E0  0E04     MOVLW 0x4
17E2  CFDB     MOVFF PLUSW2, PRODH
17E4  FFF4     NOP
17E6  50F3     MOVF PRODL, W, ACCESS
17E8  5CF4     SUBWF PRODH, W, ACCESS
17EA  E301     BNC 0x17EE
17EC  D06D     BRA 0x18C8
573:                       c2=GETNEXTCHAR();
17EE  0E04     MOVLW 0x4
17F0  CFDB     MOVFF PLUSW2, PRODL
17F2  FFF3     NOP
17F4  2ADB     INCF PLUSW2, F, ACCESS
17F6  50F3     MOVF PRODL, W, ACCESS
17F8  6AEA     CLRF FSR0H, ACCESS
17FA  0F00     ADDLW 0x0
17FC  6EE9     MOVWF FSR0L, ACCESS
17FE  0E01     MOVLW 0x1
1800  22EA     ADDWFC FSR0H, F, ACCESS
1802  0E02     MOVLW 0x2
1804  CFEF     MOVFF INDF0, PLUSW2
1806  FFDB     NOP
574:                       c2-='0';if (c2>9) c2-='A'-'9'-1;
1808  0E30     MOVLW 0x30
180A  6E14     MOVWF __tmp_0, ACCESS
180C  0E02     MOVLW 0x2
180E  CFDB     MOVFF PLUSW2, INDF1
1810  FFE7     NOP
1812  5014     MOVF __tmp_0, W, ACCESS
1814  5EE7     SUBWF INDF1, F, ACCESS
1816  0E02     MOVLW 0x2
1818  CFE7     MOVFF INDF1, PLUSW2
181A  FFDB     NOP
181C  0E02     MOVLW 0x2
181E  50DB     MOVF PLUSW2, W, ACCESS
1820  0809     SUBLW 0x9
1822  E20A     BC 0x1838
1824  0E07     MOVLW 0x7
1826  6E14     MOVWF __tmp_0, ACCESS
1828  0E02     MOVLW 0x2
182A  CFDB     MOVFF PLUSW2, INDF1
182C  FFE7     NOP
182E  5014     MOVF __tmp_0, W, ACCESS
1830  5EE7     SUBWF INDF1, F, ACCESS
1832  0E02     MOVLW 0x2
1834  CFE7     MOVFF INDF1, PLUSW2
1836  FFDB     NOP
575:                       if((c>15)||(c2>15)) goto discard; //invalid hex string
1838  0E01     MOVLW 0x1
183A  50DB     MOVF PLUSW2, W, ACCESS
183C  080F     SUBLW 0xF
183E  E304     BNC 0x1848
1840  0E02     MOVLW 0x2
1842  50DB     MOVF PLUSW2, W, ACCESS
1844  080F     SUBLW 0xF
1846  E201     BC 0x184A
1848  D03F     BRA 0x18C8
576:                       c2+=(c<<4);
184A  0E01     MOVLW 0x1
184C  50DB     MOVF PLUSW2, W, ACCESS
184E  0D10     MULLW 0x10
1850  0E02     MOVLW 0x2
1852  CFDB     MOVFF PLUSW2, INDF1
1854  FFE7     NOP
1856  50F3     MOVF PRODL, W, ACCESS
1858  26E7     ADDWF INDF1, F, ACCESS
185A  0E02     MOVLW 0x2
185C  CFE7     MOVFF INDF1, PLUSW2
185E  FFDB     NOP
577:                       FrTXPacketData(c2);
1860  0101     MOVLB 0x1
1862  5182     MOVF 0x82, W, BANKED
1864  6AEA     CLRF FSR0H, ACCESS
1866  0F42     ADDLW 0x42
1868  6EE9     MOVWF FSR0L, ACCESS
186A  0E01     MOVLW 0x1
186C  22EA     ADDWFC FSR0H, F, ACCESS
186E  0E02     MOVLW 0x2
1870  CFDB     MOVFF PLUSW2, INDF0
1872  FFEF     NOP
1874  50EF     MOVF INDF0, W, ACCESS
1876  0101     MOVLB 0x1
1878  2784     ADDWF 0x84, F, BANKED
187A  0101     MOVLB 0x1
187C  2B82     INCF 0x82, F, BANKED
578:                   }
579:                   FrTXPacketClose();
1880  0EFF     MOVLW 0xFF
1882  0101     MOVLB 0x1
1884  0384     MULWF 0x84, BANKED
1886  50F3     MOVF PRODL, W, ACCESS
1888  6EE6     MOVWF POSTINC1, ACCESS
188A  0101     MOVLB 0x1
188C  5182     MOVF 0x82, W, BANKED
188E  6AEA     CLRF FSR0H, ACCESS
1890  0F42     ADDLW 0x42
1892  6EE9     MOVWF FSR0L, ACCESS
1894  0E01     MOVLW 0x1
1896  22EA     ADDWFC FSR0H, F, ACCESS
1898  52E5     MOVF POSTDEC1, F, ACCESS
189A  50E7     MOVF INDF1, W, ACCESS
189C  6EEF     MOVWF INDF0, ACCESS
189E  0101     MOVLB 0x1
18A0  2982     INCF 0x82, W, BANKED
18A2  0101     MOVLB 0x1
18A4  6F83     MOVWF 0x83, BANKED
580:                   FrTXtries=0;
18A6  0101     MOVLB 0x1
18A8  6B85     CLRF 0x85, BANKED
581:                   FrTXPacketLaunch();
18AA  908B     BCF LATC, 0, ACCESS
18AC  9A9D     BCF PIE1, 5, ACCESS
18AE  80AC     BSF TXSTA, 0, ACCESS
18B0  C142     MOVFF FrTXpacket, AckChild
18B2  F1F9     NOP
18B4  C142     MOVFF FrTXpacket, TXREG
18B6  FFAD     NOP
18B8  90AC     BCF TXSTA, 0, ACCESS
18BA  0101     MOVLB 0x1
18BC  0E01     MOVLW 0x1
18BE  6F82     MOVWF 0x82, BANKED
18C0  0101     MOVLB 0x1
18C2  0E02     MOVLW 0x2
18C4  6FD4     MOVWF 0xD4, BANKED
18C6  889D     BSF PIE1, 4, ACCESS
582:           
583:           discard:
584:           	LineFromUsbLen=0;
18C8  0101     MOVLB 0x1
18CA  6B40     CLRF 0x40, BANKED
585:                   FrGotLineFromUsb=0;
18CC  0101     MOVLB 0x1
18CE  6B41     CLRF 0x41, BANKED
586:                   return;
18D0  D000     BRA 0x18D2
587:           }
18D2  0E05     MOVLW 0x5
18D4  5CE1     SUBWF FSR1L, W, ACCESS
18D6  E202     BC 0x18DC
18D8  6AE1     CLRF FSR1L, ACCESS
18DA  52E5     MOVF POSTDEC1, F, ACCESS
18DC  6EE1     MOVWF FSR1L, ACCESS
18DE  52E5     MOVF POSTDEC1, F, ACCESS
18E0  CFE7     MOVFF INDF1, FSR2L
18E2  FFD9     NOP
18E4  0012     RETURN 0
588:           
589:           //------------- time constants and macros --------------------------------------
590:           //#define T_1SERBYTE				(256-((40*12)/16))		// For 40us TMR2 tick , 10*4us
591:           #define T_2SERBYTES				(256UL-((61UL*12UL)/16UL))		// For 80us TMR2 tick , 20*4us, 15us before
592:           #define T_1ms					(256UL-((600UL*12UL/3UL)/16UL))	// postscaler=3
593:           #define InitTimer1ms() { PIE1bits.TMR2IE=0;T2CON=31;/*post=3*/TMR2=T_1ms;PIR1bits.TMR2IF=0; }
594:           #define ResetTimer1ms() { TMR2=T_1ms;PIR1bits.TMR2IF=0;}
595:           #define InitTimer(time) { PIE1bits.TMR2IE=0;T2CON=7;/*no post*/TMR2=time;PIR1bits.TMR2IF=0;PIE1bits.TMR2IE=1; }
596:           #define TimerOut() (PIR1bits.TMR2IF)
597:           #define StopTimer() {T2CON=3;PIE1bits.TMR2IE=0;/*stop tmr2*/PIR1bits.TMR2IF=0;}
598:           
599:           /*#ifndef SDCC
600:           #pragma interruptlow low_ISR
601:           #endif
602:           void low_ISR(void) 
603:           #ifdef SDCC
604:            shadowregs interrupt 2
605:           #endif*/
606:           
607:           void FraiseISR()
18E6  CFD9     MOVFF FSR2L, POSTINC1
18E8  FFE6     NOP
18EA  CFE1     MOVFF FSR1L, FSR2L
18EC  FFD9     NOP
18EE  52E6     MOVF POSTINC1, F, ACCESS
608:           {	
609:           	unsigned char c;
610:           	
611:                   //if(PIR1bits.RCIF) mLED_2_On();
612:           
613:                   if(RCSTAbits.OERR) FraiseStatus.OERR=1;
18F0  A2AB     BTFSS RCSTA, 1, ACCESS
18F2  D002     BRA 0x18F8
18F4  0101     MOVLB 0x1
18F6  8BCB     BSF cdc_In_len, 5, BANKED
614:                   if(RCSTAbits.FERR) FraiseStatus.FERR=1;
18F8  A4AB     BTFSS RCSTA, 2, ACCESS
18FA  D002     BRA 0x1900
18FC  0101     MOVLB 0x1
18FE  8DCB     BSF cdc_In_len, 6, BANKED
615:           
616:           	if(FraiseState==fWAITACK) 
1900  0101     MOVLB 0x1
1902  05D4     DECF 0xD4, W, BANKED
1904  E139     BNZ 0x1978
617:           	{
618:           		if (!Serial_Is_Receiver()) {
1906  BA9D     BTFSC PIE1, 5, ACCESS
1908  D00B     BRA 0x1920
619:           			if (TimerOut()) {
190A  A29E     BTFSS PIR1, 1, ACCESS
190C  D008     BRA 0x191E
620:           				Serial_Init_Receiver();
190E  EC28     CALL 0x850, 0
1910  F004     NOP
621:           				InitTimer1ms();
1912  929D     BCF PIE1, 1, ACCESS
1914  0E1F     MOVLW 0x1F
1916  6ECA     MOVWF T2CON, ACCESS
1918  0E6A     MOVLW 0x6A
191A  6ECC     MOVWF TMR2, ACCESS
191C  929E     BCF PIR1, 1, ACCESS
622:           			}
623:           			return;
191E  D127     BRA 0x1B6E
624:           		}
625:           		if(PIR1bits.RCIF) {
1920  AA9E     BTFSS PIR1, 5, ACCESS
1922  D028     BRA 0x1974
626:           			StopTimer();
1924  0E03     MOVLW 0x3
1926  6ECA     MOVWF T2CON, ACCESS
1928  929D     BCF PIE1, 1, ACCESS
192A  929E     BCF PIR1, 1, ACCESS
627:           			c=RCREG;
192C  50AE     MOVF RCREG, W, ACCESS
192E  6EDF     MOVWF INDF2, ACCESS
628:           			Serial_Init_None();
1930  808B     BSF LATC, 0, ACCESS
1932  9A9D     BCF PIE1, 5, ACCESS
1934  989D     BCF PIE1, 4, ACCESS
629:           			if(c!=0) {//nACK
1936  50DF     MOVF INDF2, W, ACCESS
1938  E01A     BZ 0x196E
630:           				if(++FrTXtries<3) {
193A  0101     MOVLB 0x1
193C  2B85     INCF 0x85, F, BANKED
193E  0E03     MOVLW 0x3
1940  0101     MOVLB 0x1
1942  5D85     SUBWF 0x85, W, BANKED
1944  E211     BC 0x1968
631:           					FrTXPacketLaunch(); // resend packet maximum 3 times
1946  908B     BCF LATC, 0, ACCESS
1948  9A9D     BCF PIE1, 5, ACCESS
194A  80AC     BSF TXSTA, 0, ACCESS
194C  C142     MOVFF FrTXpacket, AckChild
194E  F1F9     NOP
1950  C142     MOVFF FrTXpacket, TXREG
1952  FFAD     NOP
1954  90AC     BCF TXSTA, 0, ACCESS
1956  0101     MOVLB 0x1
1958  0E01     MOVLW 0x1
195A  6F82     MOVWF 0x82, BANKED
195C  0101     MOVLB 0x1
195E  0E02     MOVLW 0x2
1960  6FD4     MOVWF 0xD4, BANKED
1962  889D     BSF PIE1, 4, ACCESS
632:           					return;
1964  D104     BRA 0x1B6E
633:           				}
634:           				else {//printf("sS%c%c\n",HI_CHAR(PolledChild()),LO_CHAR(PolledChild()));
1966  D003     BRA 0x196E
635:                                               FraiseMessage=fmessNACK;
1968  0101     MOVLB 0x1
196A  0E04     MOVLW 0x4
196C  6FD5     MOVWF CDC_Inbdp, BANKED
636:                                           }
637:           			}	
638:           			FraiseState=fIDLE;
196E  0101     MOVLB 0x1
1970  6BD4     CLRF 0xD4, BANKED
639:           			return;
1972  D0FD     BRA 0x1B6E
640:           		}
641:           		return;
1974  D0FC     BRA 0x1B6E
642:           	}//endif(FraiseState==fWAITACK)
643:           	else if(FraiseState==fIN)
1976  D0FB     BRA 0x1B6E
1978  0E03     MOVLW 0x3
197A  0101     MOVLB 0x1
197C  5DD4     SUBWF 0xD4, W, BANKED
197E  E16A     BNZ 0x1A54
644:           	{
645:           		if (!Serial_Is_Receiver()) {
1980  BA9D     BTFSC PIE1, 5, ACCESS
1982  D00B     BRA 0x199A
646:           			if (TimerOut()) {
1984  A29E     BTFSS PIR1, 1, ACCESS
1986  D008     BRA 0x1998
647:           				Serial_Init_Receiver();
1988  EC28     CALL 0x850, 0
198A  F004     NOP
648:           				InitTimer1ms();
198C  929D     BCF PIE1, 1, ACCESS
198E  0E1F     MOVLW 0x1F
1990  6ECA     MOVWF T2CON, ACCESS
1992  0E6A     MOVLW 0x6A
1994  6ECC     MOVWF TMR2, ACCESS
1996  929E     BCF PIR1, 1, ACCESS
649:           			}
650:                                   //mLED_2_Off();
651:           			return;
1998  D0EA     BRA 0x1B6E
652:           		}
653:           		if(PIR1bits.RCIF) {
199A  AA9E     BTFSS PIR1, 5, ACCESS
199C  D059     BRA 0x1A50
654:           			c=RCREG;
199E  50AE     MOVF RCREG, W, ACCESS
19A0  6EDF     MOVWF INDF2, ACCESS
655:           			FrRXbuf[FrRXin]=c;
19A2  0101     MOVLB 0x1
19A4  51C6     MOVF 0xC6, W, BANKED
19A6  6AEA     CLRF FSR0H, ACCESS
19A8  0F86     ADDLW 0x86
19AA  6EE9     MOVWF FSR0L, ACCESS
19AC  0E01     MOVLW 0x1
19AE  22EA     ADDWFC FSR0H, F, ACCESS
19B0  CFDF     MOVFF INDF2, INDF0
19B2  FFEF     NOP
656:           			FrRXin++;
19B4  0101     MOVLB 0x1
19B6  2BC6     INCF 0xC6, F, BANKED
657:           			ResetTimer1ms();
19B8  0E6A     MOVLW 0x6A
19BA  6ECC     MOVWF TMR2, ACCESS
19BC  929E     BCF PIR1, 1, ACCESS
658:           			if(FrRXin==1) { //first byte
19BE  0101     MOVLB 0x1
19C0  05C6     DECF 0xC6, W, BANKED
19C2  E122     BNZ 0x1A08
659:           				FrRXchksum=0;
19C4  0101     MOVLB 0x1
19C6  6BC8     CLRF 0xC8, BANKED
660:           				FrRXout=(c&63); //get length
19C8  0E3F     MOVLW 0x3F
19CA  14DF     ANDWF INDF2, W, ACCESS
19CC  0101     MOVLB 0x1
19CE  6FC7     MOVWF 0xC7, BANKED
661:           				FrRXout++;	
19D0  0101     MOVLB 0x1
19D2  2BC7     INCF 0xC7, F, BANKED
662:           				if(c==0){ //device answered : nothing to say
19D4  50DF     MOVF INDF2, W, ACCESS
19D6  E10D     BNZ 0x19F2
663:           					StopTimer();
19D8  0E03     MOVLW 0x3
19DA  6ECA     MOVWF T2CON, ACCESS
19DC  929D     BCF PIE1, 1, ACCESS
19DE  929E     BCF PIR1, 1, ACCESS
664:           					Serial_Init_None();
19E0  808B     BSF LATC, 0, ACCESS
19E2  9A9D     BCF PIE1, 5, ACCESS
19E4  989D     BCF PIE1, 4, ACCESS
665:           					FraiseState=fIDLE;
19E6  0101     MOVLB 0x1
19E8  6BD4     CLRF 0xD4, BANKED
666:           					//if(!TST_POLLEDCHILDOK()){
667:           						//printf("\nsC%c%c\n",HI_CHAR(PolledChild()),LO_CHAR(PolledChild()));
668:                                                           FraiseMessage=fmessFOUND;
19EA  0101     MOVLB 0x1
19EC  0E01     MOVLW 0x1
19EE  6FD5     MOVWF CDC_Inbdp, BANKED
669:           						//SET_POLLEDCHILDOK();
670:           					//}
671:           				} else {
19F0  D00B     BRA 0x1A08
672:           					if(c&128) FraiseStatus.RXCHAR=1; 
19F2  50DF     MOVF INDF2, W, ACCESS
19F4  6E14     MOVWF __tmp_0, ACCESS
19F6  6A15     CLRF digit_cnt, ACCESS
19F8  5014     MOVF __tmp_0, W, ACCESS
19FA  0B80     ANDLW 0x80
19FC  E003     BZ 0x1A04
19FE  0101     MOVLB 0x1
1A00  83CB     BSF cdc_In_len, 1, BANKED
673:           					else FraiseStatus.RXCHAR=0;
1A02  D002     BRA 0x1A08
1A04  0101     MOVLB 0x1
1A06  93CB     BCF cdc_In_len, 1, BANKED
674:           					//printf("in len=%d ",FrRXout-1);	
675:           				}	
676:           			}
677:           			//else
678:           			FrRXchksum+=c;
1A08  50DF     MOVF INDF2, W, ACCESS
1A0A  0101     MOVLB 0x1
1A0C  27C8     ADDWF 0xC8, F, BANKED
679:           			
680:           			if(FrRXin>FrRXout){ //end of packet
1A0E  0101     MOVLB 0x1
1A10  51C7     MOVF 0xC7, W, BANKED
1A12  0101     MOVLB 0x1
1A14  80D8     BSF STATUS, 0, ACCESS
1A16  55C6     SUBFWB 0xC6, W, BANKED
1A18  E21A     BC 0x1A4E
681:           				StopTimer();
1A1A  0E03     MOVLW 0x3
1A1C  6ECA     MOVWF T2CON, ACCESS
1A1E  929D     BCF PIE1, 1, ACCESS
1A20  929E     BCF PIR1, 1, ACCESS
682:           				Serial_Init_None();
1A22  808B     BSF LATC, 0, ACCESS
1A24  9A9D     BCF PIE1, 5, ACCESS
1A26  989D     BCF PIE1, 4, ACCESS
683:           				FraiseState=fIDLE;
1A28  0101     MOVLB 0x1
1A2A  6BD4     CLRF 0xD4, BANKED
684:           				if(!FrRXchksum) { //checksum ok
1A2C  0101     MOVLB 0x1
1A2E  51C8     MOVF 0xC8, W, BANKED
1A30  E109     BNZ 0x1A44
685:           					//printf(" ok\n");
686:           					FrRXin--; //discard checksum
1A32  0101     MOVLB 0x1
1A34  07C6     DECF 0xC6, F, BANKED
687:           					FraiseStatus.RXFULL=1;
1A36  0101     MOVLB 0x1
1A38  81CB     BSF cdc_In_len, 0, BANKED
688:           					//FrRXout=0;
689:           					//if(!TST_POLLEDCHILDOK()){
690:           						//printf("\nsC%c%c\n",HI_CHAR(PolledChild()),LO_CHAR(PolledChild()));
691:                                                           FraiseMessage=fmessFOUND;
1A3A  0101     MOVLB 0x1
1A3C  0E01     MOVLW 0x1
1A3E  6FD5     MOVWF CDC_Inbdp, BANKED
692:           						//SET_POLLEDCHILDOK();
693:           					//}
694:           					TXREG=0; //ACK
1A40  6AAD     CLRF TXREG, ACCESS
695:           				} else {//checksum error
1A42  D005     BRA 0x1A4E
696:           					//printf("\nsRxCsErr\n");
697:                                                   FraiseMessage=fmessCHKSUM;
1A44  0101     MOVLB 0x1
1A46  0E03     MOVLW 0x3
1A48  6FD5     MOVWF CDC_Inbdp, BANKED
698:           					TXREG=1; //NACK
1A4A  0E01     MOVLW 0x1
1A4C  6EAD     MOVWF TXREG, ACCESS
699:           				}
700:           			}//end of if end of packet
701:           			return;
1A4E  D08F     BRA 0x1B6E
702:           		} //endif(PIR1bits.RCIF) 
703:           		
704:           		return;
1A50  D08E     BRA 0x1B6E
705:           	}//endif (FraiseState==fIn)
706:           	else if(FraiseState==fOUT) //if we are sending a packet to a child:
1A52  D08D     BRA 0x1B6E
1A54  0E02     MOVLW 0x2
1A56  0101     MOVLB 0x1
1A58  5DD4     SUBWF 0xD4, W, BANKED
1A5A  E134     BNZ 0x1AC4
707:           	{
708:           		StopTimer();
1A5C  0E03     MOVLW 0x3
1A5E  6ECA     MOVWF T2CON, ACCESS
1A60  929D     BCF PIE1, 1, ACCESS
1A62  929E     BCF PIR1, 1, ACCESS
709:           		if(PIR1bits.TXIF==0) return;
1A64  A89E     BTFSS PIR1, 4, ACCESS
1A66  D083     BRA 0x1B6E
710:           		TXREG=FrTXpacket[FrTXpacket_i++]; // send next byte 
1A68  0101     MOVLB 0x1
1A6A  5182     MOVF 0x82, W, BANKED
1A6C  2B82     INCF 0x82, F, BANKED
1A6E  6AEA     CLRF FSR0H, ACCESS
1A70  0F42     ADDLW 0x42
1A72  6EE9     MOVWF FSR0L, ACCESS
1A74  0E01     MOVLW 0x1
1A76  22EA     ADDWFC FSR0H, F, ACCESS
1A78  50EF     MOVF INDF0, W, ACCESS
1A7A  6EAD     MOVWF TXREG, ACCESS
711:           		if(FrTXpacket_i==FrTXpacket_len) { //if end of the packet:
1A7C  0101     MOVLB 0x1
1A7E  5183     MOVF 0x83, W, BANKED
1A80  0101     MOVLB 0x1
1A82  5D82     SUBWF 0x82, W, BANKED
1A84  E11D     BNZ 0x1AC0
712:           			PIE1bits.TXIE=0;
1A86  989D     BCF PIE1, 4, ACCESS
713:           			if(FraiseStatus.TX_NEEDACK){
1A88  0101     MOVLB 0x1
1A8A  A7CB     BTFSS cdc_In_len, 3, BANKED
1A8C  D00B     BRA 0x1AA4
714:           				InitTimer(T_2SERBYTES); //2 bytes wait inside of hardware serial tx buffer
1A8E  929D     BCF PIE1, 1, ACCESS
1A90  0E07     MOVLW 0x7
1A92  6ECA     MOVWF T2CON, ACCESS
1A94  0ED3     MOVLW 0xD3
1A96  6ECC     MOVWF TMR2, ACCESS
1A98  929E     BCF PIR1, 1, ACCESS
1A9A  829D     BSF PIE1, 1, ACCESS
715:           				//InitTMR0(TMR0_1ms);
716:           				FraiseState=fWAITACK; 	// goto to WAITACK state.
1A9C  0101     MOVLB 0x1
1A9E  0E01     MOVLW 0x1
1AA0  6FD4     MOVWF 0xD4, BANKED
717:           			}
718:           			else {
1AA2  D00E     BRA 0x1AC0
719:           				if(FraiseStatus.FBLDON) {
1AA4  0101     MOVLB 0x1
1AA6  A9CB     BTFSS cdc_In_len, 4, BANKED
1AA8  D006     BRA 0x1AB6
720:           					Serial_Init_Receiver();
1AAA  EC28     CALL 0x850, 0
1AAC  F004     NOP
721:           					FraiseState=fBLIN;
1AAE  0101     MOVLB 0x1
1AB0  0E05     MOVLW 0x5
1AB2  6FD4     MOVWF 0xD4, BANKED
722:           				}
723:           				else {
1AB4  D005     BRA 0x1AC0
724:                                               FraiseState=fIDLE; // return to IDLE state.
1AB6  0101     MOVLB 0x1
1AB8  6BD4     CLRF 0xD4, BANKED
725:                                               Serial_Init_None();
1ABA  808B     BSF LATC, 0, ACCESS
1ABC  9A9D     BCF PIE1, 5, ACCESS
1ABE  989D     BCF PIE1, 4, ACCESS
726:                                           }
727:           			}
728:           		}
729:           		return;
1AC0  D056     BRA 0x1B6E
730:           	}
731:           	else if(FraiseState==fBLOUT) //if we are sending a bootloader packet :
1AC2  D055     BRA 0x1B6E
1AC4  0E04     MOVLW 0x4
1AC6  0101     MOVLB 0x1
1AC8  5DD4     SUBWF 0xD4, W, BANKED
1ACA  E126     BNZ 0x1B18
732:           	{
733:           		StopTimer();
1ACC  0E03     MOVLW 0x3
1ACE  6ECA     MOVWF T2CON, ACCESS
1AD0  929D     BCF PIE1, 1, ACCESS
1AD2  929E     BCF PIR1, 1, ACCESS
734:           		if(PIR1bits.TXIF==0) return;
1AD4  A89E     BTFSS PIR1, 4, ACCESS
1AD6  D04B     BRA 0x1B6E
735:           		TXREG=FrTXpacket[FrTXpacket_i++]; // send next byte 
1AD8  0101     MOVLB 0x1
1ADA  5182     MOVF 0x82, W, BANKED
1ADC  2B82     INCF 0x82, F, BANKED
1ADE  6AEA     CLRF FSR0H, ACCESS
1AE0  0F42     ADDLW 0x42
1AE2  6EE9     MOVWF FSR0L, ACCESS
1AE4  0E01     MOVLW 0x1
1AE6  22EA     ADDWFC FSR0H, F, ACCESS
1AE8  50EF     MOVF INDF0, W, ACCESS
1AEA  6EAD     MOVWF TXREG, ACCESS
736:           		if(FrTXpacket_i==FrTXpacket_len) { //if end of the packet:
1AEC  0101     MOVLB 0x1
1AEE  5183     MOVF 0x83, W, BANKED
1AF0  0101     MOVLB 0x1
1AF2  5D82     SUBWF 0x82, W, BANKED
1AF4  E10F     BNZ 0x1B14
737:           			PIE1bits.TXIE=0;
1AF6  989D     BCF PIE1, 4, ACCESS
738:           			InitTimer(T_2SERBYTES); //2 bytes wait inside of hardware serial tx buffer
1AF8  929D     BCF PIE1, 1, ACCESS
1AFA  0E07     MOVLW 0x7
1AFC  6ECA     MOVWF T2CON, ACCESS
1AFE  0ED3     MOVLW 0xD3
1B00  6ECC     MOVWF TMR2, ACCESS
1B02  929E     BCF PIR1, 1, ACCESS
1B04  829D     BSF PIE1, 1, ACCESS
739:           			FraiseState=fBLIN; 	// goto to BLIN state.
1B06  0101     MOVLB 0x1
1B08  0E05     MOVLW 0x5
1B0A  6FD4     MOVWF 0xD4, BANKED
740:           			FrRXin=FrRXout=0;
1B0C  0101     MOVLB 0x1
1B0E  6BC7     CLRF 0xC7, BANKED
1B10  C1C7     MOVFF FrRXout, FrRXin
1B12  F1C6     NOP
741:           		}
742:           		return;
1B14  D02C     BRA 0x1B6E
743:           	}	//endif(FraiseState==fBLOUT)
744:           	else if(FraiseState==fBLIN) 
1B16  D02B     BRA 0x1B6E
1B18  0E05     MOVLW 0x5
1B1A  0101     MOVLB 0x1
1B1C  5DD4     SUBWF 0xD4, W, BANKED
1B1E  E11D     BNZ 0x1B5A
745:           	{
746:           		if (!Serial_Is_Receiver()) {
1B20  BA9D     BTFSC PIE1, 5, ACCESS
1B22  D009     BRA 0x1B36
747:           			if (TimerOut()) {
1B24  A29E     BTFSS PIR1, 1, ACCESS
1B26  D006     BRA 0x1B34
748:           				Serial_Init_Receiver();
1B28  EC28     CALL 0x850, 0
1B2A  F004     NOP
749:           				StopTimer();
1B2C  0E03     MOVLW 0x3
1B2E  6ECA     MOVWF T2CON, ACCESS
1B30  929D     BCF PIE1, 1, ACCESS
1B32  929E     BCF PIR1, 1, ACCESS
750:           			}
751:           			return;
1B34  D01C     BRA 0x1B6E
752:           		}
753:           		if(PIR1bits.RCIF) {
1B36  AA9E     BTFSS PIR1, 5, ACCESS
1B38  D00E     BRA 0x1B56
754:           			//StopTimer();
755:           			c=RCREG;
1B3A  50AE     MOVF RCREG, W, ACCESS
1B3C  6EDF     MOVWF INDF2, ACCESS
756:           			FrRXbuf[FrRXin]=c;
1B3E  0101     MOVLB 0x1
1B40  51C6     MOVF 0xC6, W, BANKED
1B42  6AEA     CLRF FSR0H, ACCESS
1B44  0F86     ADDLW 0x86
1B46  6EE9     MOVWF FSR0L, ACCESS
1B48  0E01     MOVLW 0x1
1B4A  22EA     ADDWFC FSR0H, F, ACCESS
1B4C  CFDF     MOVFF INDF2, INDF0
1B4E  FFEF     NOP
757:           			FrRXin++;
1B50  0101     MOVLB 0x1
1B52  2BC6     INCF 0xC6, F, BANKED
758:           			return;
1B54  D00C     BRA 0x1B6E
759:           		}
760:           		return;
1B56  D00B     BRA 0x1B6E
761:           	}	//endif(FraiseState==fBLIN)
762:           	else if(FraiseState==fIDLE)	//should't happen... clear interrupt flags:	
1B58  D00A     BRA 0x1B6E
1B5A  0101     MOVLB 0x1
1B5C  51D4     MOVF 0xD4, W, BANKED
1B5E  E107     BNZ 0x1B6E
763:           	{
764:           		StopTimer();
1B60  0E03     MOVLW 0x3
1B62  6ECA     MOVWF T2CON, ACCESS
1B64  929D     BCF PIE1, 1, ACCESS
1B66  929E     BCF PIR1, 1, ACCESS
765:           		//PIE1bits.TMR2IE=0;
766:           		PIE1bits.TXIE=0;
1B68  989D     BCF PIE1, 4, ACCESS
767:           		PIE1bits.RCIE=0;
1B6A  9A9D     BCF PIE1, 5, ACCESS
768:           		return;
1B6C  D000     BRA 0x1B6E
769:           	}
770:           
771:           } //end of LowISR
1B6E  52E5     MOVF POSTDEC1, F, ACCESS
1B70  52E5     MOVF POSTDEC1, F, ACCESS
1B72  CFE7     MOVFF INDF1, FSR2L
1B74  FFD9     NOP
1B76  0012     RETURN 0
772:           
773:           void FraiseService(void)
774:           {
775:           	//unsigned char c;
776:           	//static char TXNtries=0; //number of tries to send the TX packet
777:           	
778:                   //if(FrGotLineFromUsb&&(FraiseState==fIDLE)) FrGetLineFromUsb();
779:                   //goto _fin;
780:               //FraiseState=fIDLE;
781:           	/*if(fIDLE==FraiseState) {
782:           		mLED_2_On();
783:           		if(FrGotLineFromUsb) {
784:                               FrGetLineFromUsb(); //
785:                               goto _fin;
786:                           }
787:                   } else { mLED_2_Off(); }*/
788:           
789:                   FrSendMessagetoUsb();
1B78  EC4C     CALL 0xA98, 0
1B7A  F005     NOP
790:           
791:                   if(FraiseState==fBLIN) { 
1B7C  0E05     MOVLW 0x5
1B7E  0101     MOVLB 0x1
1B80  5DD4     SUBWF 0xD4, W, BANKED
1B82  E119     BNZ 0x1BB6
792:           		while(FrRXin!=FrRXout) putchar(FrRXbuf[FrRXout++]);
1B84  0101     MOVLB 0x1
1B86  51C7     MOVF 0xC7, W, BANKED
1B88  0101     MOVLB 0x1
1B8A  5DC6     SUBWF 0xC6, W, BANKED
1B8C  E00E     BZ 0x1BAA
1B8E  0101     MOVLB 0x1
1B90  51C7     MOVF 0xC7, W, BANKED
1B92  2BC7     INCF 0xC7, F, BANKED
1B94  6AEA     CLRF FSR0H, ACCESS
1B96  0F86     ADDLW 0x86
1B98  6EE9     MOVWF FSR0L, ACCESS
1B9A  0E01     MOVLW 0x1
1B9C  22EA     ADDWFC FSR0H, F, ACCESS
1B9E  50EF     MOVF INDF0, W, ACCESS
1BA0  6EE6     MOVWF POSTINC1, ACCESS
1BA2  EC26     CALL 0x424C, 0
1BA4  F021     NOP
1BA6  52E5     MOVF POSTDEC1, F, ACCESS
1BA8  D7ED     BRA 0x1B84
793:           		if(FrGotLineFromUsb) FrGetLineFromUsb();
1BAA  0101     MOVLB 0x1
1BAC  5141     MOVF 0x41, W, BANKED
1BAE  E002     BZ 0x1BB4
1BB0  EC2F     CALL 0xE5E, 0
1BB2  F007     NOP
794:           
795:           		goto _fin;
1BB4  D0A5     BRA 0x1D00
796:           	}
797:           	
798:           	INTCONbits.GIEH = 0;
1BB6  9EF2     BCF INTCON, 7, ACCESS
799:           
800:                   if(FraiseState==fIDLE) {
1BB8  0101     MOVLB 0x1
1BBA  51D4     MOVF 0xD4, W, BANKED
1BBC  E15F     BNZ 0x1C7C
801:           		StopTimer();
1BBE  0E03     MOVLW 0x3
1BC0  6ECA     MOVWF T2CON, ACCESS
1BC2  929D     BCF PIE1, 1, ACCESS
1BC4  929E     BCF PIR1, 1, ACCESS
802:                           
803:           		if(FrGotLineFromUsb) {
1BC6  0101     MOVLB 0x1
1BC8  5141     MOVF 0x41, W, BANKED
1BCA  E003     BZ 0x1BD2
804:                               FrGetLineFromUsb();
1BCC  EC2F     CALL 0xE5E, 0
1BCE  F007     NOP
805:                               goto _fin;
1BD0  D097     BRA 0x1D00
806:                           }
807:                           //goto _fin;
808:           		if(!FraiseStatus.RXFULL){
1BD2  0101     MOVLB 0x1
1BD4  B1CB     BTFSC cdc_In_len, 0, BANKED
1BD6  D051     BRA 0x1C7A
809:                                   if(PollCount>=PollDelay) {
1BD8  0101     MOVLB 0x1
1BDA  51C9     MOVF cls, W, BANKED
1BDC  0101     MOVLB 0x1
1BDE  5DCA     SUBWF 0xCA, W, BANKED
1BE0  E34C     BNC 0x1C7A
810:                                       PollCount=0;
1BE2  0101     MOVLB 0x1
1BE4  6BCA     CLRF 0xCA, BANKED
811:                                       //while(TXSTAbits.TRMT==0);
812:                                       incPolledChild();
1BE6  0101     MOVLB 0x1
1BE8  2BD6     INCF 0xD6, F, BANKED
1BEA  0101     MOVLB 0x1
1BEC  51D8     MOVF cdc_trf_state, W, BANKED
1BEE  0101     MOVLB 0x1
1BF0  80D8     BSF STATUS, 0, ACCESS
1BF2  55D6     SUBFWB 0xD6, W, BANKED
1BF4  E207     BC 0x1C04
1BF6  0101     MOVLB 0x1
1BF8  0E01     MOVLW 0x1
1BFA  6FD6     MOVWF 0xD6, BANKED
1BFC  0101     MOVLB 0x1
1BFE  0E02     MOVLW 0x2
1C00  6FD7     MOVWF CDCFunctionError, BANKED
1C02  D00A     BRA 0x1C18
1C04  0101     MOVLB 0x1
1C06  45D7     RLNCF CDCFunctionError, W, BANKED
1C08  0B01     ANDLW 0x1
1C0A  6E14     MOVWF __tmp_0, ACCESS
1C0C  0101     MOVLB 0x1
1C0E  51D7     MOVF CDCFunctionError, W, BANKED
1C10  24E8     ADDWF WREG, W, ACCESS
1C12  1014     IORWF __tmp_0, W, ACCESS
1C14  0101     MOVLB 0x1
1C16  6FD7     MOVWF CDCFunctionError, BANKED
813:                                       if(TST_POLLEDCHILD())
1C18  0101     MOVLB 0x1
1C1A  51D6     MOVF 0xD6, W, BANKED
1C1C  40E8     RRNCF WREG, W, ACCESS
1C1E  40E8     RRNCF WREG, W, ACCESS
1C20  40E8     RRNCF WREG, W, ACCESS
1C22  0B1F     ANDLW 0x1F
1C24  6AEA     CLRF FSR0H, ACCESS
1C26  0FD9     ADDLW 0xD9
1C28  6EE9     MOVWF FSR0L, ACCESS
1C2A  0E01     MOVLW 0x1
1C2C  22EA     ADDWFC FSR0H, F, ACCESS
1C2E  50EF     MOVF INDF0, W, ACCESS
1C30  0101     MOVLB 0x1
1C32  15D7     ANDWF CDCFunctionError, W, BANKED
1C34  E022     BZ 0x1C7A
814:                                       {
815:                                               //PIE1bits.TXIE=0;
816:                                               FrRXchksum=FrRXin=FrRXout=0;
1C36  0101     MOVLB 0x1
1C38  6BC7     CLRF 0xC7, BANKED
1C3A  C1C7     MOVFF FrRXout, FrRXin
1C3C  F1C6     NOP
1C3E  C1C7     MOVFF FrRXout, FrRXchksum
1C40  F1C8     NOP
817:                                               TXSTAbits.TX9D=1;
1C42  80AC     BSF TXSTA, 0, ACCESS
818:           
819:                                               Serial_Init_Driver();
1C44  908B     BCF LATC, 0, ACCESS
1C46  9A9D     BCF PIE1, 5, ACCESS
820:                                               FrSendMessagetoUsb();
1C48  EC4C     CALL 0xA98, 0
1C4A  F005     NOP
821:                                               INTCONbits.GIEL=0;
1C4C  9CF2     BCF INTCON, 6, ACCESS
822:                                               AckChild=PolledChild();
1C4E  C1D6     MOVFF _PolledChild, AckChild
1C50  F1F9     NOP
823:                                               TXREG=(PolledChild()|128);
1C52  0E80     MOVLW 0x80
1C54  0101     MOVLB 0x1
1C56  11D6     IORWF 0xD6, W, BANKED
1C58  6EAD     MOVWF TXREG, ACCESS
824:                                               TXSTAbits.TX9D=0;
1C5A  90AC     BCF TXSTA, 0, ACCESS
825:                                               TXREG=(PolledChild()|128);
1C5C  0E80     MOVLW 0x80
1C5E  0101     MOVLB 0x1
1C60  11D6     IORWF 0xD6, W, BANKED
1C62  6EAD     MOVWF TXREG, ACCESS
826:                                               InitTimer(T_2SERBYTES);
1C64  929D     BCF PIE1, 1, ACCESS
1C66  0E07     MOVLW 0x7
1C68  6ECA     MOVWF T2CON, ACCESS
1C6A  0ED3     MOVLW 0xD3
1C6C  6ECC     MOVWF TMR2, ACCESS
1C6E  929E     BCF PIR1, 1, ACCESS
1C70  829D     BSF PIE1, 1, ACCESS
827:                                               FraiseState=fIN;
1C72  0101     MOVLB 0x1
1C74  0E03     MOVLW 0x3
1C76  6FD4     MOVWF 0xD4, BANKED
828:                                               INTCONbits.GIEL=1;
1C78  8CF2     BSF INTCON, 6, ACCESS
829:                                       }
830:                                   }
831:           		}
832:           	} else if(FraiseState==fWAITACK) { 
1C7A  D042     BRA 0x1D00
1C7C  0101     MOVLB 0x1
1C7E  05D4     DECF 0xD4, W, BANKED
1C80  E129     BNZ 0x1CD4
833:           		if((Serial_Is_Receiver()) && TimerOut() ){ //didn't rcved ACK before Timeout
1C82  509D     MOVF PIE1, W, ACCESS
1C84  0B20     ANDLW 0x20
1C86  E025     BZ 0x1CD2
1C88  509E     MOVF PIR1, W, ACCESS
1C8A  0B02     ANDLW 0x2
1C8C  E022     BZ 0x1CD2
834:            			StopTimer();
1C8E  0E03     MOVLW 0x3
1C90  6ECA     MOVWF T2CON, ACCESS
1C92  929D     BCF PIE1, 1, ACCESS
1C94  929E     BCF PIR1, 1, ACCESS
835:           			Serial_Init_None();
1C96  808B     BSF LATC, 0, ACCESS
1C98  9A9D     BCF PIE1, 5, ACCESS
1C9A  989D     BCF PIE1, 4, ACCESS
836:           			if(++FrTXtries<3) { FrTXPacketLaunch(); }// resend packet maximum 3 times
1C9C  0101     MOVLB 0x1
1C9E  2B85     INCF 0x85, F, BANKED
1CA0  0E03     MOVLW 0x3
1CA2  0101     MOVLB 0x1
1CA4  5D85     SUBWF 0x85, W, BANKED
1CA6  E210     BC 0x1CC8
1CA8  908B     BCF LATC, 0, ACCESS
1CAA  9A9D     BCF PIE1, 5, ACCESS
1CAC  80AC     BSF TXSTA, 0, ACCESS
1CAE  C142     MOVFF FrTXpacket, AckChild
1CB0  F1F9     NOP
1CB2  C142     MOVFF FrTXpacket, TXREG
1CB4  FFAD     NOP
1CB6  90AC     BCF TXSTA, 0, ACCESS
1CB8  0101     MOVLB 0x1
1CBA  0E01     MOVLW 0x1
1CBC  6F82     MOVWF 0x82, BANKED
1CBE  0101     MOVLB 0x1
1CC0  0E02     MOVLW 0x2
1CC2  6FD4     MOVWF 0xD4, BANKED
1CC4  889D     BSF PIE1, 4, ACCESS
837:           			else 
1CC6  D005     BRA 0x1CD2
838:           			{
839:           				//printf((STRING)"sT%c%c\n",HI_CHAR(AckChild),LO_CHAR(AckChild));
840:           				FraiseMessage=fmessTOUT;
1CC8  0101     MOVLB 0x1
1CCA  0E05     MOVLW 0x5
1CCC  6FD5     MOVWF CDC_Inbdp, BANKED
841:                                           FraiseState=fIDLE;
1CCE  0101     MOVLB 0x1
1CD0  6BD4     CLRF 0xD4, BANKED
842:           			}
843:           		}	
844:           	} else if(FraiseState==fIN){
1CD2  D016     BRA 0x1D00
1CD4  0E03     MOVLW 0x3
1CD6  0101     MOVLB 0x1
1CD8  5DD4     SUBWF 0xD4, W, BANKED
1CDA  E112     BNZ 0x1D00
845:           		if( (Serial_Is_Receiver()) && TimerOut() ){ //Timeout
1CDC  509D     MOVF PIE1, W, ACCESS
1CDE  0B20     ANDLW 0x20
1CE0  E00F     BZ 0x1D00
1CE2  509E     MOVF PIR1, W, ACCESS
1CE4  0B02     ANDLW 0x2
1CE6  E00C     BZ 0x1D00
846:           			StopTimer();
1CE8  0E03     MOVLW 0x3
1CEA  6ECA     MOVWF T2CON, ACCESS
1CEC  929D     BCF PIE1, 1, ACCESS
1CEE  929E     BCF PIR1, 1, ACCESS
847:           			/*if(TST_POLLEDCHILDOK()){
848:           				printf((STRING)"\nsc%c%c\n",HI_CHAR(PolledChild()),LO_CHAR(PolledChild()));
849:           				CLR_POLLEDCHILDOK();
850:           			}*/
851:                                   FraiseMessage=fmessLOST;
1CF0  0101     MOVLB 0x1
1CF2  0E02     MOVLW 0x2
1CF4  6FD5     MOVWF CDC_Inbdp, BANKED
852:           			//printf("fIN timeout!\n");
853:           			Serial_Init_None();
1CF6  808B     BSF LATC, 0, ACCESS
1CF8  9A9D     BCF PIE1, 5, ACCESS
1CFA  989D     BCF PIE1, 4, ACCESS
854:           			FraiseState=fIDLE;
1CFC  0101     MOVLB 0x1
1CFE  6BD4     CLRF 0xD4, BANKED
855:           		}
856:           	}
857:           
858:           _fin : 
859:           	INTCONbits.GIEH = 1;
1D00  8EF2     BSF INTCON, 7, ACCESS
860:           
861:                   FrSendtoUsb();
1D02  EC8A     CALL 0x914, 0
1D04  F004     NOP
862:           }
1D06  0012     RETURN 0
863:           	
864:           void FraiseSOF(void)
865:           {
866:               static BYTE il;
867:           
868:               if((il++)==200) { il=0; mLED_2_Toggle(); }
1D08  0101     MOVLB 0x1
1D0A  51FA     MOVF 0xFA, W, BANKED
1D0C  2BFA     INCF 0xFA, F, BANKED
1D0E  6E14     MOVWF __tmp_0, ACCESS
1D10  6A15     CLRF digit_cnt, ACCESS
1D12  0EC8     MOVLW 0xC8
1D14  1814     XORWF __tmp_0, W, ACCESS
1D16  E101     BNZ 0x1D1A
1D18  5015     MOVF digit_cnt, W, ACCESS
1D1A  E103     BNZ 0x1D22
1D1C  0101     MOVLB 0x1
1D1E  6BFA     CLRF 0xFA, BANKED
1D20  728B     BTG LATC, 1, ACCESS
869:           
870:               if(++PollCount==0) PollCount=255;
1D22  0101     MOVLB 0x1
1D24  2BCA     INCF 0xCA, F, BANKED
1D26  E102     BNZ 0x1D2C
1D28  0101     MOVLB 0x1
1D2A  69CA     SETF 0xCA, BANKED
871:           }
1D2C  0012     RETURN 0
872:           
